{"version":3,"sources":["../../src/learning/config.ts","../../src/learning/data-sources/eval-source.ts","../../src/learning/data-sources/jsonl-source.ts","../../src/learning/data-sources/index.ts","../../src/learning/explanation-generator.ts","../../src/learning/pattern-detector.ts","../../src/learning/rule-generator.ts","../../src/learning/cli-reviewer.ts","../../src/learning/rule-writer.ts","../../src/learning/learning-runner.ts"],"names":["__filename","__dirname","config","fs","path","fileURLToPath","readline","dotenv2","readline2"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Configuration for the Prompt Learning System\n */\n\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport interface LearningConfig {\n  // Analysis settings\n  /** Minimum number of failures to form a pattern */\n  minFailuresForPattern: number;\n\n  /** Similarity threshold for grouping failures (0-1) */\n  similarityThreshold: number;\n\n  /** Maximum failures to process per iteration */\n  maxFailuresPerIteration: number;\n\n  // Rule generation settings\n  /** Model to use for explanation generation */\n  explanationModel: string;\n\n  /** Model to use for rule generation */\n  ruleGenerationModel: string;\n\n  /** Maximum rules to suggest per iteration */\n  maxRulesPerIteration: number;\n\n  /** Minimum confidence to include a rule */\n  minRuleConfidence: number;\n\n  // Validation settings\n  /** Number of evals to run for validation */\n  validationRunSize: number;\n\n  /** Maximum acceptable regression percentage */\n  regressionThreshold: number;\n\n  // Directories\n  /** Directory for the learning system */\n  learningDir: string;\n\n  /** Directory for prompts */\n  promptsDir: string;\n\n  /** Directory for rules */\n  rulesDir: string;\n\n  /** Directory for pending rules */\n  pendingDir: string;\n\n  /** Directory for approved rules */\n  approvedDir: string;\n\n  /** Directory for rejected rules */\n  rejectedDir: string;\n\n  /** Path to learned rules JSON */\n  learnedRulesPath: string;\n\n  /** Path to learning history */\n  historyPath: string;\n\n  /** Directory for eval results (to read from) */\n  evalResultsDir: string;\n}\n\nconst LEARNING_DIR = path.join(__dirname);\nconst RULES_DIR = path.join(LEARNING_DIR, 'rules');\nconst EVAL_RESULTS_DIR = path.join(__dirname, '..', 'results');\n\nexport const DEFAULT_LEARNING_CONFIG: LearningConfig = {\n  // Analysis settings\n  minFailuresForPattern: 2,\n  similarityThreshold: 0.7,\n  maxFailuresPerIteration: 100,\n\n  // Rule generation settings\n  explanationModel: 'claude-sonnet-4-20250514',\n  ruleGenerationModel: 'claude-sonnet-4-20250514',\n  maxRulesPerIteration: 5,\n  minRuleConfidence: 0.6,\n\n  // Validation settings\n  validationRunSize: 10,\n  regressionThreshold: 5, // 5% max regression\n\n  // Directories\n  learningDir: LEARNING_DIR,\n  promptsDir: path.join(LEARNING_DIR, 'prompts'),\n  rulesDir: RULES_DIR,\n  pendingDir: path.join(RULES_DIR, 'pending'),\n  approvedDir: path.join(RULES_DIR, 'approved'),\n  rejectedDir: path.join(RULES_DIR, 'rejected'),\n  learnedRulesPath: path.join(RULES_DIR, 'learned-rules.json'),\n  historyPath: path.join(RULES_DIR, 'history.json'),\n  evalResultsDir: EVAL_RESULTS_DIR,\n};\n\n/**\n * Get the learning configuration, optionally with overrides\n */\nexport function getLearningConfig(\n  overrides?: Partial<LearningConfig>\n): LearningConfig {\n  return {\n    ...DEFAULT_LEARNING_CONFIG,\n    ...overrides,\n  };\n}\n\n/**\n * Environment variable overrides\n */\nexport function getConfigFromEnv(): Partial<LearningConfig> {\n  const overrides: Partial<LearningConfig> = {};\n\n  if (process.env.LEARNING_EXPLANATION_MODEL) {\n    overrides.explanationModel = process.env.LEARNING_EXPLANATION_MODEL;\n  }\n\n  if (process.env.LEARNING_RULE_MODEL) {\n    overrides.ruleGenerationModel = process.env.LEARNING_RULE_MODEL;\n  }\n\n  if (process.env.LEARNING_MIN_PATTERN_SIZE) {\n    overrides.minFailuresForPattern = parseInt(\n      process.env.LEARNING_MIN_PATTERN_SIZE,\n      10\n    );\n  }\n\n  if (process.env.LEARNING_SIMILARITY_THRESHOLD) {\n    overrides.similarityThreshold = parseFloat(\n      process.env.LEARNING_SIMILARITY_THRESHOLD\n    );\n  }\n\n  if (process.env.LEARNING_MAX_RULES) {\n    overrides.maxRulesPerIteration = parseInt(\n      process.env.LEARNING_MAX_RULES,\n      10\n    );\n  }\n\n  return overrides;\n}\n\nexport default getLearningConfig;\n","/**\n * Data source for extracting failures from eval results.\n * Reads from __evals__/results/ directory.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport type { DataSource, FailureInput, CollectOptions, ToolCall } from './types.js';\nimport type { EvalSuiteResult, EvalCaseResult } from '../../runner/eval-runner.js';\nimport type { EvalCase } from '../../config/schemas.js';\nimport { getLearningConfig } from '../config.js';\n\n/**\n * Extracts the prompt from an eval case based on its category\n */\nfunction getPromptFromEvalCase(evalCase: EvalCase): string {\n  if ('prompt' in evalCase) {\n    return evalCase.prompt;\n  }\n  if ('turns' in evalCase && evalCase.turns.length > 0) {\n    return evalCase.turns.map((t) => t.prompt).join('\\n---\\n');\n  }\n  return '';\n}\n\n/**\n * Extracts expected behavior from an eval case\n */\nfunction getExpectedBehavior(evalCase: EvalCase): string | undefined {\n  if ('expectedBehavior' in evalCase) {\n    return evalCase.expectedBehavior;\n  }\n  if ('expectedToolCalls' in evalCase) {\n    return `Expected tool calls: ${evalCase.expectedToolCalls.map((t) => t.toolName).join(', ')}`;\n  }\n  if ('expectedAgent' in evalCase) {\n    return `Expected to route to: ${evalCase.expectedAgent}`;\n  }\n  if ('targetFiles' in evalCase) {\n    return `Expected to create/modify files: ${evalCase.targetFiles.join(', ')}`;\n  }\n  return undefined;\n}\n\n/**\n * Converts an EvalCaseResult to a FailureInput\n */\nfunction evalResultToFailureInput(result: EvalCaseResult): FailureInput {\n  const toolCalls: ToolCall[] =\n    result.toolCalls?.map((tc) => ({\n      name: tc.toolName,\n      input: tc.input as Record<string, unknown>,\n      output: typeof tc.output === 'string' ? tc.output : JSON.stringify(tc.output),\n    })) ?? [];\n\n  return {\n    id: result.evalCase.id,\n    source: 'eval',\n    sourceId: result.evalCase.id,\n    prompt: getPromptFromEvalCase(result.evalCase),\n    expectedBehavior: getExpectedBehavior(result.evalCase),\n    category: result.evalCase.category,\n    output: result.output ?? '',\n    toolCalls,\n    error: result.error?.message,\n    judgeResults: result.judgeResults,\n    timestamp: new Date().toISOString(),\n    metadata: {\n      evalName: result.evalCase.name,\n      evalDescription: result.evalCase.description,\n      evalTags: result.evalCase.tags,\n      duration: result.duration,\n      retryCount: result.retryCount,\n    },\n  };\n}\n\nexport class EvalDataSource implements DataSource {\n  name = 'eval';\n  private resultsDir: string;\n\n  constructor(resultsDir?: string) {\n    const config = getLearningConfig();\n    this.resultsDir = resultsDir ?? config.evalResultsDir;\n  }\n\n  async isAvailable(): Promise<boolean> {\n    try {\n      await fs.access(this.resultsDir);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Gets the path to the latest results file\n   */\n  private async getLatestResultsPath(): Promise<string | null> {\n    try {\n      // First check for latest.json symlink/file\n      const latestPath = path.join(this.resultsDir, 'latest.json');\n      try {\n        await fs.access(latestPath);\n        return latestPath;\n      } catch {\n        // No latest.json, look for most recent eval-results file\n      }\n\n      const files = await fs.readdir(this.resultsDir);\n      const resultFiles = files\n        .filter((f) => f.startsWith('eval-results-') && f.endsWith('.json'))\n        .sort()\n        .reverse();\n\n      if (resultFiles.length === 0) {\n        return null;\n      }\n\n      return path.join(this.resultsDir, resultFiles[0]);\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Reads eval results from a file\n   */\n  private async readResults(filePath: string): Promise<EvalSuiteResult | null> {\n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n      return JSON.parse(content) as EvalSuiteResult;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Collects failed evals from the results directory\n   */\n  async collect(options?: CollectOptions): Promise<FailureInput[]> {\n    const resultsPath = await this.getLatestResultsPath();\n    if (!resultsPath) {\n      console.warn('No eval results found in', this.resultsDir);\n      return [];\n    }\n\n    const suiteResult = await this.readResults(resultsPath);\n    if (!suiteResult) {\n      console.warn('Could not parse eval results from', resultsPath);\n      return [];\n    }\n\n    // Filter to only failed results\n    let failures = suiteResult.results.filter((r) => !r.success);\n\n    // Apply category filter\n    if (options?.categories && options.categories.length > 0) {\n      failures = failures.filter((r) =>\n        options.categories!.includes(r.evalCase.category)\n      );\n    }\n\n    // Apply ID filter\n    if (options?.ids && options.ids.length > 0) {\n      failures = failures.filter((r) => options.ids!.includes(r.evalCase.id));\n    }\n\n    // Apply limit\n    if (options?.limit && options.limit > 0) {\n      failures = failures.slice(0, options.limit);\n    }\n\n    // Convert to FailureInput format\n    return failures.map(evalResultToFailureInput);\n  }\n\n  /**\n   * Gets summary statistics about available results\n   */\n  async getStats(): Promise<{\n    totalRuns: number;\n    latestRun: EvalSuiteResult | null;\n    failuresInLatest: number;\n  }> {\n    const files = await fs.readdir(this.resultsDir).catch(() => []);\n    const resultFiles = files.filter(\n      (f) => f.startsWith('eval-results-') && f.endsWith('.json')\n    );\n\n    const latestPath = await this.getLatestResultsPath();\n    const latestRun = latestPath ? await this.readResults(latestPath) : null;\n    const failuresInLatest = latestRun\n      ? latestRun.results.filter((r) => !r.success).length\n      : 0;\n\n    return {\n      totalRuns: resultFiles.length,\n      latestRun,\n      failuresInLatest,\n    };\n  }\n}\n\nexport default EvalDataSource;\n","/**\n * Data source for extracting failures from production JSONL logs.\n * Scans prompt-runs/project-* folders for .claude session logs.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { createReadStream } from 'fs';\nimport readline from 'readline';\nimport type { DataSource, FailureInput, CollectOptions, ToolCall } from './types.js';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Structure of a JSONL message entry\n */\ninterface JsonlMessage {\n  uuid: string;\n  parentUuid: string | null;\n  type: 'user' | 'assistant';\n  sessionId: string;\n  agentId?: string;\n  timestamp: string;\n  cwd?: string;\n  message: {\n    role: 'user' | 'assistant';\n    content: string | ContentBlock[];\n    model?: string;\n    id?: string;\n    stop_reason?: string | null;\n    usage?: {\n      input_tokens: number;\n      output_tokens: number;\n    };\n  };\n  toolUseResult?: string;\n  isSidechain?: boolean;\n}\n\ninterface ContentBlock {\n  type: 'text' | 'tool_use' | 'tool_result';\n  text?: string;\n  id?: string;\n  name?: string;\n  input?: Record<string, unknown>;\n  content?: string;\n  is_error?: boolean;\n  tool_use_id?: string;\n}\n\n/**\n * A session with all its messages\n */\ninterface Session {\n  sessionId: string;\n  agentId?: string;\n  messages: JsonlMessage[];\n  firstMessage: JsonlMessage;\n  lastMessage: JsonlMessage;\n  hasErrors: boolean;\n  errors: SessionError[];\n}\n\ninterface SessionError {\n  messageUuid: string;\n  toolName?: string;\n  errorMessage: string;\n  timestamp: string;\n  parentUuid?: string;\n}\n\nexport class JsonlDataSource implements DataSource {\n  name = 'jsonl';\n  private promptRunsDir: string;\n\n  constructor(promptRunsDir?: string) {\n    // Default to cdk/dev-server-manager/prompt-runs relative to project root\n    this.promptRunsDir = promptRunsDir ||\n      path.join(__dirname, '..', '..', '..', 'cdk', 'dev-server-manager', 'prompt-runs');\n  }\n\n  async isAvailable(): Promise<boolean> {\n    try {\n      await fs.access(this.promptRunsDir);\n      const projects = await this.findProjectFolders();\n      return projects.length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Finds all project-* folders in prompt-runs\n   */\n  private async findProjectFolders(): Promise<string[]> {\n    try {\n      const entries = await fs.readdir(this.promptRunsDir, { withFileTypes: true });\n      return entries\n        .filter(e => e.isDirectory() && e.name.startsWith('project-'))\n        .map(e => path.join(this.promptRunsDir, e.name));\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Finds all .jsonl files in a project's .claude folders\n   */\n  private async findJsonlFiles(projectDir: string): Promise<string[]> {\n    const jsonlFiles: string[] = [];\n\n    const searchDir = async (dir: string) => {\n      try {\n        const entries = await fs.readdir(dir, { withFileTypes: true });\n        for (const entry of entries) {\n          const fullPath = path.join(dir, entry.name);\n          if (entry.isDirectory()) {\n            await searchDir(fullPath);\n          } else if (entry.isFile() && entry.name.endsWith('.jsonl')) {\n            jsonlFiles.push(fullPath);\n          }\n        }\n      } catch {\n        // Ignore permission errors\n      }\n    };\n\n    await searchDir(projectDir);\n    return jsonlFiles;\n  }\n\n  /**\n   * Parses a JSONL file into messages\n   */\n  private async parseJsonlFile(filePath: string): Promise<JsonlMessage[]> {\n    const messages: JsonlMessage[] = [];\n\n    const fileStream = createReadStream(filePath);\n    const rl = readline.createInterface({\n      input: fileStream,\n      crlfDelay: Infinity,\n    });\n\n    for await (const line of rl) {\n      if (line.trim()) {\n        try {\n          const parsed = JSON.parse(line) as JsonlMessage;\n          messages.push(parsed);\n        } catch {\n          // Skip malformed lines\n        }\n      }\n    }\n\n    return messages;\n  }\n\n  /**\n   * Groups messages into sessions\n   */\n  private groupIntoSessions(messages: JsonlMessage[]): Session[] {\n    const sessionMap = new Map<string, JsonlMessage[]>();\n\n    for (const msg of messages) {\n      const key = msg.agentId || msg.sessionId;\n      if (!sessionMap.has(key)) {\n        sessionMap.set(key, []);\n      }\n      sessionMap.get(key)!.push(msg);\n    }\n\n    const sessions: Session[] = [];\n\n    for (const [key, msgs] of sessionMap) {\n      // Sort by timestamp\n      msgs.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n\n      // Find errors\n      const errors: SessionError[] = [];\n      for (const msg of msgs) {\n        const msgErrors = this.extractErrors(msg);\n        errors.push(...msgErrors);\n      }\n\n      if (msgs.length > 0) {\n        sessions.push({\n          sessionId: msgs[0].sessionId,\n          agentId: msgs[0].agentId,\n          messages: msgs,\n          firstMessage: msgs[0],\n          lastMessage: msgs[msgs.length - 1],\n          hasErrors: errors.length > 0,\n          errors,\n        });\n      }\n    }\n\n    return sessions;\n  }\n\n  /**\n   * Extracts errors from a message\n   */\n  private extractErrors(msg: JsonlMessage): SessionError[] {\n    const errors: SessionError[] = [];\n\n    // Check toolUseResult for errors\n    if (msg.toolUseResult) {\n      const resultStr = typeof msg.toolUseResult === 'string'\n        ? msg.toolUseResult\n        : JSON.stringify(msg.toolUseResult);\n      if (resultStr.toLowerCase().includes('error')) {\n        errors.push({\n          messageUuid: msg.uuid,\n          errorMessage: resultStr,\n          timestamp: msg.timestamp,\n          parentUuid: msg.parentUuid || undefined,\n        });\n      }\n    }\n\n    // Check content for tool_result with is_error\n    if (Array.isArray(msg.message?.content)) {\n      for (const block of msg.message.content) {\n        if (block.type === 'tool_result' && block.is_error) {\n          errors.push({\n            messageUuid: msg.uuid,\n            toolName: this.findToolNameForResult(msg, block.tool_use_id),\n            errorMessage: typeof block.content === 'string' ? block.content : JSON.stringify(block.content),\n            timestamp: msg.timestamp,\n            parentUuid: msg.parentUuid || undefined,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Finds the tool name for a tool_use_id by looking at parent messages\n   */\n  private findToolNameForResult(msg: JsonlMessage, toolUseId?: string): string | undefined {\n    if (!toolUseId) return undefined;\n\n    // Look in the message content for matching tool_use\n    if (Array.isArray(msg.message?.content)) {\n      for (const block of msg.message.content) {\n        if (block.type === 'tool_use' && block.id === toolUseId) {\n          return block.name;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Extracts the initial prompt from a session\n   */\n  private extractPrompt(session: Session): string {\n    const firstUserMsg = session.messages.find(m => m.type === 'user');\n    if (!firstUserMsg) return '';\n\n    const content = firstUserMsg.message?.content;\n    if (typeof content === 'string') {\n      return content;\n    }\n    if (Array.isArray(content)) {\n      const textBlock = content.find(b => b.type === 'text');\n      return textBlock?.text || '';\n    }\n    return '';\n  }\n\n  /**\n   * Extracts all tool calls from a session\n   */\n  private extractToolCalls(session: Session): ToolCall[] {\n    const toolCalls: ToolCall[] = [];\n    const toolUseMap = new Map<string, ContentBlock>();\n\n    // First pass: collect tool_use blocks\n    for (const msg of session.messages) {\n      if (Array.isArray(msg.message?.content)) {\n        for (const block of msg.message.content) {\n          if (block.type === 'tool_use' && block.id) {\n            toolUseMap.set(block.id, block);\n          }\n        }\n      }\n    }\n\n    // Second pass: match with tool_result\n    for (const msg of session.messages) {\n      if (Array.isArray(msg.message?.content)) {\n        for (const block of msg.message.content) {\n          if (block.type === 'tool_result' && block.tool_use_id) {\n            const toolUse = toolUseMap.get(block.tool_use_id);\n            if (toolUse) {\n              toolCalls.push({\n                name: toolUse.name || 'unknown',\n                input: toolUse.input,\n                output: typeof block.content === 'string' ? block.content : JSON.stringify(block.content),\n                error: block.is_error ? (typeof block.content === 'string' ? block.content : JSON.stringify(block.content)) : undefined,\n                timestamp: msg.timestamp,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return toolCalls;\n  }\n\n  /**\n   * Extracts the final output from a session\n   */\n  private extractOutput(session: Session): string {\n    // Find last assistant message with text content\n    for (let i = session.messages.length - 1; i >= 0; i--) {\n      const msg = session.messages[i];\n      if (msg.type === 'assistant') {\n        const content = msg.message?.content;\n        if (typeof content === 'string') {\n          return content;\n        }\n        if (Array.isArray(content)) {\n          const textBlock = content.find(b => b.type === 'text');\n          if (textBlock?.text) {\n            return textBlock.text;\n          }\n        }\n      }\n    }\n    return '';\n  }\n\n  /**\n   * Converts a session with errors to a FailureInput\n   */\n  private sessionToFailureInput(session: Session, filePath: string): FailureInput {\n    const prompt = this.extractPrompt(session);\n    const output = this.extractOutput(session);\n    const toolCalls = this.extractToolCalls(session);\n\n    // Combine all errors into a single error message\n    const errorMessage = session.errors\n      .map(e => e.toolName ? `${e.toolName}: ${e.errorMessage}` : e.errorMessage)\n      .join('\\n');\n\n    return {\n      id: `jsonl-${session.agentId || session.sessionId}-${Date.now()}`,\n      source: 'production',\n      sourceId: filePath,\n      prompt,\n      output,\n      toolCalls,\n      error: errorMessage,\n      timestamp: session.firstMessage.timestamp,\n      metadata: {\n        sessionId: session.sessionId,\n        agentId: session.agentId,\n        errorCount: session.errors.length,\n        messageCount: session.messages.length,\n        cwd: session.firstMessage.cwd,\n        errors: session.errors,\n      },\n    };\n  }\n\n  /**\n   * Collects failures from production JSONL logs\n   */\n  async collect(options?: CollectOptions): Promise<FailureInput[]> {\n    const failures: FailureInput[] = [];\n    const projectFolders = await this.findProjectFolders();\n\n    if (projectFolders.length === 0) {\n      console.warn(`No project-* folders found in ${this.promptRunsDir}`);\n      return [];\n    }\n\n    for (const projectDir of projectFolders) {\n      const jsonlFiles = await this.findJsonlFiles(projectDir);\n\n      for (const filePath of jsonlFiles) {\n        // Apply date filters\n        if (options?.since || options?.until) {\n          const stats = await fs.stat(filePath);\n          if (options.since && stats.mtime < options.since) continue;\n          if (options.until && stats.mtime > options.until) continue;\n        }\n\n        const messages = await this.parseJsonlFile(filePath);\n        const sessions = this.groupIntoSessions(messages);\n\n        for (const session of sessions) {\n          if (session.hasErrors) {\n            const failure = this.sessionToFailureInput(session, filePath);\n            failures.push(failure);\n          }\n        }\n\n        // Check limit\n        if (options?.limit && failures.length >= options.limit) {\n          return failures.slice(0, options.limit);\n        }\n      }\n    }\n\n    return failures;\n  }\n\n  /**\n   * Gets statistics about available JSONL data\n   */\n  async getStats(): Promise<{\n    projectCount: number;\n    jsonlFileCount: number;\n    sessionCount: number;\n    errorSessionCount: number;\n  }> {\n    const projectFolders = await this.findProjectFolders();\n    let jsonlFileCount = 0;\n    let sessionCount = 0;\n    let errorSessionCount = 0;\n\n    for (const projectDir of projectFolders) {\n      const jsonlFiles = await this.findJsonlFiles(projectDir);\n      jsonlFileCount += jsonlFiles.length;\n\n      for (const filePath of jsonlFiles) {\n        const messages = await this.parseJsonlFile(filePath);\n        const sessions = this.groupIntoSessions(messages);\n        sessionCount += sessions.length;\n        errorSessionCount += sessions.filter(s => s.hasErrors).length;\n      }\n    }\n\n    return {\n      projectCount: projectFolders.length,\n      jsonlFileCount,\n      sessionCount,\n      errorSessionCount,\n    };\n  }\n}\n\nexport default JsonlDataSource;\n","/**\n * Data source registry and factory for the learning system.\n */\n\nimport type { DataSource, DataSourceRegistry, CollectOptions, FailureInput } from './types.js';\nimport { EvalDataSource } from './eval-source.js';\nimport { JsonlDataSource } from './jsonl-source.js';\n\n// Export types\nexport * from './types.js';\n\n// Export data sources\nexport { EvalDataSource } from './eval-source.js';\nexport { JsonlDataSource } from './jsonl-source.js';\n\n/**\n * Creates a data source by name\n */\nexport function createDataSource(\n  name: string,\n  options?: Record<string, unknown>\n): DataSource | null {\n  switch (name) {\n    case 'eval':\n      return new EvalDataSource(options?.resultsDir as string | undefined);\n\n    case 'jsonl':\n      return new JsonlDataSource(options?.promptRunsDir as string | undefined);\n\n    default:\n      console.warn(`Unknown data source: ${name}`);\n      return null;\n  }\n}\n\n/**\n * Registry of all available data sources\n */\nexport function getDataSourceRegistry(): DataSourceRegistry {\n  return {\n    eval: new EvalDataSource(),\n    jsonl: new JsonlDataSource(),\n  };\n}\n\n/**\n * Collects failures from multiple data sources\n */\nexport async function collectFromSources(\n  sources: string[],\n  options?: CollectOptions\n): Promise<FailureInput[]> {\n  const failures: FailureInput[] = [];\n\n  for (const sourceName of sources) {\n    const source = createDataSource(sourceName);\n    if (!source) {\n      console.warn(`Skipping unknown source: ${sourceName}`);\n      continue;\n    }\n\n    const isAvailable = await source.isAvailable?.();\n    if (isAvailable === false) {\n      console.warn(`Source not available: ${sourceName}`);\n      continue;\n    }\n\n    const sourceFailures = await source.collect(options);\n    failures.push(...sourceFailures);\n  }\n\n  return failures;\n}\n\n/**\n * Gets statistics about available data sources\n */\nexport async function getSourceStats(): Promise<\n  Record<string, { available: boolean; failureCount?: number; details?: Record<string, number> }>\n> {\n  const registry = getDataSourceRegistry();\n  const stats: Record<string, { available: boolean; failureCount?: number; details?: Record<string, number> }> = {};\n\n  for (const [name, source] of Object.entries(registry)) {\n    const available = (await source.isAvailable?.()) ?? true;\n    let failureCount: number | undefined;\n    let details: Record<string, number> | undefined;\n\n    if (available && name === 'eval') {\n      const evalSource = source as EvalDataSource;\n      const evalStats = await evalSource.getStats();\n      failureCount = evalStats.failuresInLatest;\n    }\n\n    if (available && name === 'jsonl') {\n      const jsonlSource = source as JsonlDataSource;\n      const jsonlStats = await jsonlSource.getStats();\n      failureCount = jsonlStats.errorSessionCount;\n      details = {\n        projects: jsonlStats.projectCount,\n        files: jsonlStats.jsonlFileCount,\n        sessions: jsonlStats.sessionCount,\n      };\n    }\n\n    stats[name] = { available, failureCount, details };\n  }\n\n  return stats;\n}\n","/**\n * Generates LLM-powered explanations for why failures occurred.\n * This is the critical component - quality of explanations drives learning quality.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport * as dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\nimport type { FailureInput } from './data-sources/types.js';\nimport type { FailureExplanation } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\ninterface ExplanationResult {\n  whatWentWrong: string;\n  whyItFailed: string;\n  rootCause: string;\n  suggestedFix: string;\n  patternCategory: string;\n  affectedComponent?: string;\n  confidence: number;\n}\n\ntype AnthropicClient = import('@anthropic-ai/sdk').default;\n\nexport class ExplanationGenerator {\n  private anthropic: AnthropicClient | null = null;\n  private config: LearningConfig;\n  private promptTemplate: string | null = null;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  private async getAnthropicClient(): Promise<AnthropicClient> {\n    if (!this.anthropic) {\n      const { default: Anthropic } = await import('@anthropic-ai/sdk');\n      this.anthropic = new Anthropic();\n    }\n    return this.anthropic;\n  }\n\n  /**\n   * Loads the failure analysis prompt template\n   */\n  private async loadPromptTemplate(): Promise<string> {\n    if (this.promptTemplate) {\n      return this.promptTemplate;\n    }\n\n    const promptPath = path.join(\n      this.config.promptsDir,\n      'failure-analysis.md'\n    );\n\n    try {\n      this.promptTemplate = await fs.readFile(promptPath, 'utf-8');\n      return this.promptTemplate;\n    } catch (error) {\n      throw new Error(\n        `Failed to load failure analysis prompt from ${promptPath}: ${error}`\n      );\n    }\n  }\n\n  /**\n   * Builds the prompt for a specific failure\n   */\n  private async buildPrompt(failure: FailureInput): Promise<string> {\n    const template = await this.loadPromptTemplate();\n\n    // Format tool calls\n    const toolCallsFormatted = failure.toolCalls?.length\n      ? failure.toolCalls\n          .map(\n            (tc) =>\n              `- ${tc.name}${tc.error ? ` (error: ${tc.error})` : ''}`\n          )\n          .join('\\n')\n      : 'None';\n\n    // Format judge results\n    const judgeResultsFormatted = failure.judgeResults?.length\n      ? failure.judgeResults\n          .map(\n            (jr) =>\n              `- ${jr.judgeId}: ${jr.passed ? 'PASSED' : 'FAILED'} (score: ${jr.score})\\n  Reasoning: ${jr.reasoning}`\n          )\n          .join('\\n')\n      : 'None';\n\n    // Replace template variables\n    let prompt = template\n      .replace('{{evalName}}', failure.metadata?.evalName as string ?? failure.id)\n      .replace('{{category}}', failure.category ?? 'unknown')\n      .replace('{{description}}', failure.metadata?.evalDescription as string ?? '')\n      .replace('{{prompt}}', failure.prompt)\n      .replace('{{expectedBehavior}}', failure.expectedBehavior ?? 'Not specified')\n      .replace('{{toolCalls}}', toolCallsFormatted)\n      .replace('{{output}}', failure.output || 'No output')\n      .replace('{{judgeResults}}', judgeResultsFormatted);\n\n    // Handle conditional error section\n    if (failure.error) {\n      prompt = prompt.replace('{{#if error}}', '').replace('{{/if}}', '');\n      prompt = prompt.replace('{{error}}', failure.error);\n    } else {\n      // Remove the error section if no error\n      prompt = prompt.replace(/{{#if error}}[\\s\\S]*?{{\\/if}}/g, '');\n    }\n\n    return prompt;\n  }\n\n  /**\n   * Parses the LLM response into a structured explanation\n   */\n  private parseResponse(text: string): ExplanationResult {\n    // Try to extract JSON from markdown code block\n    const jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n    const jsonContent = jsonMatch ? jsonMatch[1] : text;\n\n    try {\n      const parsed = JSON.parse(jsonContent.trim());\n\n      return {\n        whatWentWrong: parsed.whatWentWrong || 'Unknown',\n        whyItFailed: parsed.whyItFailed || 'Unknown',\n        rootCause: parsed.rootCause || 'Unknown',\n        suggestedFix: parsed.suggestedFix || 'No suggestion',\n        patternCategory: parsed.patternCategory || 'other',\n        affectedComponent: parsed.affectedComponent,\n        confidence: Math.max(0, Math.min(1, parsed.confidence || 0.5)),\n      };\n    } catch (error) {\n      console.warn('Failed to parse LLM response:', text.substring(0, 200));\n      return {\n        whatWentWrong: 'Failed to parse response',\n        whyItFailed: text.substring(0, 500),\n        rootCause: 'Parse error',\n        suggestedFix: 'Manual review required',\n        patternCategory: 'other',\n        confidence: 0,\n      };\n    }\n  }\n\n  /**\n   * Generates an explanation for a single failure\n   */\n  async generateExplanation(failure: FailureInput): Promise<FailureExplanation> {\n    const prompt = await this.buildPrompt(failure);\n\n    try {\n      const client = await this.getAnthropicClient();\n      const response = await client.messages.create({\n        model: this.config.explanationModel,\n        max_tokens: 1024,\n        messages: [{ role: 'user', content: prompt }],\n      });\n\n      const content = response.content[0];\n      if (content.type !== 'text') {\n        throw new Error('Unexpected response type from LLM');\n      }\n\n      const explanation = this.parseResponse(content.text);\n\n      return {\n        id: `explanation-${failure.id}-${Date.now()}`,\n        failureInput: failure,\n        explanation,\n        confidence: explanation.confidence,\n        generatedAt: new Date().toISOString(),\n        model: this.config.explanationModel,\n      };\n    } catch (error) {\n      console.error(`Failed to generate explanation for ${failure.id}:`, error);\n\n      return {\n        id: `explanation-${failure.id}-${Date.now()}`,\n        failureInput: failure,\n        explanation: {\n          whatWentWrong: 'Failed to generate explanation',\n          whyItFailed: error instanceof Error ? error.message : 'Unknown error',\n          rootCause: 'LLM error',\n          suggestedFix: 'Manual review required',\n          patternCategory: 'other',\n        },\n        confidence: 0,\n        generatedAt: new Date().toISOString(),\n        model: this.config.explanationModel,\n      };\n    }\n  }\n\n  /**\n   * Generates explanations for multiple failures\n   */\n  async generateExplanations(\n    failures: FailureInput[],\n    options?: {\n      concurrency?: number;\n      onProgress?: (completed: number, total: number) => void;\n    }\n  ): Promise<FailureExplanation[]> {\n    const concurrency = options?.concurrency ?? 3;\n    const explanations: FailureExplanation[] = [];\n    let completed = 0;\n\n    // Process in batches\n    for (let i = 0; i < failures.length; i += concurrency) {\n      const batch = failures.slice(i, i + concurrency);\n      const batchResults = await Promise.all(\n        batch.map((f) => this.generateExplanation(f))\n      );\n      explanations.push(...batchResults);\n\n      completed += batch.length;\n      options?.onProgress?.(completed, failures.length);\n    }\n\n    return explanations;\n  }\n\n  /**\n   * Filters explanations by confidence threshold\n   */\n  filterByConfidence(\n    explanations: FailureExplanation[],\n    minConfidence: number = 0.5\n  ): FailureExplanation[] {\n    return explanations.filter((e) => e.confidence >= minConfidence);\n  }\n\n  /**\n   * Groups explanations by pattern category\n   */\n  groupByCategory(\n    explanations: FailureExplanation[]\n  ): Record<string, FailureExplanation[]> {\n    const grouped: Record<string, FailureExplanation[]> = {};\n\n    for (const explanation of explanations) {\n      const category = explanation.explanation.patternCategory;\n      if (!grouped[category]) {\n        grouped[category] = [];\n      }\n      grouped[category].push(explanation);\n    }\n\n    return grouped;\n  }\n}\n\nexport default ExplanationGenerator;\n","/**\n * Detects patterns across multiple failure explanations.\n * Groups similar failures to identify systemic issues.\n */\n\nimport type { FailureExplanation, FailurePattern } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\n/**\n * Simple text similarity using Jaccard index on word sets\n */\nfunction textSimilarity(a: string, b: string): number {\n  const wordsA = new Set(a.toLowerCase().split(/\\s+/).filter(w => w.length > 2));\n  const wordsB = new Set(b.toLowerCase().split(/\\s+/).filter(w => w.length > 2));\n\n  if (wordsA.size === 0 || wordsB.size === 0) {\n    return 0;\n  }\n\n  const intersection = new Set([...wordsA].filter(w => wordsB.has(w)));\n  const union = new Set([...wordsA, ...wordsB]);\n\n  return intersection.size / union.size;\n}\n\n/**\n * Calculates similarity between two failure explanations\n */\nfunction explanationSimilarity(a: FailureExplanation, b: FailureExplanation): number {\n  // If categories don't match, low similarity\n  if (a.explanation.patternCategory !== b.explanation.patternCategory) {\n    return 0.2;\n  }\n\n  // Compare root causes\n  const rootCauseSim = textSimilarity(\n    a.explanation.rootCause,\n    b.explanation.rootCause\n  );\n\n  // Compare what went wrong\n  const whatWrongSim = textSimilarity(\n    a.explanation.whatWentWrong,\n    b.explanation.whyItFailed\n  );\n\n  // Compare suggested fixes\n  const fixSim = textSimilarity(\n    a.explanation.suggestedFix,\n    b.explanation.suggestedFix\n  );\n\n  // Weighted average: root cause is most important\n  return rootCauseSim * 0.5 + whatWrongSim * 0.25 + fixSim * 0.25;\n}\n\n/**\n * Generates a pattern ID from a category and common words\n */\nfunction generatePatternId(\n  category: string,\n  explanations: FailureExplanation[]\n): string {\n  // Extract common words from root causes\n  const allWords = explanations\n    .flatMap(e => e.explanation.rootCause.toLowerCase().split(/\\s+/))\n    .filter(w => w.length > 3);\n\n  const wordCounts = new Map<string, number>();\n  for (const word of allWords) {\n    wordCounts.set(word, (wordCounts.get(word) || 0) + 1);\n  }\n\n  // Get top 2 most common words\n  const topWords = [...wordCounts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 2)\n    .map(([word]) => word);\n\n  const suffix = topWords.length > 0 ? `-${topWords.join('-')}` : '';\n  return `${category}${suffix}-${Date.now().toString(36)}`;\n}\n\n/**\n * Generates a human-readable pattern name\n */\nfunction generatePatternName(\n  category: string,\n  explanations: FailureExplanation[]\n): string {\n  // Use the most common affected component if available\n  const components = explanations\n    .map(e => e.explanation.affectedComponent)\n    .filter(Boolean);\n\n  const componentCounts = new Map<string, number>();\n  for (const comp of components) {\n    if (comp) {\n      componentCounts.set(comp, (componentCounts.get(comp) || 0) + 1);\n    }\n  }\n\n  const topComponent = [...componentCounts.entries()]\n    .sort((a, b) => b[1] - a[1])[0]?.[0];\n\n  const categoryName = category.replace(/-/g, ' ');\n\n  if (topComponent) {\n    return `${categoryName} in ${topComponent}`;\n  }\n\n  return `${categoryName} pattern`;\n}\n\n/**\n * Extracts common root causes from a group of explanations\n */\nfunction extractCommonRootCauses(explanations: FailureExplanation[]): string[] {\n  // Collect all root causes\n  const rootCauses = explanations.map(e => e.explanation.rootCause);\n\n  // Find unique-ish causes (not too similar to each other)\n  const uniqueCauses: string[] = [];\n\n  for (const cause of rootCauses) {\n    const isDuplicate = uniqueCauses.some(\n      existing => textSimilarity(existing, cause) > 0.7\n    );\n    if (!isDuplicate) {\n      uniqueCauses.push(cause);\n    }\n  }\n\n  return uniqueCauses.slice(0, 5); // Max 5 causes\n}\n\nexport class PatternDetector {\n  private config: LearningConfig;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  /**\n   * Detects patterns in a set of failure explanations\n   */\n  detectPatterns(explanations: FailureExplanation[]): FailurePattern[] {\n    if (explanations.length === 0) {\n      return [];\n    }\n\n    // First, group by category\n    const byCategory = new Map<string, FailureExplanation[]>();\n    for (const exp of explanations) {\n      const category = exp.explanation.patternCategory;\n      if (!byCategory.has(category)) {\n        byCategory.set(category, []);\n      }\n      byCategory.get(category)!.push(exp);\n    }\n\n    const patterns: FailurePattern[] = [];\n\n    // Process each category\n    for (const [category, categoryExplanations] of byCategory) {\n      // Skip if not enough failures to form a pattern\n      if (categoryExplanations.length < this.config.minFailuresForPattern) {\n        continue;\n      }\n\n      // Cluster within category using similarity\n      const clusters = this.clusterExplanations(\n        categoryExplanations,\n        this.config.similarityThreshold\n      );\n\n      // Convert clusters to patterns\n      for (const cluster of clusters) {\n        if (cluster.length >= this.config.minFailuresForPattern) {\n          patterns.push(this.createPattern(category, cluster));\n        }\n      }\n    }\n\n    // Sort by frequency (most common patterns first)\n    return patterns.sort((a, b) => b.frequency - a.frequency);\n  }\n\n  /**\n   * Clusters explanations by similarity\n   */\n  private clusterExplanations(\n    explanations: FailureExplanation[],\n    threshold: number\n  ): FailureExplanation[][] {\n    const clusters: FailureExplanation[][] = [];\n    const assigned = new Set<string>();\n\n    for (const exp of explanations) {\n      if (assigned.has(exp.id)) {\n        continue;\n      }\n\n      // Start a new cluster\n      const cluster = [exp];\n      assigned.add(exp.id);\n\n      // Find similar explanations\n      for (const other of explanations) {\n        if (assigned.has(other.id)) {\n          continue;\n        }\n\n        // Check similarity against all cluster members\n        const avgSimilarity =\n          cluster.reduce(\n            (sum, member) => sum + explanationSimilarity(member, other),\n            0\n          ) / cluster.length;\n\n        if (avgSimilarity >= threshold) {\n          cluster.push(other);\n          assigned.add(other.id);\n        }\n      }\n\n      clusters.push(cluster);\n    }\n\n    return clusters;\n  }\n\n  /**\n   * Creates a FailurePattern from a cluster of explanations\n   */\n  private createPattern(\n    category: string,\n    explanations: FailureExplanation[]\n  ): FailurePattern {\n    // Calculate average similarity within cluster\n    let totalSim = 0;\n    let pairCount = 0;\n    for (let i = 0; i < explanations.length; i++) {\n      for (let j = i + 1; j < explanations.length; j++) {\n        totalSim += explanationSimilarity(explanations[i], explanations[j]);\n        pairCount++;\n      }\n    }\n    const avgSimilarity = pairCount > 0 ? totalSim / pairCount : 1;\n\n    // Collect affected components\n    const components = new Set<string>();\n    for (const exp of explanations) {\n      if (exp.explanation.affectedComponent) {\n        components.add(exp.explanation.affectedComponent);\n      }\n    }\n\n    return {\n      patternId: generatePatternId(category, explanations),\n      patternName: generatePatternName(category, explanations),\n      category,\n      failures: explanations,\n      frequency: explanations.length,\n      affectedComponents: [...components],\n      commonRootCauses: extractCommonRootCauses(explanations),\n      similarityScore: avgSimilarity,\n      detectedAt: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Merges similar patterns across different runs\n   */\n  mergeWithExisting(\n    newPatterns: FailurePattern[],\n    existingPatterns: FailurePattern[]\n  ): FailurePattern[] {\n    const merged: FailurePattern[] = [...existingPatterns];\n\n    for (const newPattern of newPatterns) {\n      // Find existing pattern with same category and high similarity\n      const existingIndex = merged.findIndex(\n        existing =>\n          existing.category === newPattern.category &&\n          this.patternsAreSimilar(existing, newPattern)\n      );\n\n      if (existingIndex >= 0) {\n        // Merge into existing pattern\n        const existing = merged[existingIndex];\n        merged[existingIndex] = {\n          ...existing,\n          failures: [...existing.failures, ...newPattern.failures],\n          frequency: existing.frequency + newPattern.frequency,\n          affectedComponents: [\n            ...new Set([\n              ...existing.affectedComponents,\n              ...newPattern.affectedComponents,\n            ]),\n          ],\n          commonRootCauses: extractCommonRootCauses([\n            ...existing.failures,\n            ...newPattern.failures,\n          ]),\n        };\n      } else {\n        // Add as new pattern\n        merged.push(newPattern);\n      }\n    }\n\n    return merged;\n  }\n\n  /**\n   * Checks if two patterns are similar enough to merge\n   */\n  private patternsAreSimilar(a: FailurePattern, b: FailurePattern): boolean {\n    // Compare root causes\n    const aCauses = a.commonRootCauses.join(' ');\n    const bCauses = b.commonRootCauses.join(' ');\n\n    return textSimilarity(aCauses, bCauses) > 0.6;\n  }\n\n  /**\n   * Gets pattern statistics\n   */\n  getStats(patterns: FailurePattern[]): {\n    totalPatterns: number;\n    totalFailures: number;\n    avgPatterSize: number;\n    byCategory: Record<string, number>;\n  } {\n    const totalPatterns = patterns.length;\n    const totalFailures = patterns.reduce((sum, p) => sum + p.frequency, 0);\n    const avgPatterSize =\n      totalPatterns > 0 ? totalFailures / totalPatterns : 0;\n\n    const byCategory: Record<string, number> = {};\n    for (const pattern of patterns) {\n      byCategory[pattern.category] =\n        (byCategory[pattern.category] || 0) + pattern.frequency;\n    }\n\n    return {\n      totalPatterns,\n      totalFailures,\n      avgPatterSize,\n      byCategory,\n    };\n  }\n}\n\nexport default PatternDetector;\n","/**\n * Generates new prompt rules based on detected failure patterns.\n * Uses LLM to synthesize rules from pattern analysis.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport * as dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\nimport type { FailurePattern, ProposedRule } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\ninterface RuleGenerationResult {\n  rule: string;\n  targetSection: string;\n  placement?: string;\n  rationale: string;\n  expectedImpact: {\n    evalIds: string[];\n    confidenceScore: number;\n  };\n}\n\n/**\n * Maps pattern categories to prompt sections\n */\nconst CATEGORY_TO_SECTION: Record<string, string> = {\n  'routing-error': 'CHAT_PROMPT.delegationPrinciple',\n  'delegation-error': 'CHAT_PROMPT.delegationPrinciple',\n  'missing-tool-call': 'CHAT_PROMPT.troubleshooting',\n  'incorrect-code-pattern': 'CORE_INSTRUCTIONS',\n  'validation-failure': 'CORE_INSTRUCTIONS.coreSafetyRules',\n  'context-missing': 'CHAT_PROMPT.reasoningAndPlanning',\n  other: 'CORE_INSTRUCTIONS',\n};\n\ntype AnthropicClient = import('@anthropic-ai/sdk').default;\n\nexport class RuleGenerator {\n  private anthropic: AnthropicClient | null = null;\n  private config: LearningConfig;\n  private promptTemplate: string | null = null;\n  private currentInstructions: Map<string, string> = new Map();\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  private async getAnthropicClient(): Promise<AnthropicClient> {\n    if (!this.anthropic) {\n      const { default: Anthropic } = await import('@anthropic-ai/sdk');\n      this.anthropic = new Anthropic();\n    }\n    return this.anthropic;\n  }\n\n  /**\n   * Loads the rule generation prompt template\n   */\n  private async loadPromptTemplate(): Promise<string> {\n    if (this.promptTemplate) {\n      return this.promptTemplate;\n    }\n\n    const promptPath = path.join(this.config.promptsDir, 'rule-generation.md');\n\n    try {\n      this.promptTemplate = await fs.readFile(promptPath, 'utf-8');\n      return this.promptTemplate;\n    } catch (error) {\n      throw new Error(\n        `Failed to load rule generation prompt from ${promptPath}: ${error}`\n      );\n    }\n  }\n\n  /**\n   * Loads current instructions from prompt-templates.ts\n   * (Reads a simplified version for context)\n   */\n  async loadCurrentInstructions(): Promise<void> {\n    const templatePath = path.join(\n      this.config.learningDir,\n      '..',\n      '..',\n      'lib',\n      'ai',\n      'claude-code',\n      'prompt-templates.ts'\n    );\n\n    try {\n      const content = await fs.readFile(templatePath, 'utf-8');\n\n      // Extract major sections (simplified parsing)\n      const sections = [\n        'CORE_INSTRUCTIONS',\n        'CHAT_PROMPT',\n        'delegationPrinciple',\n        'coreSafetyRules',\n        'troubleshooting',\n      ];\n\n      for (const section of sections) {\n        const regex = new RegExp(\n          `${section}[:\\\\s]*[\\`'\"](.*?)[\\`'\"]`,\n          'gs'\n        );\n        const match = content.match(regex);\n        if (match) {\n          this.currentInstructions.set(\n            section,\n            match[0].substring(0, 500) + '...'\n          );\n        }\n      }\n    } catch (error) {\n      console.warn('Could not load current instructions:', error);\n    }\n  }\n\n  /**\n   * Gets the target section for a pattern\n   */\n  private getTargetSection(pattern: FailurePattern): string {\n    return (\n      CATEGORY_TO_SECTION[pattern.category] ||\n      CATEGORY_TO_SECTION['other']\n    );\n  }\n\n  /**\n   * Builds the prompt for rule generation\n   */\n  private async buildPrompt(pattern: FailurePattern): Promise<string> {\n    const template = await this.loadPromptTemplate();\n    const targetSection = this.getTargetSection(pattern);\n\n    // Get current instructions for the target section\n    const sectionKey = targetSection.split('.')[0];\n    const currentInstructions =\n      this.currentInstructions.get(sectionKey) ||\n      '(Instructions not loaded)';\n\n    // Format failures\n    const failuresFormatted = pattern.failures\n      .slice(0, 5) // Limit to 5 examples\n      .map((f, i) => {\n        const evalName =\n          (f.failureInput.metadata?.evalName as string) ||\n          f.failureInput.id;\n        return `#### Failure ${i + 1}\n- **Eval**: ${evalName}\n- **What Went Wrong**: ${f.explanation.whatWentWrong}\n- **Why It Failed**: ${f.explanation.whyItFailed}\n- **Suggested Fix**: ${f.explanation.suggestedFix}`;\n      })\n      .join('\\n\\n');\n\n    // Replace template variables\n    let prompt = template\n      .replace('{{targetSection}}', targetSection)\n      .replace('{{currentInstructions}}', currentInstructions)\n      .replace('{{patternName}}', pattern.patternName)\n      .replace('{{patternCategory}}', pattern.category)\n      .replace('{{frequency}}', pattern.frequency.toString())\n      .replace('{{affectedComponents}}', pattern.affectedComponents.join(', ') || 'None specified')\n      .replace('{{commonRootCauses}}', pattern.commonRootCauses.join('\\n- ') || 'None identified');\n\n    // Handle the failures loop\n    prompt = prompt.replace(\n      /{{#each failures}}[\\s\\S]*?{{\\/each}}/g,\n      failuresFormatted\n    );\n\n    return prompt;\n  }\n\n  /**\n   * Parses the LLM response into a rule result\n   */\n  private parseResponse(text: string, pattern: FailurePattern): RuleGenerationResult {\n    // Try to extract JSON from markdown code block\n    const jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n    const jsonContent = jsonMatch ? jsonMatch[1] : text;\n\n    try {\n      const parsed = JSON.parse(jsonContent.trim());\n\n      // Get failure IDs for expected impact\n      const evalIds = pattern.failures\n        .slice(0, 10)\n        .map((f) => f.failureInput.id);\n\n      return {\n        rule: parsed.rule || 'No rule generated',\n        targetSection: parsed.targetSection || this.getTargetSection(pattern),\n        placement: parsed.placement,\n        rationale: parsed.rationale || 'No rationale provided',\n        expectedImpact: {\n          evalIds: parsed.expectedImpact?.evalIds || evalIds,\n          confidenceScore: Math.max(\n            0,\n            Math.min(1, parsed.expectedImpact?.confidenceScore || 0.5)\n          ),\n        },\n      };\n    } catch (error) {\n      console.warn('Failed to parse rule generation response:', text.substring(0, 200));\n      return {\n        rule: text.substring(0, 500),\n        targetSection: this.getTargetSection(pattern),\n        rationale: 'Failed to parse structured response',\n        expectedImpact: {\n          evalIds: pattern.failures.slice(0, 5).map((f) => f.failureInput.id),\n          confidenceScore: 0.3,\n        },\n      };\n    }\n  }\n\n  /**\n   * Generates a rule for a single pattern\n   */\n  async generateRule(pattern: FailurePattern): Promise<ProposedRule> {\n    const prompt = await this.buildPrompt(pattern);\n\n    try {\n      const client = await this.getAnthropicClient();\n      const response = await client.messages.create({\n        model: this.config.ruleGenerationModel,\n        max_tokens: 1024,\n        messages: [{ role: 'user', content: prompt }],\n      });\n\n      const content = response.content[0];\n      if (content.type !== 'text') {\n        throw new Error('Unexpected response type from LLM');\n      }\n\n      const result = this.parseResponse(content.text, pattern);\n\n      return {\n        ruleId: `rule-${pattern.patternId}`,\n        ruleContent: result.rule,\n        targetSection: result.targetSection,\n        placement: result.placement,\n        rationale: result.rationale,\n        addressesPatterns: [pattern.patternId],\n        expectedImpact: {\n          failureIds: result.expectedImpact.evalIds,\n          confidenceScore: result.expectedImpact.confidenceScore,\n        },\n        status: 'pending',\n        generatedAt: new Date().toISOString(),\n        model: this.config.ruleGenerationModel,\n        source: `iteration-${new Date().toISOString().split('T')[0]}`,\n      };\n    } catch (error) {\n      console.error(`Failed to generate rule for pattern ${pattern.patternId}:`, error);\n\n      return {\n        ruleId: `rule-${pattern.patternId}`,\n        ruleContent: `[Generation failed: ${error instanceof Error ? error.message : 'Unknown error'}]`,\n        targetSection: this.getTargetSection(pattern),\n        rationale: 'Rule generation failed',\n        addressesPatterns: [pattern.patternId],\n        expectedImpact: {\n          failureIds: [],\n          confidenceScore: 0,\n        },\n        status: 'pending',\n        generatedAt: new Date().toISOString(),\n        model: this.config.ruleGenerationModel,\n        source: `iteration-${new Date().toISOString().split('T')[0]}`,\n      };\n    }\n  }\n\n  /**\n   * Generates rules for multiple patterns\n   */\n  async generateRules(\n    patterns: FailurePattern[],\n    options?: {\n      maxRules?: number;\n      onProgress?: (completed: number, total: number) => void;\n    }\n  ): Promise<ProposedRule[]> {\n    // Load current instructions first\n    await this.loadCurrentInstructions();\n\n    // Limit patterns to process\n    const maxRules = options?.maxRules ?? this.config.maxRulesPerIteration;\n    const patternsToProcess = patterns.slice(0, maxRules);\n\n    const rules: ProposedRule[] = [];\n\n    for (let i = 0; i < patternsToProcess.length; i++) {\n      const pattern = patternsToProcess[i];\n      const rule = await this.generateRule(pattern);\n      rules.push(rule);\n\n      options?.onProgress?.(i + 1, patternsToProcess.length);\n    }\n\n    return rules;\n  }\n\n  /**\n   * Filters rules by confidence\n   */\n  filterByConfidence(\n    rules: ProposedRule[],\n    minConfidence?: number\n  ): ProposedRule[] {\n    const threshold = minConfidence ?? this.config.minRuleConfidence;\n    return rules.filter(\n      (r) => r.expectedImpact.confidenceScore >= threshold\n    );\n  }\n\n  /**\n   * Checks for conflicts between a new rule and existing rules\n   */\n  checkForConflicts(\n    newRule: ProposedRule,\n    existingRules: ProposedRule[]\n  ): { hasConflict: boolean; conflictingRules: ProposedRule[] } {\n    const conflicting = existingRules.filter((existing) => {\n      // Same target section\n      if (existing.targetSection !== newRule.targetSection) {\n        return false;\n      }\n\n      // Check for contradictory keywords\n      const newLower = newRule.ruleContent.toLowerCase();\n      const existingLower = existing.ruleContent.toLowerCase();\n\n      // Simple conflict detection: opposite instructions\n      const hasAlways = newLower.includes('always');\n      const hasNever = newLower.includes('never');\n      const existingHasAlways = existingLower.includes('always');\n      const existingHasNever = existingLower.includes('never');\n\n      if ((hasAlways && existingHasNever) || (hasNever && existingHasAlways)) {\n        // Check if they're about the same topic (rough heuristic)\n        const newWords = new Set(newLower.split(/\\s+/).filter(w => w.length > 4));\n        const existingWords = new Set(existingLower.split(/\\s+/).filter(w => w.length > 4));\n        const commonWords = [...newWords].filter(w => existingWords.has(w));\n\n        if (commonWords.length > 2) {\n          return true;\n        }\n      }\n\n      return false;\n    });\n\n    return {\n      hasConflict: conflicting.length > 0,\n      conflictingRules: conflicting,\n    };\n  }\n}\n\nexport default RuleGenerator;\n","/**\n * Interactive CLI for reviewing proposed rules.\n * Provides a human-in-the-loop interface for approving/rejecting rules.\n */\n\nimport * as readline from 'readline';\nimport type { ProposedRule, FailurePattern } from './types.js';\n\nexport interface ReviewDecision {\n  rule: ProposedRule;\n  decision: 'approve' | 'reject' | 'modify' | 'skip';\n  notes?: string;\n  modifiedRule?: string;\n}\n\nexport interface ReviewSession {\n  decisions: ReviewDecision[];\n  approved: ProposedRule[];\n  rejected: ProposedRule[];\n  skipped: ProposedRule[];\n}\n\n/**\n * Formats a rule for display\n */\nfunction formatRuleDisplay(rule: ProposedRule, index: number, total: number): string {\n  const header = `\n\n  PROMPT LEARNING: RULE REVIEW (${index + 1}/${total})\n`;\n\n  const ruleBox = `\n\n ${rule.ruleContent.split('\\n').map(line => line.padEnd(63)).join('\\n ')}\n`;\n\n  const evidence = `\nEvidence:\n  - Pattern: ${rule.addressesPatterns.join(', ')}\n  - Target: ${rule.targetSection}\n  - Confidence: ${(rule.expectedImpact.confidenceScore * 100).toFixed(0)}%\n  - Affects: ${rule.expectedImpact.failureIds.slice(0, 3).join(', ')}${rule.expectedImpact.failureIds.length > 3 ? '...' : ''}\n\nRationale:\n  ${rule.rationale}`;\n\n  return header + '\\n' + ruleBox + evidence;\n}\n\n/**\n * Interactive CLI reviewer for proposed rules\n */\nexport class CLIReviewer {\n  private rl: readline.Interface | null = null;\n\n  /**\n   * Creates readline interface\n   */\n  private createInterface(): readline.Interface {\n    return readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n  }\n\n  /**\n   * Prompts user for input\n   */\n  private async prompt(question: string): Promise<string> {\n    return new Promise((resolve) => {\n      this.rl?.question(question, (answer) => {\n        resolve(answer.trim().toLowerCase());\n      });\n    });\n  }\n\n  /**\n   * Prompts for multi-line input\n   */\n  private async promptMultiline(prompt: string): Promise<string> {\n    console.log(prompt);\n    console.log('(Enter an empty line to finish)');\n\n    const lines: string[] = [];\n    let line = await this.prompt('> ');\n\n    while (line !== '') {\n      lines.push(line);\n      line = await this.prompt('> ');\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Reviews a single rule\n   */\n  private async reviewRule(\n    rule: ProposedRule,\n    index: number,\n    total: number\n  ): Promise<ReviewDecision> {\n    console.log(formatRuleDisplay(rule, index, total));\n    console.log('\\n[A]pprove  [R]eject  [M]odify  [S]kip  [Q]uit\\n');\n\n    const answer = await this.prompt('Your choice: ');\n\n    switch (answer) {\n      case 'a':\n      case 'approve':\n        const approveNotes = await this.prompt('Notes (optional): ');\n        return {\n          rule: { ...rule, status: 'approved' },\n          decision: 'approve',\n          notes: approveNotes || undefined,\n        };\n\n      case 'r':\n      case 'reject':\n        const rejectReason = await this.prompt('Reason for rejection: ');\n        return {\n          rule: { ...rule, status: 'rejected', reviewNotes: rejectReason },\n          decision: 'reject',\n          notes: rejectReason,\n        };\n\n      case 'm':\n      case 'modify':\n        console.log('\\nCurrent rule:');\n        console.log(rule.ruleContent);\n        const modified = await this.promptMultiline('\\nEnter modified rule:');\n        return {\n          rule: { ...rule, status: 'approved', ruleContent: modified },\n          decision: 'modify',\n          modifiedRule: modified,\n        };\n\n      case 's':\n      case 'skip':\n        return {\n          rule,\n          decision: 'skip',\n        };\n\n      case 'q':\n      case 'quit':\n        throw new Error('Review session aborted by user');\n\n      default:\n        console.log('Invalid choice. Please try again.');\n        return this.reviewRule(rule, index, total);\n    }\n  }\n\n  /**\n   * Starts an interactive review session\n   */\n  async startReviewSession(rules: ProposedRule[]): Promise<ReviewSession> {\n    if (rules.length === 0) {\n      console.log('No rules to review.');\n      return { decisions: [], approved: [], rejected: [], skipped: [] };\n    }\n\n    this.rl = this.createInterface();\n\n    console.log(`\\n`);\n    console.log(`              PROMPT LEARNING SYSTEM                            `);\n    console.log(`              Interactive Rule Review                           `);\n    console.log(``);\n    console.log(`  ${rules.length} rule(s) to review                                          `);\n    console.log(`                                                                `);\n    console.log(`  Commands:                                                     `);\n    console.log(`    [A]pprove - Accept the rule as-is                          `);\n    console.log(`    [R]eject  - Reject the rule with reason                    `);\n    console.log(`    [M]odify  - Edit the rule before approving                 `);\n    console.log(`    [S]kip    - Skip for now, review later                     `);\n    console.log(`    [Q]uit    - Exit review session                            `);\n    console.log(`\\n`);\n\n    const decisions: ReviewDecision[] = [];\n    const approved: ProposedRule[] = [];\n    const rejected: ProposedRule[] = [];\n    const skipped: ProposedRule[] = [];\n\n    try {\n      for (let i = 0; i < rules.length; i++) {\n        const decision = await this.reviewRule(rules[i], i, rules.length);\n        decisions.push(decision);\n\n        switch (decision.decision) {\n          case 'approve':\n          case 'modify':\n            approved.push(decision.rule);\n            break;\n          case 'reject':\n            rejected.push(decision.rule);\n            break;\n          case 'skip':\n            skipped.push(decision.rule);\n            break;\n        }\n      }\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('aborted')) {\n        console.log('\\nReview session aborted.');\n      } else {\n        throw error;\n      }\n    } finally {\n      this.rl?.close();\n      this.rl = null;\n    }\n\n    // Print summary\n    console.log('\\n');\n    console.log('  REVIEW SESSION COMPLETE');\n    console.log('');\n    console.log(`  Approved: ${approved.length}`);\n    console.log(`  Rejected: ${rejected.length}`);\n    console.log(`  Skipped:  ${skipped.length}`);\n    console.log('\\n');\n\n    return { decisions, approved, rejected, skipped };\n  }\n\n  /**\n   * Prints a summary of rules without interactive review\n   */\n  printRulesSummary(rules: ProposedRule[]): void {\n    console.log('\\n');\n    console.log('              PROPOSED RULES SUMMARY                            ');\n    console.log('\\n');\n\n    for (const [i, rule] of rules.entries()) {\n      console.log(`[${i + 1}] ${rule.ruleId}`);\n      console.log(`    Target: ${rule.targetSection}`);\n      console.log(`    Confidence: ${(rule.expectedImpact.confidenceScore * 100).toFixed(0)}%`);\n      console.log(`    Rule: ${rule.ruleContent.substring(0, 80)}...`);\n      console.log('');\n    }\n  }\n\n  /**\n   * Quick approve all rules (for non-interactive mode)\n   */\n  autoApproveAll(\n    rules: ProposedRule[],\n    minConfidence: number = 0.8\n  ): ReviewSession {\n    const decisions: ReviewDecision[] = [];\n    const approved: ProposedRule[] = [];\n    const rejected: ProposedRule[] = [];\n    const skipped: ProposedRule[] = [];\n\n    for (const rule of rules) {\n      if (rule.expectedImpact.confidenceScore >= minConfidence) {\n        const approvedRule = { ...rule, status: 'approved' as const };\n        decisions.push({ rule: approvedRule, decision: 'approve' });\n        approved.push(approvedRule);\n      } else {\n        decisions.push({ rule, decision: 'skip' });\n        skipped.push(rule);\n      }\n    }\n\n    return { decisions, approved, rejected, skipped };\n  }\n}\n\nexport default CLIReviewer;\n","/**\n * Writes approved rules to the learned-rules.json file.\n * Manages the rules storage lifecycle.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport type { ProposedRule, LearnedRulesFile, LearningHistory, LearningIterationResult } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\nexport class RuleWriter {\n  private config: LearningConfig;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  /**\n   * Ensures rules directories exist\n   */\n  async ensureDirectories(): Promise<void> {\n    await fs.mkdir(this.config.rulesDir, { recursive: true });\n    await fs.mkdir(this.config.pendingDir, { recursive: true });\n    await fs.mkdir(this.config.approvedDir, { recursive: true });\n    await fs.mkdir(this.config.rejectedDir, { recursive: true });\n  }\n\n  /**\n   * Reads the current learned rules file\n   */\n  async readLearnedRules(): Promise<LearnedRulesFile> {\n    try {\n      const content = await fs.readFile(this.config.learnedRulesPath, 'utf-8');\n      return JSON.parse(content) as LearnedRulesFile;\n    } catch {\n      // File doesn't exist or is invalid, return empty\n      return {\n        rules: [],\n        lastUpdated: new Date().toISOString(),\n        iterations: [],\n      };\n    }\n  }\n\n  /**\n   * Writes rules to the learned rules file\n   */\n  async writeLearnedRules(rules: LearnedRulesFile): Promise<void> {\n    await this.ensureDirectories();\n\n    const content = JSON.stringify(rules, null, 2);\n    await fs.writeFile(this.config.learnedRulesPath, content, 'utf-8');\n  }\n\n  /**\n   * Adds approved rules to the learned rules file\n   */\n  async addApprovedRules(\n    rules: ProposedRule[],\n    iterationId: string\n  ): Promise<void> {\n    const current = await this.readLearnedRules();\n\n    // Add new rules\n    for (const rule of rules) {\n      // Check if rule already exists (by ID)\n      const existingIndex = current.rules.findIndex(\n        (r) => r.ruleId === rule.ruleId\n      );\n\n      if (existingIndex >= 0) {\n        // Update existing rule\n        current.rules[existingIndex] = { ...rule, status: 'approved' };\n      } else {\n        // Add new rule\n        current.rules.push({ ...rule, status: 'approved' });\n      }\n    }\n\n    // Update metadata\n    current.lastUpdated = new Date().toISOString();\n    if (!current.iterations.includes(iterationId)) {\n      current.iterations.push(iterationId);\n    }\n\n    await this.writeLearnedRules(current);\n  }\n\n  /**\n   * Saves a rule to the pending directory for later review\n   */\n  async savePendingRule(rule: ProposedRule): Promise<string> {\n    await this.ensureDirectories();\n\n    const filename = `${rule.ruleId}.json`;\n    const filepath = path.join(this.config.pendingDir, filename);\n\n    await fs.writeFile(filepath, JSON.stringify(rule, null, 2), 'utf-8');\n\n    return filepath;\n  }\n\n  /**\n   * Saves multiple pending rules\n   */\n  async savePendingRules(rules: ProposedRule[]): Promise<string[]> {\n    const paths: string[] = [];\n    for (const rule of rules) {\n      const filepath = await this.savePendingRule(rule);\n      paths.push(filepath);\n    }\n    return paths;\n  }\n\n  /**\n   * Loads pending rules from the pending directory\n   */\n  async loadPendingRules(): Promise<ProposedRule[]> {\n    try {\n      const files = await fs.readdir(this.config.pendingDir);\n      const jsonFiles = files.filter((f) => f.endsWith('.json'));\n\n      const rules: ProposedRule[] = [];\n      for (const file of jsonFiles) {\n        const filepath = path.join(this.config.pendingDir, file);\n        const content = await fs.readFile(filepath, 'utf-8');\n        rules.push(JSON.parse(content) as ProposedRule);\n      }\n\n      return rules;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Moves a pending rule to approved\n   */\n  async approvePendingRule(ruleId: string): Promise<void> {\n    const pendingPath = path.join(this.config.pendingDir, `${ruleId}.json`);\n    const approvedPath = path.join(this.config.approvedDir, `${ruleId}.json`);\n\n    try {\n      const content = await fs.readFile(pendingPath, 'utf-8');\n      const rule = JSON.parse(content) as ProposedRule;\n      rule.status = 'approved';\n\n      await fs.writeFile(approvedPath, JSON.stringify(rule, null, 2), 'utf-8');\n      await fs.unlink(pendingPath);\n\n      // Also add to learned rules\n      await this.addApprovedRules([rule], `manual-${Date.now()}`);\n    } catch (error) {\n      throw new Error(`Failed to approve rule ${ruleId}: ${error}`);\n    }\n  }\n\n  /**\n   * Moves a pending rule to rejected\n   */\n  async rejectPendingRule(ruleId: string, reason: string): Promise<void> {\n    const pendingPath = path.join(this.config.pendingDir, `${ruleId}.json`);\n    const rejectedPath = path.join(this.config.rejectedDir, `${ruleId}.json`);\n\n    try {\n      const content = await fs.readFile(pendingPath, 'utf-8');\n      const rule = JSON.parse(content) as ProposedRule;\n      rule.status = 'rejected';\n      rule.reviewNotes = reason;\n\n      await fs.writeFile(rejectedPath, JSON.stringify(rule, null, 2), 'utf-8');\n      await fs.unlink(pendingPath);\n    } catch (error) {\n      throw new Error(`Failed to reject rule ${ruleId}: ${error}`);\n    }\n  }\n\n  /**\n   * Clears all pending rules\n   */\n  async clearPendingRules(): Promise<number> {\n    try {\n      const files = await fs.readdir(this.config.pendingDir);\n      for (const file of files) {\n        await fs.unlink(path.join(this.config.pendingDir, file));\n      }\n      return files.length;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Reads the learning history\n   */\n  async readHistory(): Promise<LearningHistory> {\n    try {\n      const content = await fs.readFile(this.config.historyPath, 'utf-8');\n      return JSON.parse(content) as LearningHistory;\n    } catch {\n      return {\n        iterations: [],\n        totalRulesGenerated: 0,\n        totalRulesApproved: 0,\n        totalRulesRejected: 0,\n        lastRunAt: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Writes the learning history\n   */\n  async writeHistory(history: LearningHistory): Promise<void> {\n    await this.ensureDirectories();\n    await fs.writeFile(\n      this.config.historyPath,\n      JSON.stringify(history, null, 2),\n      'utf-8'\n    );\n  }\n\n  /**\n   * Adds a learning iteration to the history\n   */\n  async addIterationToHistory(\n    iteration: LearningIterationResult\n  ): Promise<void> {\n    const history = await this.readHistory();\n\n    history.iterations.push(iteration);\n    history.totalRulesGenerated += iteration.rulesProposed.length;\n    history.totalRulesApproved += iteration.rulesApproved.length;\n    history.totalRulesRejected += iteration.rulesRejected.length;\n    history.lastRunAt = iteration.timestamp;\n\n    await this.writeHistory(history);\n  }\n\n  /**\n   * Gets statistics about stored rules\n   */\n  async getStats(): Promise<{\n    totalRules: number;\n    pendingCount: number;\n    approvedCount: number;\n    rejectedCount: number;\n    iterationsCount: number;\n  }> {\n    const rules = await this.readLearnedRules();\n    const pending = await this.loadPendingRules();\n    const history = await this.readHistory();\n\n    let approvedCount = 0;\n    let rejectedCount = 0;\n\n    try {\n      approvedCount = (await fs.readdir(this.config.approvedDir)).length;\n    } catch {\n      // Directory doesn't exist\n    }\n\n    try {\n      rejectedCount = (await fs.readdir(this.config.rejectedDir)).length;\n    } catch {\n      // Directory doesn't exist\n    }\n\n    return {\n      totalRules: rules.rules.length,\n      pendingCount: pending.length,\n      approvedCount,\n      rejectedCount,\n      iterationsCount: history.iterations.length,\n    };\n  }\n}\n\nexport default RuleWriter;\n","/**\n * Learning Loop Runner\n * Orchestrates the full prompt learning pipeline.\n */\n\nimport { collectFromSources, getSourceStats } from './data-sources/index.js';\nimport { ExplanationGenerator } from './explanation-generator.js';\nimport { PatternDetector } from './pattern-detector.js';\nimport { RuleGenerator } from './rule-generator.js';\nimport { CLIReviewer } from './cli-reviewer.js';\nimport { RuleWriter } from './rule-writer.js';\nimport type {\n  FailureInput,\n  FailureExplanation,\n  FailurePattern,\n  ProposedRule,\n  LearningIterationResult,\n  CollectOptions,\n} from './types.js';\nimport { getLearningConfig, getConfigFromEnv, type LearningConfig } from './config';\n\nexport interface LearningOptions {\n  /** Data sources to use */\n  sources?: string[];\n\n  /** Options for collecting failures */\n  collectOptions?: CollectOptions;\n\n  /** Project ID for production data source (fetches from S3) */\n  projectId?: string;\n\n  /** Task ID for production data source (optional) */\n  taskId?: string;\n\n  /** Skip interactive review (use auto-approve) */\n  autoApprove?: boolean;\n\n  /** Minimum confidence for auto-approve */\n  autoApproveThreshold?: number;\n\n  /** Save pending rules for later review */\n  savePending?: boolean;\n\n  /** Run validation after applying rules */\n  validate?: boolean;\n\n  /** Progress callback */\n  onProgress?: (stage: string, progress: number, total: number) => void;\n}\n\nexport class LearningRunner {\n  private config: LearningConfig;\n  private explanationGenerator: ExplanationGenerator;\n  private patternDetector: PatternDetector;\n  private ruleGenerator: RuleGenerator;\n  private cliReviewer: CLIReviewer;\n  private ruleWriter: RuleWriter;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig({ ...getConfigFromEnv(), ...config });\n    this.explanationGenerator = new ExplanationGenerator(this.config);\n    this.patternDetector = new PatternDetector(this.config);\n    this.ruleGenerator = new RuleGenerator(this.config);\n    this.cliReviewer = new CLIReviewer();\n    this.ruleWriter = new RuleWriter(this.config);\n  }\n\n  /**\n   * Runs a full learning iteration\n   */\n  async runIteration(options: LearningOptions = {}): Promise<LearningIterationResult> {\n    const startTime = Date.now();\n    const iterationId = `iteration-${new Date().toISOString().replace(/[:.]/g, '-')}`;\n\n    console.log('\\n');\n    console.log('              PROMPT LEARNING SYSTEM                            ');\n    console.log('              Starting Learning Iteration                       ');\n    console.log('\\n');\n\n    // Phase 1: Collect failures\n    console.log(' Phase 1: Collecting failures...');\n    const sources = options.sources || ['eval', 'jsonl'];\n\n    // Merge projectId and taskId into collectOptions for production source\n    const collectOptions: CollectOptions = {\n      ...options.collectOptions,\n      projectId: options.projectId,\n      taskId: options.taskId,\n    };\n\n    const failures = await collectFromSources(sources, collectOptions);\n    console.log(`   Found ${failures.length} failures from ${sources.join(', ')}`);\n\n    if (failures.length === 0) {\n      console.log('\\n No failures to analyze. System is performing well!\\n');\n      return this.createEmptyResult(iterationId, startTime, sources);\n    }\n\n    // Phase 2: Generate explanations\n    console.log('\\n Phase 2: Generating failure explanations...');\n    const explanations = await this.explanationGenerator.generateExplanations(\n      failures,\n      {\n        concurrency: 3,\n        onProgress: (completed, total) => {\n          process.stdout.write(`\\r   Progress: ${completed}/${total}`);\n          options.onProgress?.('explanations', completed, total);\n        },\n      }\n    );\n    console.log(`\\n   Generated ${explanations.length} explanations`);\n\n    // Phase 3: Detect patterns\n    console.log('\\n Phase 3: Detecting patterns...');\n    const patterns = this.patternDetector.detectPatterns(explanations);\n    console.log(`   Detected ${patterns.length} patterns`);\n\n    if (patterns.length === 0) {\n      console.log('\\n  No patterns detected. Failures may be too diverse.\\n');\n      return this.createResult(\n        iterationId,\n        startTime,\n        sources,\n        failures.length,\n        explanations.length,\n        [],\n        [],\n        [],\n        []\n      );\n    }\n\n    // Print pattern summary\n    this.printPatternSummary(patterns);\n\n    // Phase 4: Generate rules\n    console.log('\\n Phase 4: Generating rules...');\n    const proposedRules = await this.ruleGenerator.generateRules(patterns, {\n      maxRules: this.config.maxRulesPerIteration,\n      onProgress: (completed, total) => {\n        process.stdout.write(`\\r   Progress: ${completed}/${total}`);\n        options.onProgress?.('rules', completed, total);\n      },\n    });\n    console.log(`\\n   Generated ${proposedRules.length} proposed rules`);\n\n    // Filter low-confidence rules\n    const filteredRules = this.ruleGenerator.filterByConfidence(proposedRules);\n    console.log(`   ${filteredRules.length} rules pass confidence threshold`);\n\n    if (filteredRules.length === 0) {\n      console.log('\\n  No rules passed confidence threshold.\\n');\n      return this.createResult(\n        iterationId,\n        startTime,\n        sources,\n        failures.length,\n        explanations.length,\n        patterns,\n        proposedRules,\n        [],\n        []\n      );\n    }\n\n    // Phase 5: Human review or auto-approve\n    let approvedRules: ProposedRule[] = [];\n    let rejectedRules: ProposedRule[] = [];\n\n    if (options.autoApprove) {\n      console.log('\\n Phase 5: Auto-approving rules...');\n      const session = this.cliReviewer.autoApproveAll(\n        filteredRules,\n        options.autoApproveThreshold || 0.8\n      );\n      approvedRules = session.approved;\n      rejectedRules = session.rejected;\n      console.log(`   Auto-approved: ${approvedRules.length}, Skipped: ${session.skipped.length}`);\n    } else if (options.savePending) {\n      console.log('\\n Phase 5: Saving rules for later review...');\n      await this.ruleWriter.savePendingRules(filteredRules);\n      console.log(`   Saved ${filteredRules.length} rules to pending/`);\n      console.log('   Run \"npm run learn:review\" to review them');\n    } else {\n      console.log('\\n Phase 5: Interactive review...');\n      const session = await this.cliReviewer.startReviewSession(filteredRules);\n      approvedRules = session.approved;\n      rejectedRules = session.rejected;\n    }\n\n    // Phase 6: Save approved rules\n    if (approvedRules.length > 0) {\n      console.log('\\n Phase 6: Saving approved rules...');\n      await this.ruleWriter.addApprovedRules(approvedRules, iterationId);\n      console.log(`   Saved ${approvedRules.length} rules to learned-rules.json`);\n    }\n\n    // Create and save iteration result\n    const result = this.createResult(\n      iterationId,\n      startTime,\n      sources,\n      failures.length,\n      explanations.length,\n      patterns,\n      proposedRules,\n      approvedRules,\n      rejectedRules\n    );\n\n    await this.ruleWriter.addIterationToHistory(result);\n\n    // Print summary\n    this.printIterationSummary(result);\n\n    return result;\n  }\n\n  /**\n   * Analyzes failures without generating rules\n   */\n  async analyze(options: LearningOptions = {}): Promise<{\n    failures: FailureInput[];\n    explanations: FailureExplanation[];\n    patterns: FailurePattern[];\n  }> {\n    console.log('\\n ANALYZE MODE: Collecting and analyzing failures...\\n');\n\n    const sources = options.sources || ['eval', 'jsonl'];\n\n    // Merge projectId and taskId into collectOptions for production source\n    const collectOptions: CollectOptions = {\n      ...options.collectOptions,\n      projectId: options.projectId,\n      taskId: options.taskId,\n    };\n\n    const failures = await collectFromSources(sources, collectOptions);\n    console.log(`Found ${failures.length} failures`);\n\n    if (failures.length === 0) {\n      return { failures: [], explanations: [], patterns: [] };\n    }\n\n    const explanations = await this.explanationGenerator.generateExplanations(\n      failures,\n      { concurrency: 3 }\n    );\n    console.log(`Generated ${explanations.length} explanations`);\n\n    const patterns = this.patternDetector.detectPatterns(explanations);\n    console.log(`Detected ${patterns.length} patterns`);\n\n    this.printPatternSummary(patterns);\n\n    return { failures, explanations, patterns };\n  }\n\n  /**\n   * Reviews pending rules\n   */\n  async reviewPending(): Promise<void> {\n    const pending = await this.ruleWriter.loadPendingRules();\n\n    if (pending.length === 0) {\n      console.log('No pending rules to review.');\n      return;\n    }\n\n    const session = await this.cliReviewer.startReviewSession(pending);\n\n    // Process decisions\n    for (const decision of session.decisions) {\n      if (decision.decision === 'approve' || decision.decision === 'modify') {\n        await this.ruleWriter.approvePendingRule(decision.rule.ruleId);\n      } else if (decision.decision === 'reject') {\n        await this.ruleWriter.rejectPendingRule(\n          decision.rule.ruleId,\n          decision.notes || 'Rejected'\n        );\n      }\n      // Skip leaves the rule in pending\n    }\n\n    console.log(`\\nApproved: ${session.approved.length}`);\n    console.log(`Rejected: ${session.rejected.length}`);\n    console.log(`Remaining pending: ${session.skipped.length}`);\n  }\n\n  /**\n   * Shows current stats\n   */\n  async showStats(): Promise<void> {\n    console.log('\\n');\n    console.log('              PROMPT LEARNING SYSTEM STATUS                     ');\n    console.log('\\n');\n\n    // Source stats\n    const sourceStats = await getSourceStats();\n    console.log('Data Sources:');\n    for (const [name, stats] of Object.entries(sourceStats)) {\n      const status = stats.available ? '' : '';\n      const count = stats.failureCount !== undefined ? ` (${stats.failureCount} failures)` : '';\n      console.log(`  ${status} ${name}${count}`);\n\n      // Show JSONL details if available\n      if (stats.details) {\n        console.log(`      Projects: ${stats.details.projects}`);\n        console.log(`      Files: ${stats.details.files}`);\n        console.log(`      Sessions: ${stats.details.sessions}`);\n      }\n    }\n\n    // Rule stats\n    const ruleStats = await this.ruleWriter.getStats();\n    console.log('\\nRules:');\n    console.log(`  Total learned: ${ruleStats.totalRules}`);\n    console.log(`  Pending review: ${ruleStats.pendingCount}`);\n    console.log(`  Approved: ${ruleStats.approvedCount}`);\n    console.log(`  Rejected: ${ruleStats.rejectedCount}`);\n    console.log(`  Iterations: ${ruleStats.iterationsCount}`);\n\n    console.log('');\n  }\n\n  /**\n   * Creates an empty result for no-failures case\n   */\n  private createEmptyResult(\n    iterationId: string,\n    startTime: number,\n    sources: string[]\n  ): LearningIterationResult {\n    return {\n      iterationId,\n      timestamp: new Date().toISOString(),\n      sources,\n      failuresCollected: 0,\n      explanationsGenerated: 0,\n      patternsDetected: [],\n      rulesProposed: [],\n      rulesApproved: [],\n      rulesRejected: [],\n      durationMs: Date.now() - startTime,\n    };\n  }\n\n  /**\n   * Creates a full result\n   */\n  private createResult(\n    iterationId: string,\n    startTime: number,\n    sources: string[],\n    failuresCollected: number,\n    explanationsGenerated: number,\n    patterns: FailurePattern[],\n    proposed: ProposedRule[],\n    approved: ProposedRule[],\n    rejected: ProposedRule[]\n  ): LearningIterationResult {\n    return {\n      iterationId,\n      timestamp: new Date().toISOString(),\n      sources,\n      failuresCollected,\n      explanationsGenerated,\n      patternsDetected: patterns,\n      rulesProposed: proposed,\n      rulesApproved: approved,\n      rulesRejected: rejected,\n      durationMs: Date.now() - startTime,\n    };\n  }\n\n  /**\n   * Prints pattern summary\n   */\n  private printPatternSummary(patterns: FailurePattern[]): void {\n    console.log('\\n   Patterns detected:');\n    for (const pattern of patterns.slice(0, 5)) {\n      console.log(`     - ${pattern.patternName} (${pattern.frequency} failures)`);\n    }\n    if (patterns.length > 5) {\n      console.log(`     ... and ${patterns.length - 5} more`);\n    }\n  }\n\n  /**\n   * Prints iteration summary\n   */\n  private printIterationSummary(result: LearningIterationResult): void {\n    console.log('\\n');\n    console.log('  LEARNING ITERATION COMPLETE');\n    console.log('');\n    console.log(`  Iteration ID: ${result.iterationId}`);\n    console.log(`  Duration: ${(result.durationMs / 1000).toFixed(1)}s`);\n    console.log('');\n    console.log(`  Failures analyzed: ${result.failuresCollected}`);\n    console.log(`  Explanations generated: ${result.explanationsGenerated}`);\n    console.log(`  Patterns detected: ${result.patternsDetected.length}`);\n    console.log(`  Rules proposed: ${result.rulesProposed.length}`);\n    console.log(`  Rules approved: ${result.rulesApproved.length}`);\n    console.log(`  Rules rejected: ${result.rulesRejected.length}`);\n    console.log('');\n    console.log('  Next steps:');\n    console.log('    1. Review learned-rules.json');\n    console.log('    2. Manually integrate approved rules into prompt-templates.ts');\n    console.log('    3. Run evals to validate improvements');\n    console.log('\\n');\n  }\n}\n\nexport default LearningRunner;\n"]}