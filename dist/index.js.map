{"version":3,"sources":["../src/config/types.ts","../src/config/schemas.ts","../src/config/config-loader.ts","../src/judges/judge-interface.ts","../src/harness/test-harness.ts","../src/judges/builtin/file-existence.ts","../src/judges/builtin/tool-invocation.ts","../src/judges/builtin/pattern-match.ts","../src/judges/builtin/agent-routing.ts","../src/judges/builtin/skill-invocation.ts","../src/judges/builtin/syntax-validation.ts","../src/judges/builtin/llm-judge.ts","../src/judges/judge-registry.ts","../src/utils/eval-loader.ts","../src/runner/eval-runner.ts","../src/utils/reporter.ts","../src/utils/result-aggregator.ts"],"names":["path","fs","stat","path3","fs3","passed","path4","fs4","path5","fs5","path6","fs6","path7","fs7","path8","fs8","path9","fs9"],"mappings":"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","file":"index.js","sourcesContent":["import type { EvalCase, EvalCaseResult } from './schemas.js';\nimport type { Judge } from '../judges/judge-interface.js';\n\nexport interface EvalWorkspace {\n  id: string;\n  path: string;\n}\n\nexport interface ToolCall {\n  toolName: string;\n  input: unknown;\n  output?: unknown;\n  isError?: boolean;\n  timestamp?: number;\n  duration?: number;\n}\n\nexport interface ProgressRecord {\n  type: string;\n  percentage: number;\n  description: string;\n  timestamp: number;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface TranscriptTurn {\n  role: 'user' | 'assistant';\n  content: string;\n  toolCalls?: ToolCall[];\n  reasoning?: string;\n  timestamp: number;\n}\n\nexport interface TranscriptOutcome {\n  files: string[];\n  success: boolean;\n  error?: string;\n  finalState?: Record<string, unknown>;\n}\n\nexport interface Transcript {\n  turns: TranscriptTurn[];\n  outcome: TranscriptOutcome;\n  duration: number;\n  startTime: number;\n  endTime: number;\n}\n\nexport interface AgentContext {\n  workingDirectory: string;\n  evalId: string;\n  evalName: string;\n  sessionId?: string;\n  timeout?: number;\n}\n\nexport interface AgentResult {\n  output: string;\n  success: boolean;\n  toolCalls?: ToolCall[];\n  sessionId?: string;\n  error?: Error;\n  duration?: number;\n  numTurns?: number;\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalCostUsd?: number;\n  };\n}\n\nexport type AgentFunction = (\n  prompt: string,\n  context: AgentContext\n) => Promise<AgentResult>;\n\nexport type AgentType = 'claude-code' | 'generic';\n\nexport interface LearningConfig {\n  enabled?: boolean;\n  ruleOutputDir?: string;\n  minFailuresForPattern?: number;\n  similarityThreshold?: number;\n  maxRulesPerIteration?: number;\n  minRuleConfidence?: number;\n  autoApprove?: boolean;\n  autoApproveThreshold?: number;\n}\n\nexport interface VibeCheckConfig {\n  agent: AgentFunction;\n  agentType?: AgentType;\n  testMatch?: string[];\n  testDir?: string;\n  parallel?: boolean;\n  maxConcurrency?: number;\n  timeout?: number;\n  maxRetries?: number;\n  retryDelayMs?: number;\n  retryBackoffMultiplier?: number;\n  trials?: number;\n  trialPassThreshold?: number;\n  judges?: Judge[];\n  llmJudgeModel?: string;\n  rubricsDir?: string;\n  outputDir?: string;\n  verbose?: boolean;\n  preserveWorkspaces?: boolean;\n  learning?: LearningConfig;\n  createWorkspace?: () => Promise<EvalWorkspace>;\n  cleanupWorkspace?: (workspace: EvalWorkspace) => Promise<void>;\n  setup?: () => Promise<void>;\n  teardown?: () => Promise<void>;\n  beforeEach?: (evalCase: EvalCase) => Promise<void>;\n  afterEach?: (result: EvalCaseResult) => Promise<void>;\n}\n\nexport interface ResolvedConfig extends Required<Omit<VibeCheckConfig, 'setup' | 'teardown' | 'beforeEach' | 'afterEach' | 'learning' | 'judges' | 'createWorkspace' | 'cleanupWorkspace'>> {\n  setup?: () => Promise<void>;\n  teardown?: () => Promise<void>;\n  beforeEach?: (evalCase: EvalCase) => Promise<void>;\n  afterEach?: (result: EvalCaseResult) => Promise<void>;\n  learning: Required<LearningConfig>;\n  judges: Judge[];\n  createWorkspace?: () => Promise<EvalWorkspace>;\n  cleanupWorkspace?: (workspace: EvalWorkspace) => Promise<void>;\n}\n\nexport function defineConfig(config: VibeCheckConfig): VibeCheckConfig {\n  return config;\n}\n\nexport const defaultConfig: Omit<ResolvedConfig, 'agent'> = {\n  agentType: 'generic',\n  testMatch: ['**/*.eval.json'],\n  testDir: './__evals__',\n  parallel: true,\n  maxConcurrency: 3,\n  timeout: 300000,\n  maxRetries: 2,\n  retryDelayMs: 1000,\n  retryBackoffMultiplier: 2,\n  trials: 1,\n  trialPassThreshold: 0.5,\n  judges: [],\n  llmJudgeModel: 'claude-sonnet-4-20250514',\n  rubricsDir: './__evals__/rubrics',\n  outputDir: './__evals__/results',\n  verbose: false,\n  preserveWorkspaces: false,\n  learning: {\n    enabled: false,\n    ruleOutputDir: './prompts',\n    minFailuresForPattern: 2,\n    similarityThreshold: 0.7,\n    maxRulesPerIteration: 5,\n    minRuleConfidence: 0.6,\n    autoApprove: false,\n    autoApproveThreshold: 0.8,\n  },\n};\n","import { z } from 'zod';\n\nexport const EvalCategorySchema = z.enum(['tool', 'code-gen', 'multi-turn', 'routing', 'basic']);\nexport type EvalCategory = z.infer<typeof EvalCategorySchema>;\n\nexport const EvalAgentTypeSchema = z.enum(['coding', 'conversational', 'research', 'computer-use', 'general']);\nexport type EvalAgentType = z.infer<typeof EvalAgentTypeSchema>;\n\nexport const ReferenceSolutionSchema = z.object({\n  files: z.array(z.string()).optional(),\n  description: z.string().optional(),\n  code: z.string().optional(),\n});\nexport type ReferenceSolution = z.infer<typeof ReferenceSolutionSchema>;\n\nexport const TrialConfigSchema = z.object({\n  count: z.number().min(1).max(10).default(1),\n  passThreshold: z.number().min(0).max(1).default(0.5),\n});\nexport type TrialConfig = z.infer<typeof TrialConfigSchema>;\n\nconst BaseEvalCaseSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  description: z.string(),\n  category: EvalCategorySchema,\n  tags: z.array(z.string()).optional(),\n  enabled: z.boolean().default(true),\n  timeout: z.number().optional(),\n  agentType: EvalAgentTypeSchema.optional(),\n  trials: TrialConfigSchema.optional(),\n  referenceSolution: ReferenceSolutionSchema.optional(),\n});\n\nexport const ExpectedToolCallSchema = z.object({\n  toolName: z.string(),\n  expectedInput: z.record(z.unknown()).optional(),\n  minCalls: z.number().optional(),\n  maxCalls: z.number().optional(),\n});\nexport type ExpectedToolCall = z.infer<typeof ExpectedToolCallSchema>;\n\nexport const ExpectedSkillSchema = z.object({\n  skillName: z.string(),\n  minCalls: z.number().optional().default(1),\n});\nexport type ExpectedSkill = z.infer<typeof ExpectedSkillSchema>;\n\nexport const ToolEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('tool'),\n  prompt: z.string(),\n  expectedToolCalls: z.array(ExpectedToolCallSchema),\n  expectedSkills: z.array(ExpectedSkillSchema).optional(),\n  judges: z.array(z.string()),\n});\nexport type ToolEvalCase = z.infer<typeof ToolEvalSchema>;\n\nexport const ExpectedPatternSchema = z.object({\n  file: z.string(),\n  patterns: z.array(z.string()),\n});\nexport type ExpectedPattern = z.infer<typeof ExpectedPatternSchema>;\n\nexport const CodeGenEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('code-gen'),\n  prompt: z.string(),\n  targetFiles: z.array(z.string()),\n  expectedPatterns: z.array(ExpectedPatternSchema).optional(),\n  syntaxValidation: z.boolean().default(true),\n  buildVerification: z.boolean().default(false),\n  judges: z.array(z.string()),\n});\nexport type CodeGenEvalCase = z.infer<typeof CodeGenEvalSchema>;\n\nexport const RoutingEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('routing'),\n  prompt: z.string(),\n  expectedAgent: z.string(),\n  shouldNotRoute: z.array(z.string()).optional(),\n  judges: z.array(z.string()),\n});\nexport type RoutingEvalCase = z.infer<typeof RoutingEvalSchema>;\n\nexport const TurnSchema = z.object({\n  prompt: z.string(),\n  expectedBehavior: z.string().optional(),\n  judges: z.array(z.string()).optional(),\n});\nexport type Turn = z.infer<typeof TurnSchema>;\n\nexport const MultiTurnEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('multi-turn'),\n  turns: z.array(TurnSchema),\n  sessionPersistence: z.boolean().default(true),\n  contextValidation: z.array(z.string()).optional(),\n  judges: z.array(z.string()).optional(),\n});\nexport type MultiTurnEvalCase = z.infer<typeof MultiTurnEvalSchema>;\n\nexport const BasicEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('basic'),\n  prompt: z.string(),\n  expectedBehavior: z.string().optional(),\n  judges: z.array(z.string()),\n});\nexport type BasicEvalCase = z.infer<typeof BasicEvalSchema>;\n\nexport const EvalCaseSchema = z.discriminatedUnion('category', [\n  ToolEvalSchema,\n  CodeGenEvalSchema,\n  RoutingEvalSchema,\n  MultiTurnEvalSchema,\n  BasicEvalSchema,\n]);\nexport type EvalCase = z.infer<typeof EvalCaseSchema>;\n\nexport function parseEvalCase(data: unknown): EvalCase {\n  return EvalCaseSchema.parse(data);\n}\n\nexport function isToolEval(evalCase: EvalCase): evalCase is ToolEvalCase {\n  return evalCase.category === 'tool';\n}\n\nexport function isCodeGenEval(evalCase: EvalCase): evalCase is CodeGenEvalCase {\n  return evalCase.category === 'code-gen';\n}\n\nexport function isRoutingEval(evalCase: EvalCase): evalCase is RoutingEvalCase {\n  return evalCase.category === 'routing';\n}\n\nexport function isMultiTurnEval(evalCase: EvalCase): evalCase is MultiTurnEvalCase {\n  return evalCase.category === 'multi-turn';\n}\n\nexport function isBasicEval(evalCase: EvalCase): evalCase is BasicEvalCase {\n  return evalCase.category === 'basic';\n}\n\nexport interface JudgeResult {\n  judgeId: string;\n  passed: boolean;\n  score: number;\n  confidence: number;\n  reasoning: string;\n  details?: Record<string, unknown>;\n}\n\nexport type ErrorType = 'api' | 'timeout' | 'judge' | 'unknown';\n\nexport interface EvalCaseResult {\n  evalCase: EvalCase;\n  success: boolean;\n  output: string;\n  duration: number;\n  judgeResults: JudgeResult[];\n  toolCalls?: Array<{ toolName: string; input: unknown; output?: unknown; isError?: boolean; timestamp?: number; duration?: number }>;\n  error?: Error;\n  errorType?: ErrorType;\n  retryCount?: number;\n  trialResults?: boolean[];\n  /** Whether this test passed on a retry (indicates flaky test) */\n  flaky?: boolean;\n  /** Error messages from each failed retry attempt */\n  retryErrors?: string[];\n}\n","import * as path from 'path';\nimport * as fs from 'fs/promises';\nimport { pathToFileURL } from 'url';\nimport type { VibeCheckConfig, ResolvedConfig } from './types.js';\nimport { defaultConfig } from './types.js';\n\nconst CONFIG_FILE_NAMES = [\n  'vibe-check.config.ts',\n  'vibe-check.config.js',\n  'vibe-check.config.mjs',\n];\n\nexport async function loadConfig(configPath?: string): Promise<ResolvedConfig> {\n  const cwd = process.cwd();\n\n  let configFile: string | undefined;\n\n  if (configPath) {\n    configFile = path.isAbsolute(configPath) ? configPath : path.join(cwd, configPath);\n  } else {\n    for (const name of CONFIG_FILE_NAMES) {\n      const candidate = path.join(cwd, name);\n      try {\n        await fs.access(candidate);\n        configFile = candidate;\n        break;\n      } catch {\n        // Continue to next candidate\n      }\n    }\n  }\n\n  if (!configFile) {\n    throw new Error(\n      `No config file found. Create one of: ${CONFIG_FILE_NAMES.join(', ')}`\n    );\n  }\n\n  const userConfig = await importConfig(configFile);\n\n  if (!userConfig.agent) {\n    throw new Error('Config must specify an \"agent\" function');\n  }\n\n  return resolveConfig(userConfig);\n}\n\nasync function importConfig(configPath: string): Promise<VibeCheckConfig> {\n  const fileUrl = pathToFileURL(configPath).href;\n\n  try {\n    const module = await import(fileUrl);\n    return module.default || module;\n  } catch (error) {\n    if (configPath.endsWith('.ts')) {\n      throw new Error(\n        `Failed to import TypeScript config. Run with tsx: npx vibe-check\\n${error}`\n      );\n    }\n    throw error;\n  }\n}\n\nfunction resolveConfig(userConfig: VibeCheckConfig): ResolvedConfig {\n  return {\n    agent: userConfig.agent,\n    agentType: userConfig.agentType ?? defaultConfig.agentType,\n    testMatch: userConfig.testMatch ?? defaultConfig.testMatch,\n    testDir: userConfig.testDir ?? defaultConfig.testDir,\n    parallel: userConfig.parallel ?? defaultConfig.parallel,\n    maxConcurrency: userConfig.maxConcurrency ?? defaultConfig.maxConcurrency,\n    timeout: userConfig.timeout ?? defaultConfig.timeout,\n    maxRetries: userConfig.maxRetries ?? defaultConfig.maxRetries,\n    retryDelayMs: userConfig.retryDelayMs ?? defaultConfig.retryDelayMs,\n    retryBackoffMultiplier: userConfig.retryBackoffMultiplier ?? defaultConfig.retryBackoffMultiplier,\n    trials: userConfig.trials ?? defaultConfig.trials,\n    trialPassThreshold: userConfig.trialPassThreshold ?? defaultConfig.trialPassThreshold,\n    judges: userConfig.judges ?? defaultConfig.judges,\n    llmJudgeModel: userConfig.llmJudgeModel ?? defaultConfig.llmJudgeModel,\n    rubricsDir: userConfig.rubricsDir ?? defaultConfig.rubricsDir,\n    outputDir: userConfig.outputDir ?? defaultConfig.outputDir,\n    verbose: userConfig.verbose ?? defaultConfig.verbose,\n    preserveWorkspaces: userConfig.preserveWorkspaces ?? defaultConfig.preserveWorkspaces,\n    createWorkspace: userConfig.createWorkspace,\n    cleanupWorkspace: userConfig.cleanupWorkspace,\n    learning: {\n      enabled: userConfig.learning?.enabled ?? defaultConfig.learning.enabled,\n      ruleOutputDir: userConfig.learning?.ruleOutputDir ?? defaultConfig.learning.ruleOutputDir,\n      minFailuresForPattern: userConfig.learning?.minFailuresForPattern ?? defaultConfig.learning.minFailuresForPattern,\n      similarityThreshold: userConfig.learning?.similarityThreshold ?? defaultConfig.learning.similarityThreshold,\n      maxRulesPerIteration: userConfig.learning?.maxRulesPerIteration ?? defaultConfig.learning.maxRulesPerIteration,\n      minRuleConfidence: userConfig.learning?.minRuleConfidence ?? defaultConfig.learning.minRuleConfidence,\n      autoApprove: userConfig.learning?.autoApprove ?? defaultConfig.learning.autoApprove,\n      autoApproveThreshold: userConfig.learning?.autoApproveThreshold ?? defaultConfig.learning.autoApproveThreshold,\n    },\n    setup: userConfig.setup,\n    teardown: userConfig.teardown,\n    beforeEach: userConfig.beforeEach,\n    afterEach: userConfig.afterEach,\n  };\n}\n","import type { EvalCase, JudgeResult } from '../config/schemas.js';\nimport type { AgentResult, Transcript, ProgressRecord } from '../config/types.js';\n\nexport interface ExecutionResult {\n  success: boolean;\n  output: string;\n  error?: Error;\n  toolCalls: ToolCallRecord[];\n  duration: number;\n  numTurns?: number;\n  sessionId?: string;\n  workingDirectory?: string;\n  workspaceId?: string;\n  transcript?: Transcript;\n  progressUpdates?: ProgressRecord[];\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalCostUsd?: number;\n  };\n}\n\nexport interface ToolCallRecord {\n  toolName: string;\n  toolUseId?: string;\n  input: unknown;\n  output?: unknown;\n  timestamp?: number;\n  duration?: number;\n  isError?: boolean;\n}\n\nexport interface JudgeContext {\n  evalCase: EvalCase;\n  executionResult: ExecutionResult;\n  workingDirectory: string;\n  turnIndex?: number;\n}\n\nexport type JudgeType = 'code' | 'llm' | 'hybrid';\n\nexport interface Judge {\n  id: string;\n  name: string;\n  type: JudgeType;\n  evaluate(context: JudgeContext): Promise<JudgeResult>;\n}\n\nexport abstract class BaseJudge implements Judge {\n  abstract id: string;\n  abstract name: string;\n  abstract type: JudgeType;\n\n  abstract evaluate(context: JudgeContext): Promise<JudgeResult>;\n\n  protected createResult(params: {\n    passed: boolean;\n    score: number;\n    reasoning: string;\n    confidence?: number;\n    details?: Record<string, unknown>;\n  }): JudgeResult {\n    return {\n      judgeId: this.id,\n      passed: params.passed,\n      score: params.score,\n      confidence: params.confidence ?? 1,\n      reasoning: params.reasoning,\n      details: params.details,\n    };\n  }\n\n  protected notApplicable(reason: string = 'Not applicable'): JudgeResult {\n    return this.createResult({\n      passed: true,\n      score: 100,\n      reasoning: reason,\n    });\n  }\n}\n\nexport function agentResultToExecutionResult(result: AgentResult): ExecutionResult {\n  return {\n    success: result.success,\n    output: result.output,\n    error: result.error,\n    toolCalls: (result.toolCalls ?? []).map(tc => ({\n      toolName: tc.toolName,\n      input: tc.input,\n      output: tc.output,\n      isError: tc.isError,\n    })),\n    duration: result.duration ?? 0,\n    numTurns: result.numTurns,\n    sessionId: result.sessionId,\n    usage: result.usage,\n  };\n}\n\nexport { JudgeResult };\n","import * as fs from 'fs/promises';\nimport * as fsSync from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport type { EvalCase } from '../config/schemas.js';\nimport type { AgentFunction, AgentContext, AgentResult, ResolvedConfig, EvalWorkspace, ToolCall } from '../config/types.js';\nimport type { ExecutionResult } from '../judges/judge-interface.js';\nimport { agentResultToExecutionResult } from '../judges/judge-interface.js';\n\nexport interface TestHarnessOptions {\n  config: ResolvedConfig;\n}\n\n/** @deprecated Use TestHarnessOptions instead */\nexport type HarnessOptions = TestHarnessOptions;\n\nexport class TestHarness {\n  private config: ResolvedConfig;\n  private workspaces: Map<string, EvalWorkspace> = new Map();\n\n  constructor(options: TestHarnessOptions) {\n    this.config = options.config;\n  }\n\n  private verbose(message: string): void {\n    if (this.config.verbose) {\n      console.log(message);\n    }\n  }\n\n  async execute(evalCase: EvalCase): Promise<ExecutionResult> {\n    this.verbose(`[${evalCase.id}] Starting: ${evalCase.name}`);\n\n    const workspace = this.config.createWorkspace\n      ? await this.config.createWorkspace()\n      : await this.createDefaultWorkspace();\n\n    this.workspaces.set(workspace.id, workspace);\n    this.verbose(`[${evalCase.id}] Workspace: ${workspace.id}`);\n\n    try {\n      const context: AgentContext = {\n        workingDirectory: workspace.path,\n        evalId: evalCase.id,\n        evalName: evalCase.name,\n        timeout: evalCase.timeout ?? this.config.timeout,\n      };\n\n      const prompt = this.getPrompt(evalCase);\n      const startTime = Date.now();\n\n      this.verbose(`[${evalCase.id}] Executing agent...`);\n      const result = await this.executeWithTimeout(\n        this.config.agent,\n        prompt,\n        context,\n        context.timeout!\n      );\n\n      // Extract tool calls from JSONL for claude-code agent type\n      if (this.config.agentType === 'claude-code') {\n        const jsonlToolCalls = await this.extractToolCallsFromJsonl(workspace.path);\n        if (jsonlToolCalls.length > 0) {\n          this.verbose(`[${evalCase.id}] Found ${jsonlToolCalls.length} tool calls from JSONL`);\n          result.toolCalls = result.toolCalls || [];\n          for (const call of jsonlToolCalls) {\n            if (!result.toolCalls.some((t) => t.toolName === call.toolName)) {\n              result.toolCalls.push(call);\n            }\n          }\n        }\n      }\n\n      const executionResult = agentResultToExecutionResult(result);\n      executionResult.duration = result.duration ?? (Date.now() - startTime);\n      executionResult.workingDirectory = workspace.path;\n\n      this.verbose(`[${evalCase.id}] Completed (${result.success ? 'success' : 'failed'}) in ${executionResult.duration}ms`);\n\n      // Store workspace ID in result so eval runner can clean up after judging\n      executionResult.workspaceId = workspace.id;\n\n      return executionResult;\n    } catch (error) {\n      // Still try to extract tool calls from JSONL even on error/timeout\n      let jsonlToolCalls: ToolCall[] = [];\n      if (this.config.agentType === 'claude-code') {\n        jsonlToolCalls = await this.extractToolCallsFromJsonl(workspace.path);\n      }\n\n      // On error, cleanup immediately\n      if (this.config.cleanupWorkspace || !this.config.preserveWorkspaces) {\n        await this.cleanupWorkspaceById(workspace.id);\n      }\n\n      // Re-throw with tool calls available for error analysis\n      const executionError = error as Error & { toolCalls?: ToolCall[] };\n      executionError.toolCalls = jsonlToolCalls;\n      throw executionError;\n    }\n    // Note: Workspace cleanup is deferred until after judging completes\n    // The eval runner should call cleanupWorkspaceById after judges run\n  }\n\n  async executeMultiTurn(evalCase: EvalCase & { category: 'multi-turn' }): Promise<ExecutionResult[]> {\n    this.verbose(`[${evalCase.id}] Starting multi-turn: ${evalCase.name} (${evalCase.turns.length} turns)`);\n\n    const workspace = this.config.createWorkspace\n      ? await this.config.createWorkspace()\n      : await this.createDefaultWorkspace();\n\n    this.workspaces.set(workspace.id, workspace);\n    this.verbose(`[${evalCase.id}] Workspace: ${workspace.id}`);\n\n    const results: ExecutionResult[] = [];\n    let sessionId: string | undefined;\n\n    try {\n      for (let i = 0; i < evalCase.turns.length; i++) {\n        const turn = evalCase.turns[i];\n\n        const context: AgentContext = {\n          workingDirectory: workspace.path,\n          evalId: evalCase.id,\n          evalName: `${evalCase.name} - Turn ${i + 1}`,\n          timeout: evalCase.timeout ?? this.config.timeout,\n          sessionId,\n        };\n\n        const startTime = Date.now();\n\n        this.verbose(`[${evalCase.id}] Executing turn ${i + 1}/${evalCase.turns.length}...`);\n        const result = await this.executeWithTimeout(\n          this.config.agent,\n          turn.prompt,\n          context,\n          context.timeout!\n        );\n\n        // Extract tool calls from JSONL for claude-code agent type\n        if (this.config.agentType === 'claude-code') {\n          const jsonlToolCalls = await this.extractToolCallsFromJsonl(workspace.path);\n          if (jsonlToolCalls.length > 0) {\n            this.verbose(`[${evalCase.id}] Found ${jsonlToolCalls.length} tool calls from JSONL`);\n            result.toolCalls = result.toolCalls || [];\n            for (const call of jsonlToolCalls) {\n              if (!result.toolCalls.some((t) => t.toolName === call.toolName)) {\n                result.toolCalls.push(call);\n              }\n            }\n          }\n        }\n\n        const executionResult = agentResultToExecutionResult(result);\n        executionResult.duration = result.duration ?? (Date.now() - startTime);\n        executionResult.workingDirectory = workspace.path;\n\n        this.verbose(`[${evalCase.id}] Turn ${i + 1} completed (${result.success ? 'success' : 'failed'}) in ${executionResult.duration}ms`);\n\n        results.push(executionResult);\n\n        sessionId = result.sessionId;\n      }\n\n      this.verbose(`[${evalCase.id}] Multi-turn completed`);\n\n      // Store workspace ID in final result so eval runner can clean up after judging\n      if (results.length > 0) {\n        results[results.length - 1].workspaceId = workspace.id;\n      }\n\n      return results;\n    } catch (error) {\n      // Still try to extract tool calls from JSONL even on error/timeout\n      let jsonlToolCalls: ToolCall[] = [];\n      if (this.config.agentType === 'claude-code') {\n        jsonlToolCalls = await this.extractToolCallsFromJsonl(workspace.path);\n      }\n\n      // On error, cleanup immediately\n      if (this.config.cleanupWorkspace || !this.config.preserveWorkspaces) {\n        await this.cleanupWorkspaceById(workspace.id);\n      }\n\n      // Re-throw with tool calls available for error analysis\n      const executionError = error as Error & { toolCalls?: ToolCall[] };\n      executionError.toolCalls = jsonlToolCalls;\n      throw executionError;\n    }\n    // Note: Workspace cleanup is deferred until after judging completes\n    // The eval runner should call cleanupWorkspaceById after judges run\n  }\n\n  private getPrompt(evalCase: EvalCase): string {\n    if ('prompt' in evalCase) {\n      return evalCase.prompt;\n    }\n    if ('turns' in evalCase && evalCase.turns.length > 0) {\n      return evalCase.turns[0].prompt;\n    }\n    throw new Error(`Eval case ${evalCase.id} has no prompt`);\n  }\n\n  private async executeWithTimeout(\n    agent: AgentFunction,\n    prompt: string,\n    context: AgentContext,\n    timeout: number\n  ): Promise<AgentResult> {\n    return new Promise(async (resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Agent execution timed out after ${timeout}ms`));\n      }, timeout);\n\n      try {\n        const result = await agent(prompt, context);\n        clearTimeout(timer);\n        resolve(result);\n      } catch (error) {\n        clearTimeout(timer);\n        reject(error);\n      }\n    });\n  }\n\n  async cleanup(): Promise<void> {\n    if (this.config.cleanupWorkspace || !this.config.preserveWorkspaces) {\n      for (const id of this.workspaces.keys()) {\n        await this.cleanupWorkspaceById(id);\n      }\n    }\n  }\n\n  async cleanupWorkspace(workspaceId: string): Promise<void> {\n    if (this.config.cleanupWorkspace || !this.config.preserveWorkspaces) {\n      await this.cleanupWorkspaceById(workspaceId);\n    }\n  }\n\n  private async createDefaultWorkspace(): Promise<EvalWorkspace> {\n    const id = `ws-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n    const baseDir = this.getWorkspaceBaseDir();\n    const workspacePath = path.join(baseDir, id);\n\n    await fs.mkdir(workspacePath, { recursive: true });\n    await fs.mkdir(path.join(workspacePath, 'src'), { recursive: true });\n    await fs.writeFile(\n      path.join(workspacePath, 'package.json'),\n      JSON.stringify({ name: 'eval-workspace', version: '1.0.0', type: 'module' }, null, 2)\n    );\n\n    return { id, path: workspacePath };\n  }\n\n  private getWorkspaceBaseDir(): string {\n    const cwd = process.cwd();\n    const evalsResultsDir = path.join(cwd, '__evals__', 'results', 'workspaces');\n\n    try {\n      fsSync.mkdirSync(evalsResultsDir, { recursive: true });\n      const testFile = path.join(evalsResultsDir, '.write-test');\n      fsSync.writeFileSync(testFile, '');\n      fsSync.unlinkSync(testFile);\n      return evalsResultsDir;\n    } catch {\n      const tmpDir = fsSync.realpathSync(os.tmpdir());\n      return path.join(tmpDir, 'vibe-check-evals');\n    }\n  }\n\n  private async cleanupWorkspaceById(id: string): Promise<void> {\n    const workspace = this.workspaces.get(id);\n    if (workspace) {\n      this.verbose(`Cleaning up workspace: ${id}`);\n      if (this.config.cleanupWorkspace) {\n        await this.config.cleanupWorkspace(workspace);\n      } else {\n        try {\n          await fs.rm(workspace.path, { recursive: true, force: true, maxRetries: 3, retryDelay: 100 });\n        } catch {\n          // Ignore cleanup errors\n        }\n      }\n      this.workspaces.delete(id);\n    }\n  }\n\n  private async extractToolCallsFromJsonl(workspacePath: string): Promise<ToolCall[]> {\n    const toolCalls: ToolCall[] = [];\n    const toolUseMap = new Map<string, { name: string; input: unknown }>();\n\n    try {\n      const claudeDir = path.join(workspacePath, '.claude', 'projects');\n      try {\n        await fs.access(claudeDir);\n      } catch {\n        return toolCalls;\n      }\n\n      const projectDirs = await fs.readdir(claudeDir);\n\n      for (const projectDir of projectDirs) {\n        const projectPath = path.join(claudeDir, projectDir);\n        const stat = await fs.stat(projectPath);\n        if (!stat.isDirectory()) continue;\n\n        const files = await fs.readdir(projectPath);\n        const jsonlFiles = files.filter((f) => f.endsWith('.jsonl'));\n\n        for (const jsonlFile of jsonlFiles) {\n          const filePath = path.join(projectPath, jsonlFile);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const lines = content.split('\\n').filter((line) => line.trim());\n\n          // First pass: collect all tool_use blocks\n          for (const line of lines) {\n            try {\n              const entry = JSON.parse(line);\n              const message = entry.message;\n              if (!message?.content || !Array.isArray(message.content)) continue;\n\n              for (const block of message.content) {\n                if (block.type === 'tool_use' && typeof block.name === 'string' && block.id) {\n                  toolUseMap.set(block.id, { name: block.name, input: block.input || {} });\n                }\n              }\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n\n          // Second pass: match with tool_result\n          for (const line of lines) {\n            try {\n              const entry = JSON.parse(line);\n              const message = entry.message;\n              if (!message?.content || !Array.isArray(message.content)) continue;\n\n              for (const block of message.content) {\n                if (block.type === 'tool_result' && block.tool_use_id) {\n                  const toolUse = toolUseMap.get(block.tool_use_id);\n                  if (toolUse) {\n                    const output = typeof block.content === 'string' ? block.content : JSON.stringify(block.content);\n                    if (!toolCalls.some((t) => t.toolName === toolUse.name && JSON.stringify(t.input) === JSON.stringify(toolUse.input))) {\n                      toolCalls.push({\n                        toolName: toolUse.name,\n                        input: toolUse.input,\n                        output,\n                        isError: block.is_error,\n                      });\n                    }\n                    toolUseMap.delete(block.tool_use_id);\n                  }\n                }\n              }\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n\n          // Add any tool uses without results\n          for (const [, toolUse] of toolUseMap) {\n            if (!toolCalls.some((t) => t.toolName === toolUse.name && JSON.stringify(t.input) === JSON.stringify(toolUse.input))) {\n              toolCalls.push({\n                toolName: toolUse.name,\n                input: toolUse.input,\n              });\n            }\n          }\n        }\n      }\n    } catch {\n      // Ignore errors\n    }\n\n    return toolCalls;\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface FileCheckResult {\n  file: string;\n  exists: boolean;\n}\n\nexport class FileExistenceJudge extends BaseJudge {\n  id = 'file-existence';\n  name = 'File Existence Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    const targetFiles = evalCase.targetFiles || [];\n    if (targetFiles.length === 0) {\n      return this.notApplicable('No target files specified');\n    }\n\n    const baseDir = workingDirectory || process.cwd();\n    const results: FileCheckResult[] = [];\n\n    for (const file of targetFiles) {\n      const fullPath = path.join(baseDir, file);\n      try {\n        await fs.access(fullPath);\n        results.push({ file, exists: true });\n      } catch {\n        results.push({ file, exists: false });\n      }\n    }\n\n    const existingCount = results.filter((r) => r.exists).length;\n    const score = (existingCount / targetFiles.length) * 100;\n    const passed = score >= 80;\n\n    const missingFiles = results.filter((r) => !r.exists).map((r) => r.file);\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        missingFiles.length > 0\n          ? `${existingCount}/${targetFiles.length} expected files exist. Missing: ${missingFiles.join(', ')}`\n          : `All ${targetFiles.length} expected files exist`,\n      details: { results, missingFiles },\n    });\n  }\n}\n","import { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isToolEval } from '../../config/schemas.js';\nimport type { ExpectedToolCall } from '../../config/schemas.js';\n\ninterface ToolCallStats {\n  toolName: string;\n  expected: ExpectedToolCall;\n  actualCount: number;\n  passed: boolean;\n  reason: string;\n}\n\nexport class ToolInvocationJudge extends BaseJudge {\n  id = 'tool-invocation';\n  name = 'Tool Invocation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase } = context;\n\n    if (!isToolEval(evalCase)) {\n      return this.notApplicable('Only applicable for tool evals');\n    }\n\n    const expectedCalls = evalCase.expectedToolCalls || [];\n    if (expectedCalls.length === 0) {\n      return this.notApplicable('No expected tool calls specified');\n    }\n\n    const actualCalls = executionResult.toolCalls || [];\n    const toolCallCounts = new Map<string, number>();\n\n    for (const call of actualCalls) {\n      const count = toolCallCounts.get(call.toolName) || 0;\n      toolCallCounts.set(call.toolName, count + 1);\n    }\n\n    const stats: ToolCallStats[] = [];\n\n    for (const expected of expectedCalls) {\n      const actualCount = toolCallCounts.get(expected.toolName) || 0;\n      const minCalls = expected.minCalls ?? 1;\n      const maxCalls = expected.maxCalls ?? Infinity;\n\n      let passed = true;\n      let reason = '';\n\n      if (actualCount < minCalls) {\n        passed = false;\n        reason = `Expected at least ${minCalls} call(s), got ${actualCount}`;\n      } else if (actualCount > maxCalls) {\n        passed = false;\n        reason = `Expected at most ${maxCalls} call(s), got ${actualCount}`;\n      } else {\n        reason = `Called ${actualCount} time(s)`;\n      }\n\n      stats.push({\n        toolName: expected.toolName,\n        expected,\n        actualCount,\n        passed,\n        reason,\n      });\n    }\n\n    const passedCount = stats.filter((s) => s.passed).length;\n    const score = (passedCount / stats.length) * 100;\n    const passed = passedCount === stats.length;\n\n    const failedTools = stats.filter((s) => !s.passed);\n    const reasoning =\n      failedTools.length > 0\n        ? `${passedCount}/${stats.length} expected tool invocations satisfied. Failed: ${failedTools.map((s) => `${s.toolName} (${s.reason})`).join(', ')}`\n        : `All ${stats.length} expected tool invocations satisfied`;\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: {\n        stats,\n        actualToolCalls: actualCalls.map((c) => c.toolName),\n        toolCallCounts: Object.fromEntries(toolCallCounts),\n      },\n    });\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface PatternCheckResult {\n  file: string;\n  patterns: Array<{\n    pattern: string;\n    found: boolean;\n  }>;\n  allFound: boolean;\n}\n\nexport class PatternMatchJudge extends BaseJudge {\n  id = 'pattern-match';\n  name = 'Pattern Match Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    const expectedPatterns = evalCase.expectedPatterns || [];\n    if (expectedPatterns.length === 0) {\n      return this.notApplicable('No expected patterns specified');\n    }\n\n    const baseDir = workingDirectory || process.cwd();\n    const results: PatternCheckResult[] = [];\n\n    for (const { file, patterns } of expectedPatterns) {\n      const fullPath = path.join(baseDir, file);\n      let content = '';\n\n      try {\n        content = await fs.readFile(fullPath, 'utf-8');\n      } catch {\n        results.push({\n          file,\n          patterns: patterns.map((p) => ({ pattern: p, found: false })),\n          allFound: false,\n        });\n        continue;\n      }\n\n      const patternResults = patterns.map((pattern) => {\n        const regex = new RegExp(pattern, 'gm');\n        return {\n          pattern,\n          found: regex.test(content),\n        };\n      });\n\n      results.push({\n        file,\n        patterns: patternResults,\n        allFound: patternResults.every((p) => p.found),\n      });\n    }\n\n    const totalPatterns = results.reduce((sum, r) => sum + r.patterns.length, 0);\n    const foundPatterns = results.reduce(\n      (sum, r) => sum + r.patterns.filter((p) => p.found).length,\n      0\n    );\n    const score = totalPatterns > 0 ? (foundPatterns / totalPatterns) * 100 : 100;\n    const passed = score >= 80;\n\n    const failedFiles = results.filter((r) => !r.allFound);\n    const reasoning =\n      failedFiles.length > 0\n        ? `${foundPatterns}/${totalPatterns} patterns found. Missing patterns in: ${failedFiles.map((r) => r.file).join(', ')}`\n        : `All ${totalPatterns} expected patterns found`;\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: { results },\n    });\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isRoutingEval } from '../../config/schemas.js';\n\nconst DEFAULT_WORK_TYPE_KEYWORDS: Record<string, string[]> = {};\n\nexport interface AgentRoutingJudgeOptions {\n  workTypeKeywords?: Record<string, string[]>;\n}\n\nexport class AgentRoutingJudge extends BaseJudge {\n  id = 'agent-routing';\n  name = 'Agent Routing Judge';\n  type: JudgeType = 'code';\n\n  private workTypeKeywords: Record<string, string[]>;\n\n  constructor(options: AgentRoutingJudgeOptions = {}) {\n    super();\n    this.workTypeKeywords = options.workTypeKeywords || DEFAULT_WORK_TYPE_KEYWORDS;\n  }\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase, workingDirectory } = context;\n\n    if (!isRoutingEval(evalCase)) {\n      return this.notApplicable('Only applicable for routing evals');\n    }\n\n    const taskCalls = executionResult.toolCalls.filter(\n      (call) => call.toolName === 'Task' || call.toolName.includes('task')\n    );\n\n    let agentsInvoked = taskCalls\n      .map((call) => {\n        const input = call.input as Record<string, unknown> | undefined;\n        return (input?.agent as string) || (input?.subagent_type as string) || 'unknown';\n      })\n      .filter((agent) => agent !== 'unknown');\n\n    const jsonlAgents = await this.extractAgentsFromJsonl(workingDirectory);\n    agentsInvoked = [...new Set([...agentsInvoked, ...jsonlAgents])];\n\n    const expectedAgent = evalCase.expectedAgent;\n    const invokedExpected = agentsInvoked.includes(expectedAgent);\n\n    const forbiddenAgents = evalCase.shouldNotRoute || [];\n    const invokedForbidden = forbiddenAgents.filter((a) => agentsInvoked.includes(a));\n\n    const output = executionResult.output || '';\n    const outputLower = output.toLowerCase();\n    const hasDelegationIntent = this.checkDelegationIntent(outputLower, expectedAgent, forbiddenAgents);\n\n    let score: number;\n    let passed: boolean;\n    let reasoning: string;\n\n    if (invokedExpected && invokedForbidden.length === 0) {\n      score = 100;\n      passed = true;\n      reasoning = `Correctly routed to ${expectedAgent}`;\n    } else if (invokedExpected && invokedForbidden.length > 0) {\n      score = 50;\n      passed = false;\n      reasoning = `Routed to ${expectedAgent} but also incorrectly routed to: ${invokedForbidden.join(', ')}`;\n    } else if (hasDelegationIntent.toExpected && !hasDelegationIntent.toForbidden) {\n      score = 80;\n      passed = true;\n      reasoning = `AI indicated delegation intent to ${expectedAgent} (no actual Task tool invocation detected)`;\n    } else if (hasDelegationIntent.toExpected && hasDelegationIntent.toForbidden) {\n      score = 40;\n      passed = false;\n      reasoning = `AI mentioned ${expectedAgent} but also mentioned forbidden agents`;\n    } else if (hasDelegationIntent.performedRightWork) {\n      score = 70;\n      passed = true;\n      reasoning = `AI performed ${expectedAgent}-appropriate work directly (no delegation, but correct work type)`;\n    } else if (agentsInvoked.length === 0) {\n      score = 0;\n      passed = false;\n      reasoning = `Expected ${expectedAgent} but no agent was invoked and no delegation intent detected. The main agent may have handled the task directly.`;\n    } else {\n      score = 0;\n      passed = false;\n      reasoning = `Expected ${expectedAgent} but got: ${agentsInvoked.join(', ')}`;\n    }\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: {\n        agentsInvoked,\n        expectedAgent,\n        invokedForbidden,\n        taskCallCount: taskCalls.length,\n        jsonlAgentsFound: jsonlAgents,\n        delegationIntentDetected: hasDelegationIntent.toExpected,\n        performedRightWork: hasDelegationIntent.performedRightWork,\n      },\n    });\n  }\n\n  private async extractAgentsFromJsonl(workspacePath: string): Promise<string[]> {\n    const agents: string[] = [];\n\n    try {\n      const claudeDir = path.join(workspacePath, '.claude', 'projects');\n\n      try {\n        await fs.access(claudeDir);\n      } catch {\n        return agents;\n      }\n\n      const projectDirs = await fs.readdir(claudeDir);\n\n      for (const projectDir of projectDirs) {\n        const projectPath = path.join(claudeDir, projectDir);\n        const stat = await fs.stat(projectPath);\n\n        if (!stat.isDirectory()) continue;\n\n        const files = await fs.readdir(projectPath);\n        const jsonlFiles = files.filter(f => f.endsWith('.jsonl'));\n\n        for (const jsonlFile of jsonlFiles) {\n          const filePath = path.join(projectPath, jsonlFile);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const lines = content.split('\\n').filter(line => line.trim());\n\n          for (const line of lines) {\n            try {\n              const entry = JSON.parse(line);\n              const message = entry.message;\n\n              if (!message?.content || !Array.isArray(message.content)) continue;\n\n              for (const block of message.content) {\n                if (block.type === 'tool_use' && block.name === 'Task') {\n                  const input = block.input as Record<string, unknown> | undefined;\n                  const agentType = (input?.subagent_type as string) || (input?.agent as string);\n                  if (agentType && !agents.includes(agentType)) {\n                    agents.push(agentType);\n                  }\n                }\n              }\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n        }\n      }\n    } catch {\n      // Ignore errors reading JSONL\n    }\n\n    return agents;\n  }\n\n  private checkDelegationIntent(\n    outputLower: string,\n    expectedAgent: string,\n    forbiddenAgents: string[]\n  ): { toExpected: boolean; toForbidden: boolean; performedRightWork: boolean } {\n    const delegationKeywords = [\n      'delegate',\n      'task tool',\n      'subagent',\n      'agent',\n      'specialized',\n      'use the',\n      'invoke',\n      'call the',\n    ];\n\n    const expectedAgentLower = expectedAgent.toLowerCase();\n    const mentionsExpected = outputLower.includes(expectedAgentLower);\n    const hasDelegationContext = delegationKeywords.some((kw) => outputLower.includes(kw));\n\n    const toExpected = mentionsExpected && hasDelegationContext;\n\n    const toForbidden = forbiddenAgents.some((agent) => {\n      const agentLower = agent.toLowerCase();\n      return outputLower.includes(agentLower) && hasDelegationContext;\n    });\n\n    const performedRightWork = this.checkWorkType(outputLower, expectedAgent);\n\n    return { toExpected, toForbidden, performedRightWork };\n  }\n\n  private checkWorkType(outputLower: string, expectedAgent: string): boolean {\n    const keywords = this.workTypeKeywords[expectedAgent] || [];\n    if (keywords.length === 0) return false;\n\n    const matchCount = keywords.filter((kw) => outputLower.includes(kw)).length;\n    return matchCount >= 2;\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isToolEval } from '../../config/schemas.js';\n\ninterface SkillCheckResult {\n  skillName: string;\n  found: boolean;\n  callCount: number;\n  meetsMin: boolean;\n}\n\nexport class SkillInvocationJudge extends BaseJudge {\n  id = 'skill-invocation';\n  name = 'Skill Invocation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, executionResult, workingDirectory } = context;\n\n    if (!isToolEval(evalCase)) {\n      return this.notApplicable('Only applicable for tool evals');\n    }\n\n    const expectedSkills = evalCase.expectedSkills || [];\n    if (expectedSkills.length === 0) {\n      return this.notApplicable('No expected skills specified');\n    }\n\n    const jsonlSkillCalls = await this.extractSkillCallsFromJsonl(workingDirectory);\n    const mainAgentSkillCalls = this.extractSkillCallsFromToolCalls(executionResult.toolCalls || []);\n    const skillCalls = [...jsonlSkillCalls, ...mainAgentSkillCalls];\n\n    const results: SkillCheckResult[] = [];\n\n    for (const expected of expectedSkills) {\n      const matchCount = skillCalls.filter(\n        (call) => call.skillName === expected.skillName\n      ).length;\n\n      const meetsMin = matchCount >= (expected.minCalls ?? 1);\n\n      results.push({\n        skillName: expected.skillName,\n        found: matchCount > 0,\n        callCount: matchCount,\n        meetsMin,\n      });\n    }\n\n    const passedCount = results.filter((r) => r.found && r.meetsMin).length;\n    const score = (passedCount / expectedSkills.length) * 100;\n    const passed = score >= 80;\n\n    const failedChecks = results.filter((r) => !r.found || !r.meetsMin);\n    const allSkillNames = Array.from(new Set(skillCalls.map((c) => c.skillName)));\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        failedChecks.length > 0\n          ? `${passedCount}/${expectedSkills.length} expected skills invoked. Failed: ${failedChecks.map((f) => `${f.skillName} (found ${f.callCount}x)`).join(', ')}`\n          : `All ${expectedSkills.length} expected skills were invoked`,\n      details: {\n        results,\n        actualSkillNames: allSkillNames,\n        totalSkillCalls: skillCalls.length,\n      },\n    });\n  }\n\n  private extractSkillCallsFromToolCalls(toolCalls: Array<{ toolName: string; input: unknown }>): Array<{ skillName: string; input: unknown }> {\n    const skillCalls: Array<{ skillName: string; input: unknown }> = [];\n\n    for (const call of toolCalls) {\n      if (call.toolName === 'Skill') {\n        const input = call.input as Record<string, unknown> | undefined;\n        const skillName = input?.skill as string || input?.command as string;\n        if (skillName) {\n          skillCalls.push({\n            skillName: skillName.replace(/^\\//, ''),\n            input: input || {},\n          });\n        }\n      }\n    }\n\n    return skillCalls;\n  }\n\n  private async extractSkillCallsFromJsonl(workspacePath: string): Promise<Array<{ skillName: string; input: unknown }>> {\n    const skillCalls: Array<{ skillName: string; input: unknown }> = [];\n\n    try {\n      const claudeDir = path.join(workspacePath, '.claude', 'projects');\n\n      try {\n        await fs.access(claudeDir);\n      } catch {\n        return skillCalls;\n      }\n\n      const projectDirs = await fs.readdir(claudeDir);\n\n      for (const projectDir of projectDirs) {\n        const projectPath = path.join(claudeDir, projectDir);\n        const stat = await fs.stat(projectPath);\n\n        if (!stat.isDirectory()) continue;\n\n        const files = await fs.readdir(projectPath);\n        const jsonlFiles = files.filter(f => f.endsWith('.jsonl'));\n\n        for (const jsonlFile of jsonlFiles) {\n          const filePath = path.join(projectPath, jsonlFile);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const lines = content.split('\\n').filter(line => line.trim());\n\n          for (const line of lines) {\n            try {\n              const entry = JSON.parse(line);\n              const message = entry.message;\n\n              if (!message?.content || !Array.isArray(message.content)) continue;\n\n              for (const block of message.content) {\n                if (block.type === 'tool_use' && block.name === 'Skill') {\n                  const input = block.input as Record<string, unknown> | undefined;\n                  const skillName = input?.skill as string || input?.command as string;\n                  if (skillName) {\n                    skillCalls.push({\n                      skillName: skillName.replace(/^\\//, ''),\n                      input: input || {},\n                    });\n                  }\n                }\n              }\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n        }\n      }\n    } catch {\n      // Ignore errors\n    }\n\n    return skillCalls;\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface SyntaxCheckResult {\n  file: string;\n  valid: boolean;\n  error?: string;\n}\n\nexport class SyntaxValidationJudge extends BaseJudge {\n  id = 'syntax-validation';\n  name = 'Syntax Validation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    if (!evalCase.syntaxValidation) {\n      return this.notApplicable('Syntax validation disabled for this eval');\n    }\n\n    const targetFiles = evalCase.targetFiles || [];\n    const codeFiles = targetFiles.filter(\n      (f) => f.endsWith('.ts') || f.endsWith('.tsx') || f.endsWith('.js') || f.endsWith('.jsx')\n    );\n\n    if (codeFiles.length === 0) {\n      return this.notApplicable('No code files to validate');\n    }\n\n    const results: SyntaxCheckResult[] = [];\n\n    for (const file of codeFiles) {\n      const fullPath = path.join(workingDirectory || executionResult.workingDirectory || '', file);\n      try {\n        const content = await fs.readFile(fullPath, 'utf-8');\n        const isValid = await this.validateSyntax(content, file);\n        results.push({ file, valid: isValid.valid, error: isValid.error });\n      } catch (error) {\n        results.push({\n          file,\n          valid: false,\n          error: error instanceof Error ? error.message : 'File not found',\n        });\n      }\n    }\n\n    const validCount = results.filter((r) => r.valid).length;\n    const score = (validCount / codeFiles.length) * 100;\n    const passed = score >= 90;\n\n    const invalidFiles = results.filter((r) => !r.valid);\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        invalidFiles.length > 0\n          ? `${validCount}/${codeFiles.length} files have valid syntax. Invalid: ${invalidFiles.map((f) => `${f.file} (${f.error})`).join(', ')}`\n          : `All ${codeFiles.length} files have valid syntax`,\n      details: { results },\n    });\n  }\n\n  private async validateSyntax(\n    content: string,\n    filename: string\n  ): Promise<{ valid: boolean; error?: string }> {\n    try {\n      const { parse } = await import('@babel/parser');\n\n      const isTypeScript = filename.endsWith('.ts') || filename.endsWith('.tsx');\n      const isJSX = filename.endsWith('.tsx') || filename.endsWith('.jsx');\n\n      const plugins: string[] = [];\n      if (isTypeScript) plugins.push('typescript');\n      if (isJSX) plugins.push('jsx');\n\n      parse(content, {\n        sourceType: 'module',\n        plugins: plugins as any[],\n      });\n\n      return { valid: true };\n    } catch (error) {\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : 'Parse error',\n      };\n    }\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport Anthropic from '@anthropic-ai/sdk';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport type { ReferenceSolution } from '../../config/schemas.js';\n\nexport interface Rubric {\n  id: string;\n  content: string;\n}\n\nexport interface LLMJudgeOptions {\n  rubricsDir?: string;\n  model?: string;\n}\n\nconst DEFAULT_MODEL = 'claude-sonnet-4-20250514';\nconst DEFAULT_RUBRICS_DIR = './__evals__/rubrics';\n\nexport async function loadRubric(rubricPath: string, rubricsDir?: string): Promise<Rubric> {\n  const baseDir = rubricsDir || DEFAULT_RUBRICS_DIR;\n  const fullPath = path.isAbsolute(rubricPath)\n    ? rubricPath\n    : path.join(process.cwd(), baseDir, rubricPath);\n\n  const content = await fs.readFile(fullPath, 'utf-8');\n  const id = path.basename(rubricPath, path.extname(rubricPath));\n\n  return { id, content };\n}\n\nexport class LLMJudge extends BaseJudge {\n  id: string;\n  name: string;\n  type: JudgeType = 'llm';\n\n  private rubricPath: string;\n  private anthropic: Anthropic;\n  private rubricsDir: string;\n  private model: string;\n\n  constructor(id: string, rubricPath: string, options: LLMJudgeOptions = {}) {\n    super();\n    this.id = id;\n    this.name = `LLM Judge: ${id}`;\n    this.rubricPath = rubricPath;\n    this.rubricsDir = options.rubricsDir || DEFAULT_RUBRICS_DIR;\n    this.model = options.model || DEFAULT_MODEL;\n    this.anthropic = new Anthropic();\n  }\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, executionResult, workingDirectory } = context;\n\n    let rubric: Rubric;\n    try {\n      rubric = await loadRubric(this.rubricPath, this.rubricsDir);\n    } catch (error) {\n      return this.createResult({\n        passed: false,\n        score: 0,\n        reasoning: `Failed to load rubric: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        confidence: 0,\n      });\n    }\n\n    const generatedFiles = await this.readTargetFiles(evalCase, workingDirectory);\n\n    const referenceSolution = evalCase.referenceSolution as ReferenceSolution | undefined;\n    let referenceFiles: Map<string, string> | undefined;\n    if (referenceSolution) {\n      referenceFiles = await this.readReferenceFiles(referenceSolution, workingDirectory);\n    }\n\n    const prompt = referenceFiles && referenceFiles.size > 0\n      ? this.buildPairwisePrompt(evalCase, executionResult, rubric, generatedFiles, referenceFiles)\n      : this.buildPrompt(evalCase, executionResult, rubric, generatedFiles);\n\n    try {\n      const response = await this.anthropic.messages.create({\n        model: this.model,\n        max_tokens: 1024,\n        messages: [{ role: 'user', content: prompt }],\n      });\n\n      const content = response.content[0];\n      if (content.type !== 'text') {\n        throw new Error('Unexpected response type from LLM');\n      }\n\n      return this.parseResponse(content.text);\n    } catch (error) {\n      return this.createResult({\n        passed: false,\n        score: 0,\n        reasoning: `LLM evaluation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        confidence: 0,\n      });\n    }\n  }\n\n  private async readReferenceFiles(\n    referenceSolution: ReferenceSolution,\n    workingDirectory: string\n  ): Promise<Map<string, string>> {\n    const files = new Map<string, string>();\n\n    if (referenceSolution.code) {\n      files.set('reference_code', referenceSolution.code);\n    }\n\n    if (referenceSolution.files && referenceSolution.files.length > 0) {\n      for (const filePath of referenceSolution.files) {\n        const fullPath = path.isAbsolute(filePath)\n          ? filePath\n          : path.join(workingDirectory, filePath);\n        try {\n          const content = await fs.readFile(fullPath, 'utf-8');\n          files.set(filePath, content);\n        } catch {\n          files.set(filePath, '[REFERENCE FILE NOT FOUND]');\n        }\n      }\n    }\n\n    return files;\n  }\n\n  private buildPairwisePrompt(\n    evalCase: any,\n    result: any,\n    rubric: Rubric,\n    generatedFiles: Map<string, string>,\n    referenceFiles: Map<string, string>\n  ): string {\n    const toolCallSummary = this.formatToolCalls(result.toolCalls);\n\n    let generatedFilesSection = '';\n    if (generatedFiles && generatedFiles.size > 0) {\n      const fileContents = Array.from(generatedFiles.entries())\n        .map(([filePath, content]) => `### ${filePath}\\n\\`\\`\\`\\n${content}\\n\\`\\`\\``)\n        .join('\\n\\n');\n      generatedFilesSection = `\\n## Generated Output (Candidate)\\n${fileContents}\\n`;\n    }\n\n    let referenceFilesSection = '';\n    if (referenceFiles && referenceFiles.size > 0) {\n      const fileContents = Array.from(referenceFiles.entries())\n        .map(([filePath, content]) => `### ${filePath}\\n\\`\\`\\`\\n${content}\\n\\`\\`\\``)\n        .join('\\n\\n');\n      referenceFilesSection = `\\n## Reference Solution (Gold Standard)\\n${fileContents}\\n`;\n    }\n\n    return `You are an AI evaluation judge performing PAIRWISE COMPARISON. Compare the candidate output against the reference solution.\n\n## Evaluation Case\nID: ${evalCase.id}\nName: ${evalCase.name}\nDescription: ${evalCase.description}\nCategory: ${evalCase.category}\nOriginal Prompt: ${evalCase.prompt || 'N/A'}\nExpected Behavior: ${evalCase.expectedBehavior || 'N/A'}\n\n## Rubric\n${rubric.content}\n${referenceFilesSection}\n${generatedFilesSection}\n## Execution Result\nSuccess: ${result.success}\nAI Response: ${result.output || 'N/A'}\nDuration: ${result.duration}ms\nTool Calls: ${toolCallSummary}\nError: ${result.error?.message || 'None'}\n\n## Pairwise Comparison Instructions\n1. Compare the candidate output against the reference solution\n2. Evaluate how closely the candidate matches the reference in terms of:\n   - Functional correctness\n   - Code quality and style\n   - Completeness of implementation\n3. Award scores based on how well the candidate achieves the same goals as the reference\n4. A candidate that fully matches or exceeds the reference should score 90-100\n5. Output your evaluation in the following JSON format:\n\n\\`\\`\\`json\n{\n  \"score\": <number 0-100>,\n  \"passed\": <boolean - true if score >= 70>,\n  \"confidence\": <number 0-1 indicating how confident you are in this evaluation>,\n  \"reasoning\": \"<your detailed reasoning comparing candidate to reference, 2-4 sentences>\"\n}\n\\`\\`\\`\n\nOutput only the JSON block, no other text.`;\n  }\n\n  private async readTargetFiles(\n    evalCase: any,\n    workingDirectory: string\n  ): Promise<Map<string, string>> {\n    const files = new Map<string, string>();\n\n    const targetFiles = evalCase.targetFiles as string[] | undefined;\n    if (!targetFiles || targetFiles.length === 0) {\n      return files;\n    }\n\n    for (const filePath of targetFiles) {\n      const fullPath = path.join(workingDirectory, filePath);\n      try {\n        const content = await fs.readFile(fullPath, 'utf-8');\n        files.set(filePath, content);\n      } catch {\n        files.set(filePath, '[FILE NOT FOUND]');\n      }\n    }\n\n    return files;\n  }\n\n  private buildPrompt(\n    evalCase: any,\n    result: any,\n    rubric: Rubric,\n    generatedFiles?: Map<string, string>\n  ): string {\n    const toolCallSummary = this.formatToolCalls(result.toolCalls);\n\n    let generatedFilesSection = '';\n    if (generatedFiles && generatedFiles.size > 0) {\n      const fileContents = Array.from(generatedFiles.entries())\n        .map(([filePath, content]) => `### ${filePath}\\n\\`\\`\\`\\n${content}\\n\\`\\`\\``)\n        .join('\\n\\n');\n      generatedFilesSection = `\\n## Generated Files\\n${fileContents}\\n`;\n    }\n\n    return `You are an AI evaluation judge. Evaluate the following AI execution result against the rubric.\n\n## Evaluation Case\nID: ${evalCase.id}\nName: ${evalCase.name}\nDescription: ${evalCase.description}\nCategory: ${evalCase.category}\nOriginal Prompt: ${evalCase.prompt || 'N/A'}\nExpected Behavior: ${evalCase.expectedBehavior || 'N/A'}\n\n## Rubric\n${rubric.content}\n\n## Execution Result\nSuccess: ${result.success}\nAI Response: ${result.output || 'N/A'}\nDuration: ${result.duration}ms\nTool Calls: ${toolCallSummary}\nError: ${result.error?.message || 'None'}\n${generatedFilesSection}\n## Instructions\n1. Carefully evaluate the result against each criterion in the rubric\n2. Consider both what the AI did correctly and what it failed to do\n3. For code-gen evals, focus on the Generated Files section to evaluate the actual code quality\n4. Provide a score from 0-100 based on the rubric criteria\n5. Be specific in your reasoning - cite specific behaviors observed\n6. Output your evaluation in the following JSON format:\n\n\\`\\`\\`json\n{\n  \"score\": <number 0-100>,\n  \"passed\": <boolean - true if score >= 70>,\n  \"confidence\": <number 0-1 indicating how confident you are in this evaluation>,\n  \"reasoning\": \"<your detailed reasoning, 2-4 sentences>\"\n}\n\\`\\`\\`\n\nOutput only the JSON block, no other text.`;\n  }\n\n  private parseResponse(text: string): JudgeResult {\n    const parsed = parseLLMJudgeResponse(text);\n    return this.createResult(parsed);\n  }\n\n  private formatToolCalls(toolCalls: any[] | undefined): string {\n    return formatToolCallsSummary(toolCalls);\n  }\n}\n\nexport function createLLMCodeQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-code-quality', 'code-quality.md', options);\n}\n\nexport function createLLMRoutingQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-routing-quality', 'routing-quality.md', options);\n}\n\nexport function createLLMResponseQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-response-quality', 'response-quality.md', options);\n}\n\nexport function createLLMConversationQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-conversation-quality', 'conversation-quality.md', options);\n}\n\nexport interface ParsedLLMResponse {\n  passed: boolean;\n  score: number;\n  confidence: number;\n  reasoning: string;\n}\n\nexport function parseLLMJudgeResponse(text: string): ParsedLLMResponse {\n  const jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n  const jsonContent = jsonMatch ? jsonMatch[1] : text;\n\n  try {\n    const parsed = JSON.parse(jsonContent.trim());\n\n    return {\n      passed: parsed.passed ?? parsed.score >= 70,\n      score: Math.max(0, Math.min(100, parsed.score || 0)),\n      confidence: Math.max(0, Math.min(1, parsed.confidence || 0.5)),\n      reasoning: parsed.reasoning || 'No reasoning provided',\n    };\n  } catch {\n    return {\n      passed: false,\n      score: 0,\n      reasoning: `Failed to parse LLM response: ${text.substring(0, 200)}...`,\n      confidence: 0,\n    };\n  }\n}\n\nexport function formatToolCallsSummary(toolCalls: any[] | undefined): string {\n  if (!toolCalls || toolCalls.length === 0) {\n    return 'None';\n  }\n\n  if (toolCalls.length <= 10) {\n    return toolCalls.map((t: any) => t.toolName).join(', ');\n  }\n\n  const toolCounts = new Map<string, number>();\n  for (const call of toolCalls) {\n    const name = call.toolName || 'unknown';\n    toolCounts.set(name, (toolCounts.get(name) || 0) + 1);\n  }\n\n  return Array.from(toolCounts.entries())\n    .map(([name, count]) => count > 1 ? `${name} (x${count})` : name)\n    .join(', ');\n}\n","import type { Judge, JudgeType } from './judge-interface.js';\nimport { FileExistenceJudge } from './builtin/file-existence.js';\nimport { ToolInvocationJudge } from './builtin/tool-invocation.js';\nimport { PatternMatchJudge } from './builtin/pattern-match.js';\nimport { AgentRoutingJudge } from './builtin/agent-routing.js';\nimport { SkillInvocationJudge } from './builtin/skill-invocation.js';\nimport { SyntaxValidationJudge } from './builtin/syntax-validation.js';\nimport {\n  createLLMCodeQualityJudge,\n  createLLMRoutingQualityJudge,\n  createLLMResponseQualityJudge,\n  createLLMConversationQualityJudge,\n} from './builtin/llm-judge.js';\n\nexport class JudgeRegistry {\n  private judges: Map<string, Judge> = new Map();\n\n  constructor() {\n    this.registerBuiltInJudges();\n  }\n\n  private registerBuiltInJudges(): void {\n    this.register(new FileExistenceJudge());\n    this.register(new ToolInvocationJudge());\n    this.register(new PatternMatchJudge());\n    this.register(new AgentRoutingJudge());\n    this.register(new SkillInvocationJudge());\n    this.register(new SyntaxValidationJudge());\n    this.register(createLLMCodeQualityJudge());\n    this.register(createLLMRoutingQualityJudge());\n    this.register(createLLMResponseQualityJudge());\n    this.register(createLLMConversationQualityJudge());\n  }\n\n  register(judge: Judge): void {\n    this.judges.set(judge.id, judge);\n  }\n\n  /** @internal Used for testing only */\n  unregister(id: string): boolean {\n    return this.judges.delete(id);\n  }\n\n  get(id: string): Judge | undefined {\n    return this.judges.get(id);\n  }\n\n  has(id: string): boolean {\n    return this.judges.has(id);\n  }\n\n  list(): string[] {\n    return Array.from(this.judges.keys());\n  }\n\n  /** @internal Used for testing only */\n  listByType(type: JudgeType): string[] {\n    return Array.from(this.judges.entries())\n      .filter(([_, judge]) => judge.type === type)\n      .map(([id]) => id);\n  }\n\n  /** @internal Used for testing only */\n  getAll(): Judge[] {\n    return Array.from(this.judges.values());\n  }\n}\n\nlet defaultRegistry: JudgeRegistry | null = null;\n\nexport function getJudgeRegistry(): JudgeRegistry {\n  if (!defaultRegistry) {\n    defaultRegistry = new JudgeRegistry();\n  }\n  return defaultRegistry;\n}\n\n/** @internal Used for testing only */\nexport function resetJudgeRegistry(): void {\n  defaultRegistry = null;\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { glob } from 'glob';\nimport { EvalCase, parseEvalCase, EvalCategory } from '../config/schemas.js';\n\nexport interface EvalLoadOptions {\n  testDir: string;\n  testMatch: string[];\n  categories?: EvalCategory[];\n  tags?: string[];\n  ids?: string[];\n  enabledOnly?: boolean;\n}\n\n/** @deprecated Use EvalLoadOptions instead */\nexport type LoadOptions = EvalLoadOptions;\n\nexport async function loadEvalCases(options: EvalLoadOptions): Promise<EvalCase[]> {\n  const { testDir, testMatch } = options;\n\n  const patterns = testMatch.map(pattern => path.join(testDir, pattern));\n  const files = await glob(patterns, { absolute: true });\n\n  const evalCases: EvalCase[] = [];\n\n  for (const file of files) {\n    try {\n      const content = await fs.readFile(file, 'utf-8');\n      const data = JSON.parse(content);\n      const evalCase = parseEvalCase(data);\n      evalCases.push(evalCase);\n    } catch (error) {\n      console.warn(`Failed to load eval case from ${file}:`, error);\n    }\n  }\n\n  return filterEvalCases(evalCases, options);\n}\n\nexport async function loadEvalCase(id: string, options: EvalLoadOptions): Promise<EvalCase | null> {\n  const cases = await loadEvalCases({ ...options, ids: [id] });\n  return cases[0] || null;\n}\n\nfunction filterEvalCases(cases: EvalCase[], options: EvalLoadOptions): EvalCase[] {\n  let filtered = cases;\n\n  if (options.enabledOnly !== false) {\n    filtered = filtered.filter((c) => c.enabled !== false);\n  }\n\n  if (options.categories && options.categories.length > 0) {\n    filtered = filtered.filter((c) => options.categories!.includes(c.category));\n  }\n\n  if (options.tags && options.tags.length > 0) {\n    filtered = filtered.filter((c) => c.tags?.some((t) => options.tags!.includes(t)));\n  }\n\n  if (options.ids && options.ids.length > 0) {\n    filtered = filtered.filter((c) => options.ids!.includes(c.id));\n  }\n\n  return filtered;\n}\n\nexport function groupByCategory(cases: EvalCase[]): Record<EvalCategory, EvalCase[]> {\n  const grouped: Record<EvalCategory, EvalCase[]> = {\n    tool: [],\n    'code-gen': [],\n    'multi-turn': [],\n    routing: [],\n    basic: [],\n  };\n\n  for (const evalCase of cases) {\n    grouped[evalCase.category].push(evalCase);\n  }\n\n  return grouped;\n}\n","import type { EvalCase, EvalCaseResult, EvalCategory, JudgeResult, ErrorType } from '../config/schemas.js';\nimport type { ResolvedConfig } from '../config/types.js';\nimport { isMultiTurnEval } from '../config/schemas.js';\nimport { TestHarness } from '../harness/test-harness.js';\nimport { getJudgeRegistry } from '../judges/judge-registry.js';\nimport type { JudgeContext, ExecutionResult } from '../judges/judge-interface.js';\nimport { loadEvalCases } from '../utils/eval-loader.js';\n\nexport interface EvalRunnerOptions {\n  categories?: EvalCategory[];\n  tags?: string[];\n  ids?: string[];\n}\n\n/** @deprecated Use EvalRunnerOptions instead */\nexport type RunnerOptions = EvalRunnerOptions;\n\nexport interface EvalSuiteResult {\n  runId: string;\n  total: number;\n  passed: number;\n  failed: number;\n  skipped: number;\n  errors: number;\n  passRate: number;\n  results: EvalCaseResult[];\n  duration: number;\n  timestamp: string;\n}\n\nexport class EvalRunner {\n  private config: ResolvedConfig;\n  private harness: TestHarness;\n\n  constructor(config: ResolvedConfig) {\n    this.config = config;\n    this.harness = new TestHarness({ config });\n\n    // Register custom judges from config with the global registry\n    if (config.judges && config.judges.length > 0) {\n      const registry = getJudgeRegistry();\n      for (const judge of config.judges) {\n        registry.register(judge);\n      }\n    }\n  }\n\n  private verbose(message: string): void {\n    if (this.config.verbose) {\n      console.log(message);\n    }\n  }\n\n  async run(options: EvalRunnerOptions = {}): Promise<EvalSuiteResult> {\n    const startTime = Date.now();\n    const runId = `run-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n\n    this.verbose(`Starting eval run: ${runId}`);\n\n    if (this.config.setup) {\n      this.verbose(`Running setup hook...`);\n      await this.config.setup();\n      this.verbose(`Setup complete`);\n    }\n\n    this.verbose(`Loading eval cases from: ${this.config.testDir}`);\n    const evalCases = await loadEvalCases({\n      testDir: this.config.testDir,\n      testMatch: this.config.testMatch,\n      categories: options.categories,\n      tags: options.tags,\n      ids: options.ids,\n      enabledOnly: true,\n    });\n\n    const mode = this.config.parallel ? `parallel (${this.config.maxConcurrency} concurrent)` : 'sequential';\n    console.log(`Running ${evalCases.length} evals (${mode})...`);\n    console.log();\n\n    const results: EvalCaseResult[] = [];\n\n    if (this.config.parallel && evalCases.length > 1) {\n      results.push(...await this.runParallel(evalCases));\n    } else {\n      results.push(...await this.runSequential(evalCases));\n    }\n\n    if (this.config.teardown) {\n      this.verbose(`Running teardown hook...`);\n      await this.config.teardown();\n    }\n\n    await this.harness.cleanup();\n\n    const passed = results.filter(r => r.success).length;\n    const failed = results.filter(r => !r.success && !r.error).length;\n    const errors = results.filter(r => r.error).length;\n    const duration = Date.now() - startTime;\n\n    console.log();\n    console.log(`Completed: ${passed}/${results.length} passed (${Math.round(passed / results.length * 100)}%) in ${(duration / 1000).toFixed(1)}s`);\n\n    return {\n      runId,\n      total: results.length,\n      passed,\n      failed,\n      skipped: 0,\n      errors,\n      passRate: results.length > 0 ? passed / results.length : 0,\n      results,\n      duration,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  private async runParallel(evalCases: EvalCase[]): Promise<EvalCaseResult[]> {\n    // Pre-allocate results array to preserve original order\n    const results: EvalCaseResult[] = new Array(evalCases.length);\n    const { maxConcurrency } = this.config;\n    let nextIndex = 0;\n    let completed = 0;\n    let running = 0;\n\n    return new Promise((resolve) => {\n      const runNext = async (): Promise<void> => {\n        while (nextIndex < evalCases.length) {\n          const currentIndex = nextIndex++;\n          const evalCase = evalCases[currentIndex];\n          running++;\n\n          console.log(`[${evalCase.id}] Starting (${currentIndex + 1}/${evalCases.length})`);\n\n          try {\n            const result = await this.runSingle(evalCase);\n            results[currentIndex] = result; // Preserve order\n          } catch (error) {\n            // Catch unexpected errors to prevent crashing the pool\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            results[currentIndex] = {\n              evalCase,\n              success: false,\n              output: '',\n              duration: 0,\n              judgeResults: [],\n              error: error instanceof Error ? error : new Error(errorMessage),\n              errorType: this.classifyError(error),\n            };\n          } finally {\n            running--;\n            completed++;\n          }\n        }\n      };\n\n      // Start maxConcurrency workers\n      const workers = Array(Math.min(maxConcurrency, evalCases.length))\n        .fill(null)\n        .map(() => runNext());\n\n      Promise.all(workers).then(() => resolve(results));\n    });\n  }\n\n  private async runSequential(evalCases: EvalCase[]): Promise<EvalCaseResult[]> {\n    const results: EvalCaseResult[] = [];\n\n    for (let i = 0; i < evalCases.length; i++) {\n      const evalCase = evalCases[i];\n      console.log(`[${evalCase.id}] Starting (${i + 1}/${evalCases.length})`);\n      const result = await this.runSingle(evalCase);\n      results.push(result);\n    }\n\n    return results;\n  }\n\n  private async runSingle(evalCase: EvalCase): Promise<EvalCaseResult> {\n    const startTime = Date.now();\n\n    if (this.config.beforeEach) {\n      await this.config.beforeEach(evalCase);\n    }\n\n    let result: EvalCaseResult;\n\n    try {\n      const trialConfig = evalCase.trials || { count: this.config.trials, passThreshold: this.config.trialPassThreshold };\n      const trialCount = trialConfig.count ?? 1;\n\n      if (trialCount > 1) {\n        result = await this.runWithTrials(evalCase, trialCount, trialConfig.passThreshold ?? 0.5);\n      } else {\n        result = await this.runWithRetries(evalCase);\n      }\n    } catch (error) {\n      result = {\n        evalCase,\n        success: false,\n        output: '',\n        duration: Date.now() - startTime,\n        judgeResults: [],\n        error: error instanceof Error ? error : new Error(String(error)),\n        errorType: this.classifyError(error),\n      };\n    }\n\n    if (this.config.afterEach) {\n      await this.config.afterEach(result);\n    }\n\n    const status = result.success ? '' : '';\n    const trialInfo = result.trialResults ? ` [${result.trialResults.filter(t => t).length}/${result.trialResults.length} trials]` : '';\n    const retryInfo = result.retryCount ? ` (${result.retryCount} retries)` : '';\n    console.log(`[${evalCase.id}] ${status} ${(result.duration / 1000).toFixed(1)}s${trialInfo}${retryInfo}`);\n\n    return result;\n  }\n\n  private async runWithTrials(evalCase: EvalCase, trialCount: number, passThreshold: number): Promise<EvalCaseResult> {\n    const trialResults: boolean[] = [];\n    let lastResult: EvalCaseResult | undefined;\n    let totalDuration = 0;\n\n    for (let trial = 0; trial < trialCount; trial++) {\n      this.verbose(`[${evalCase.id}] Trial ${trial + 1}/${trialCount}...`);\n\n      try {\n        const result = await this.runWithRetries(evalCase);\n        trialResults.push(result.success);\n        totalDuration += result.duration;\n        lastResult = result;\n\n        this.verbose(`[${evalCase.id}] Trial ${trial + 1} ${result.success ? 'passed' : 'failed'}`);\n      } catch (error) {\n        trialResults.push(false);\n        lastResult = {\n          evalCase,\n          success: false,\n          output: '',\n          duration: 0,\n          judgeResults: [],\n          error: error instanceof Error ? error : new Error(String(error)),\n          errorType: this.classifyError(error),\n        };\n        this.verbose(`[${evalCase.id}] Trial ${trial + 1} errored: ${(error as Error).message}`);\n      }\n    }\n\n    const passCount = trialResults.filter(t => t).length;\n    const passRate = passCount / trialCount;\n    const overallSuccess = passRate >= passThreshold;\n\n    this.verbose(`[${evalCase.id}] Trials complete: ${passCount}/${trialCount} passed (${(passRate * 100).toFixed(0)}%)`);\n\n    return {\n      ...lastResult!,\n      success: overallSuccess,\n      trialResults,\n      duration: totalDuration,\n    };\n  }\n\n  private async runWithRetries(evalCase: EvalCase): Promise<EvalCaseResult> {\n    let lastError: Error | undefined;\n    let lastErrorType: ErrorType | undefined;\n    let retryCount = 0;\n    const retryErrors: string[] = [];\n\n    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {\n      const isRetry = attempt > 0;\n\n      try {\n        const result = await this.executeAndJudge(evalCase);\n\n        if (result.success) {\n          // Test passed - check if it was flaky (passed on retry)\n          return {\n            ...result,\n            retryCount,\n            flaky: isRetry,\n            retryErrors: isRetry ? retryErrors : undefined,\n          };\n        }\n\n        if (attempt === this.config.maxRetries) {\n          return { ...result, retryCount, retryErrors: retryErrors.length > 0 ? retryErrors : undefined };\n        }\n\n        // Record failure reason\n        const failReason = result.errorType || 'judge failure';\n        retryErrors.push(`Attempt ${attempt + 1}: ${failReason}`);\n\n        retryCount++;\n        const delay = this.getRetryDelay(attempt, result.errorType);\n        this.verbose(`[${evalCase.id}] Attempt ${attempt + 1} failed (${failReason}), retrying in ${delay}ms... (${retryCount}/${this.config.maxRetries})`);\n        await this.sleep(delay);\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        lastErrorType = this.classifyError(error);\n\n        // Record error reason\n        retryErrors.push(`Attempt ${attempt + 1}: ${lastErrorType} - ${lastError.message.substring(0, 100)}`);\n        retryCount++;\n\n        if (attempt < this.config.maxRetries) {\n          const delay = this.getRetryDelay(attempt, lastErrorType);\n          this.verbose(`[${evalCase.id}] Attempt ${attempt + 1} errored (${lastErrorType}): ${lastError.message}, retrying in ${delay}ms...`);\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    return {\n      evalCase,\n      success: false,\n      output: '',\n      duration: 0,\n      judgeResults: [],\n      error: lastError,\n      errorType: lastErrorType,\n      retryCount,\n      flaky: false,\n      retryErrors: retryErrors.length > 0 ? retryErrors : undefined,\n    };\n  }\n\n  private getRetryDelay(attempt: number, errorType?: ErrorType): number {\n    const baseDelay = this.config.retryDelayMs;\n    const multiplier = this.config.retryBackoffMultiplier;\n\n    let delay = baseDelay * Math.pow(multiplier, attempt);\n\n    // Use longer delays for API overload to allow recovery\n    if (errorType === 'api') {\n      delay *= 3;\n    } else if (errorType === 'timeout') {\n      delay *= 1.5;\n    }\n\n    return delay;\n  }\n\n  private classifyError(error: unknown, output?: string): ErrorType {\n    if (!error) return 'unknown';\n\n    const errorMessage = error instanceof Error ? error.message.toLowerCase() : String(error).toLowerCase();\n    // Check both error message and output for API errors\n    const combinedText = output ? `${errorMessage} ${output.toLowerCase()}` : errorMessage;\n\n    if (errorMessage.includes('timeout') || errorMessage.includes('timed out')) {\n      return 'timeout';\n    }\n\n    // Check for API errors including Anthropic overload (529) and Cloudflare errors\n    if (combinedText.includes('api') || combinedText.includes('rate limit') ||\n        combinedText.includes('429') || combinedText.includes('529') ||\n        combinedText.includes('500') || combinedText.includes('502') || combinedText.includes('503') ||\n        combinedText.includes('overloaded') || combinedText.includes('api error')) {\n      return 'api';\n    }\n\n    if (errorMessage.includes('judge')) {\n      return 'judge';\n    }\n\n    return 'unknown';\n  }\n\n  private async executeAndJudge(evalCase: EvalCase): Promise<EvalCaseResult> {\n    let executionResult: ExecutionResult;\n    let turnResults: ExecutionResult[] | undefined;\n    let judgeResults: JudgeResult[];\n\n    if (isMultiTurnEval(evalCase)) {\n      turnResults = await this.harness.executeMultiTurn(evalCase);\n      executionResult = turnResults[turnResults.length - 1];\n      // Use multi-turn judging which supports per-turn judges\n      judgeResults = await this.runJudgesForMultiTurn(evalCase, turnResults);\n    } else {\n      executionResult = await this.harness.execute(evalCase);\n      judgeResults = await this.runJudgesParallel(evalCase, executionResult);\n    }\n\n    const allPassed = judgeResults.every(r => r.passed);\n\n    if (this.config.verbose && judgeResults.length > 0) {\n      for (const result of judgeResults) {\n        const status = result.passed ? '' : '';\n        this.verbose(`[${evalCase.id}] Judge ${result.judgeId}: ${status} (score: ${result.score})`);\n        if (!result.passed && result.reasoning) {\n          this.verbose(`[${evalCase.id}]    ${result.reasoning}`);\n        }\n      }\n    }\n\n    // Cleanup workspace after judging completes\n    if (executionResult.workspaceId) {\n      await this.harness.cleanupWorkspace(executionResult.workspaceId);\n    }\n\n    return {\n      evalCase,\n      success: executionResult.success && allPassed,\n      output: executionResult.output,\n      duration: executionResult.duration,\n      judgeResults,\n      toolCalls: executionResult.toolCalls,\n      error: executionResult.error,\n      errorType: executionResult.error ? this.classifyError(executionResult.error, executionResult.output) : undefined,\n    };\n  }\n\n  private async runJudgesParallel(evalCase: EvalCase, executionResult: ExecutionResult, maxRetries: number = 2): Promise<JudgeResult[]> {\n    const judgeIds = this.getJudgeIds(evalCase);\n    const registry = getJudgeRegistry();\n\n    // Run all judges in parallel\n    const judgePromises = judgeIds.map(async (judgeId) => {\n      const judge = registry.get(judgeId);\n\n      if (!judge) {\n        this.verbose(`[${evalCase.id}] Warning: Judge not found: ${judgeId}`);\n        return null;\n      }\n\n      return this.evaluateJudgeWithRetry(\n        judge,\n        {\n          evalCase,\n          executionResult,\n          workingDirectory: executionResult.workingDirectory || '',\n        },\n        maxRetries,\n        judgeId\n      );\n    });\n\n    const results = await Promise.all(judgePromises);\n    return results.filter((r): r is JudgeResult => r !== null);\n  }\n\n  private async runJudgesForMultiTurn(evalCase: EvalCase & { category: 'multi-turn' }, turnResults: ExecutionResult[], maxRetries: number = 2): Promise<JudgeResult[]> {\n    const registry = getJudgeRegistry();\n    const allJudgePromises: Promise<JudgeResult | null>[] = [];\n\n    // Turn-level judges (all in parallel)\n    for (let i = 0; i < evalCase.turns.length; i++) {\n      const turn = evalCase.turns[i];\n      const turnResult = turnResults[i];\n      const turnJudgeIds = turn.judges || [];\n\n      for (const judgeId of turnJudgeIds) {\n        const turnIndex = i;\n        allJudgePromises.push(\n          (async () => {\n            const judge = registry.get(judgeId);\n            if (!judge) {\n              this.verbose(`[${evalCase.id}] Warning: Judge not found: ${judgeId}`);\n              return null;\n            }\n\n            return this.evaluateJudgeWithRetry(\n              judge,\n              {\n                evalCase,\n                executionResult: turnResult,\n                workingDirectory: turnResult.workingDirectory || '',\n                turnIndex,\n              },\n              maxRetries,\n              `${judgeId}[turn-${turnIndex + 1}]`\n            );\n          })()\n        );\n      }\n    }\n\n    // Global judges (all in parallel)\n    const globalJudgeIds = evalCase.judges || [];\n    const lastResult = turnResults[turnResults.length - 1];\n\n    for (const judgeId of globalJudgeIds) {\n      allJudgePromises.push(\n        (async () => {\n          const judge = registry.get(judgeId);\n          if (!judge) {\n            this.verbose(`[${evalCase.id}] Warning: Judge not found: ${judgeId}`);\n            return null;\n          }\n\n          return this.evaluateJudgeWithRetry(\n            judge,\n            {\n              evalCase,\n              executionResult: lastResult,\n              workingDirectory: lastResult.workingDirectory || '',\n            },\n            maxRetries,\n            judgeId\n          );\n        })()\n      );\n    }\n\n    const results = await Promise.all(allJudgePromises);\n    return results.filter((r): r is JudgeResult => r !== null);\n  }\n\n  private async evaluateJudgeWithRetry(\n    judge: { id: string; evaluate: (context: JudgeContext) => Promise<JudgeResult> },\n    context: JudgeContext,\n    maxRetries: number,\n    judgeIdOverride?: string\n  ): Promise<JudgeResult> {\n    const judgeId = judgeIdOverride || judge.id;\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const result = await judge.evaluate(context);\n        // Log success on retry\n        if (attempt > 0) {\n          this.verbose(`[${context.evalCase.id}] Judge ${judgeId} succeeded on attempt ${attempt + 1}`);\n        }\n        // Apply override judgeId if provided\n        if (judgeIdOverride) {\n          return { ...result, judgeId: judgeIdOverride };\n        }\n        return result;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        if (attempt < maxRetries) {\n          const delay = 500 * (attempt + 1);\n          this.verbose(`[${context.evalCase.id}] Judge ${judgeId} failed (attempt ${attempt + 1}), retrying in ${delay}ms...`);\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    return {\n      judgeId,\n      passed: false,\n      score: 0,\n      confidence: 1,\n      reasoning: `Judge error after ${maxRetries + 1} attempts: ${lastError?.message || 'Unknown'}`,\n    };\n  }\n\n  private getJudgeIds(evalCase: EvalCase): string[] {\n    if ('judges' in evalCase && evalCase.judges) {\n      return evalCase.judges;\n    }\n    return [];\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n","import type { EvalCaseResult, EvalCategory, ErrorType } from '../config/schemas.js';\nimport type { EvalSuiteResult } from '../runner/eval-runner.js';\n\nexport interface EvalReportOptions {\n  verbose?: boolean;\n  showDetails?: boolean;\n  format?: 'text' | 'json';\n}\n\n/** @deprecated Use EvalReportOptions instead */\nexport type ReportOptions = EvalReportOptions;\n\nexport interface CategorySummary {\n  category: EvalCategory;\n  total: number;\n  passed: number;\n  failed: number;\n  errors: number;\n  passRate: number;\n}\n\nexport interface ErrorSummary {\n  type: ErrorType;\n  count: number;\n  examples: string[];\n}\n\nexport function formatDuration(ms: number): string {\n  if (ms < 1000) return `${ms}ms`;\n  if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;\n  return `${(ms / 60000).toFixed(1)}m`;\n}\n\nexport function formatPassRate(rate: number): string {\n  return `${(rate * 100).toFixed(1)}%`;\n}\n\nexport function getStatusSymbol(success: boolean): string {\n  return success ? '' : '';\n}\n\nexport function summarizeByCategory(results: EvalCaseResult[]): CategorySummary[] {\n  const categoryMap = new Map<EvalCategory, EvalCaseResult[]>();\n\n  for (const result of results) {\n    const category = result.evalCase.category;\n    if (!categoryMap.has(category)) {\n      categoryMap.set(category, []);\n    }\n    categoryMap.get(category)!.push(result);\n  }\n\n  return Array.from(categoryMap.entries()).map(([category, categoryResults]) => ({\n    category,\n    total: categoryResults.length,\n    passed: categoryResults.filter(r => r.success).length,\n    failed: categoryResults.filter(r => !r.success && !r.error).length,\n    errors: categoryResults.filter(r => r.error).length,\n    passRate: categoryResults.filter(r => r.success).length / categoryResults.length,\n  }));\n}\n\nexport function summarizeErrors(results: EvalCaseResult[]): ErrorSummary[] {\n  const errorMap = new Map<ErrorType, { count: number; examples: string[] }>();\n\n  for (const result of results) {\n    if (result.error && result.errorType) {\n      if (!errorMap.has(result.errorType)) {\n        errorMap.set(result.errorType, { count: 0, examples: [] });\n      }\n      const entry = errorMap.get(result.errorType)!;\n      entry.count++;\n      if (entry.examples.length < 3) {\n        entry.examples.push(`${result.evalCase.name}: ${result.error.message.substring(0, 100)}`);\n      }\n    }\n  }\n\n  return Array.from(errorMap.entries()).map(([type, data]) => ({\n    type,\n    count: data.count,\n    examples: data.examples,\n  }));\n}\n\nexport function printSummary(suiteResult: EvalSuiteResult, options: EvalReportOptions = {}): void {\n  const { verbose = false, showDetails = false } = options;\n\n  console.log('\\n' + '='.repeat(60));\n  console.log('EVAL RESULTS SUMMARY');\n  console.log('='.repeat(60));\n\n  console.log(`\\nRun ID: ${suiteResult.runId}`);\n  console.log(`Duration: ${formatDuration(suiteResult.duration)}`);\n  console.log(`Timestamp: ${suiteResult.timestamp}`);\n\n  console.log('\\n--- Overall ---');\n  console.log(`Total: ${suiteResult.total}`);\n  console.log(`Passed: ${suiteResult.passed} (${formatPassRate(suiteResult.passRate)})`);\n  console.log(`Failed: ${suiteResult.failed}`);\n  console.log(`Errors: ${suiteResult.errors}`);\n\n  const categorySummaries = summarizeByCategory(suiteResult.results);\n  if (categorySummaries.length > 1) {\n    console.log('\\n--- By Category ---');\n    for (const summary of categorySummaries) {\n      console.log(`  ${summary.category}: ${summary.passed}/${summary.total} (${formatPassRate(summary.passRate)})`);\n    }\n  }\n\n  const errorSummaries = summarizeErrors(suiteResult.results);\n  if (errorSummaries.length > 0) {\n    console.log('\\n--- Errors by Type ---');\n    for (const summary of errorSummaries) {\n      console.log(`  ${summary.type}: ${summary.count}`);\n      if (verbose) {\n        for (const example of summary.examples) {\n          console.log(`    - ${example}`);\n        }\n      }\n    }\n  }\n\n  if (showDetails) {\n    console.log('\\n--- Individual Results ---');\n    for (const result of suiteResult.results) {\n      const status = getStatusSymbol(result.success);\n      const trialInfo = result.trialResults\n        ? ` [${result.trialResults.filter(t => t).length}/${result.trialResults.length}]`\n        : '';\n      console.log(`${status} ${result.evalCase.name}${trialInfo} (${formatDuration(result.duration)})`);\n\n      if (verbose && result.judgeResults.length > 0) {\n        for (const judge of result.judgeResults) {\n          const judgeStatus = getStatusSymbol(judge.passed);\n          console.log(`    ${judgeStatus} ${judge.judgeId}: ${judge.score}/100 - ${judge.reasoning.substring(0, 80)}`);\n        }\n      }\n\n      if (result.error) {\n        console.log(`    Error: ${result.error.message.substring(0, 100)}`);\n      }\n    }\n  }\n\n  console.log('\\n' + '='.repeat(60));\n}\n\nexport function generateJsonReport(suiteResult: EvalSuiteResult): object {\n  return {\n    runId: suiteResult.runId,\n    timestamp: suiteResult.timestamp,\n    duration: suiteResult.duration,\n    summary: {\n      total: suiteResult.total,\n      passed: suiteResult.passed,\n      failed: suiteResult.failed,\n      errors: suiteResult.errors,\n      passRate: suiteResult.passRate,\n    },\n    byCategory: summarizeByCategory(suiteResult.results),\n    errorsByType: summarizeErrors(suiteResult.results),\n    results: suiteResult.results.map(r => ({\n      id: r.evalCase.id,\n      name: r.evalCase.name,\n      category: r.evalCase.category,\n      success: r.success,\n      duration: r.duration,\n      errorType: r.errorType,\n      retryCount: r.retryCount,\n      trialResults: r.trialResults,\n      judgeResults: r.judgeResults.map(j => ({\n        judgeId: j.judgeId,\n        passed: j.passed,\n        score: j.score,\n        reasoning: j.reasoning,\n      })),\n    })),\n  };\n}\n","import type { EvalSuiteResult } from '../runner/eval-runner.js';\n\nexport interface AggregatedResult {\n  evalId: string;\n  evalName: string;\n  runs: number;\n  passes: number;\n  failures: number;\n  errors: number;\n  passRate: number;\n  avgDuration: number;\n  flaky: boolean;\n  flakinessScore: number;\n}\n\nexport interface AggregatedSummary {\n  totalRuns: number;\n  totalEvals: number;\n  overallPassRate: number;\n  avgPassRate: number;\n  flakyEvals: number;\n  results: AggregatedResult[];\n}\n\nexport function aggregateResults(suiteResults: EvalSuiteResult[]): AggregatedSummary {\n  const evalMap = new Map<string, {\n    evalId: string;\n    evalName: string;\n    results: { success: boolean; duration: number; hasError: boolean }[];\n  }>();\n\n  for (const suite of suiteResults) {\n    for (const result of suite.results) {\n      const id = result.evalCase.id;\n      if (!evalMap.has(id)) {\n        evalMap.set(id, {\n          evalId: id,\n          evalName: result.evalCase.name,\n          results: [],\n        });\n      }\n      evalMap.get(id)!.results.push({\n        success: result.success,\n        duration: result.duration,\n        hasError: !!result.error,\n      });\n    }\n  }\n\n  const aggregatedResults: AggregatedResult[] = Array.from(evalMap.values()).map(data => {\n    const runs = data.results.length;\n    const passes = data.results.filter(r => r.success).length;\n    const errors = data.results.filter(r => r.hasError).length;\n    const failures = runs - passes - errors;\n    const passRate = runs > 0 ? passes / runs : 0;\n    const avgDuration = runs > 0\n      ? data.results.reduce((sum, r) => sum + r.duration, 0) / runs\n      : 0;\n\n    const flakinessScore = calculateFlakinessScore(data.results.map(r => r.success));\n    const flaky = flakinessScore > 0.2 && runs >= 3;\n\n    return {\n      evalId: data.evalId,\n      evalName: data.evalName,\n      runs,\n      passes,\n      failures,\n      errors,\n      passRate,\n      avgDuration,\n      flaky,\n      flakinessScore,\n    };\n  });\n\n  const totalRuns = suiteResults.length;\n  const totalEvals = aggregatedResults.length;\n  const overallPassRate = totalEvals > 0\n    ? aggregatedResults.reduce((sum, r) => sum + r.passRate, 0) / totalEvals\n    : 0;\n  const avgPassRate = totalEvals > 0\n    ? aggregatedResults.reduce((sum, r) => sum + r.passRate, 0) / totalEvals\n    : 0;\n  const flakyEvals = aggregatedResults.filter(r => r.flaky).length;\n\n  return {\n    totalRuns,\n    totalEvals,\n    overallPassRate,\n    avgPassRate,\n    flakyEvals,\n    results: aggregatedResults,\n  };\n}\n\nfunction calculateFlakinessScore(results: boolean[]): number {\n  if (results.length < 2) return 0;\n\n  let transitions = 0;\n  for (let i = 1; i < results.length; i++) {\n    if (results[i] !== results[i - 1]) {\n      transitions++;\n    }\n  }\n\n  return transitions / (results.length - 1);\n}\n\nexport function detectRegressions(\n  current: EvalSuiteResult,\n  baseline: EvalSuiteResult\n): { evalId: string; evalName: string; wasSuccess: boolean; isSuccess: boolean }[] {\n  const regressions: { evalId: string; evalName: string; wasSuccess: boolean; isSuccess: boolean }[] = [];\n\n  const baselineMap = new Map<string, boolean>();\n  for (const result of baseline.results) {\n    baselineMap.set(result.evalCase.id, result.success);\n  }\n\n  for (const result of current.results) {\n    const wasSuccess = baselineMap.get(result.evalCase.id);\n    if (wasSuccess === true && !result.success) {\n      regressions.push({\n        evalId: result.evalCase.id,\n        evalName: result.evalCase.name,\n        wasSuccess: true,\n        isSuccess: false,\n      });\n    }\n  }\n\n  return regressions;\n}\n\nexport function calculateNonDeterminismMetrics(suiteResults: EvalSuiteResult[]): {\n  totalEvals: number;\n  deterministicEvals: number;\n  nonDeterministicEvals: number;\n  avgConsistency: number;\n} {\n  const evalMap = new Map<string, boolean[]>();\n\n  for (const suite of suiteResults) {\n    for (const result of suite.results) {\n      const id = result.evalCase.id;\n      if (!evalMap.has(id)) {\n        evalMap.set(id, []);\n      }\n      evalMap.get(id)!.push(result.success);\n    }\n  }\n\n  let deterministicCount = 0;\n  let totalConsistency = 0;\n\n  for (const [_, results] of evalMap) {\n    if (results.length < 2) {\n      deterministicCount++;\n      totalConsistency += 1;\n      continue;\n    }\n\n    const allSame = results.every(r => r === results[0]);\n    if (allSame) {\n      deterministicCount++;\n      totalConsistency += 1;\n    } else {\n      const modeCount = Math.max(\n        results.filter(r => r).length,\n        results.filter(r => !r).length\n      );\n      totalConsistency += modeCount / results.length;\n    }\n  }\n\n  const totalEvals = evalMap.size;\n\n  return {\n    totalEvals,\n    deterministicEvals: deterministicCount,\n    nonDeterministicEvals: totalEvals - deterministicCount,\n    avgConsistency: totalEvals > 0 ? totalConsistency / totalEvals : 1,\n  };\n}\n"]}