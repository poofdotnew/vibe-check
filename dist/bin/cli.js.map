{"version":3,"sources":["../../src/config/schemas.ts","../../src/utils/eval-loader.ts","../../src/learning/config.ts","../../src/learning/data-sources/eval-source.ts","../../src/learning/data-sources/jsonl-source.ts","../../src/learning/data-sources/types.ts","../../src/learning/data-sources/index.ts","../../src/learning/explanation-generator.ts","../../src/learning/pattern-detector.ts","../../src/learning/rule-generator.ts","../../src/learning/cli-reviewer.ts","../../src/learning/rule-writer.ts","../../src/learning/learning-runner.ts","../../src/config/types.ts","../../src/config/config-loader.ts","../../src/runner/eval-runner.ts","../../src/judges/judge-interface.ts","../../src/harness/workspace-manager.ts","../../src/harness/test-harness.ts","../../src/judges/builtin/file-existence.ts","../../src/judges/builtin/tool-invocation.ts","../../src/judges/builtin/pattern-match.ts","../../src/judges/judge-registry.ts","../../src/bin/cli.ts"],"names":["path5","fs5","__filename","__dirname","path","config","fs","fileURLToPath","readline","dotenv2","readline2","fs2","path3","fs3","passed","path4","fs4","loadEvalCases","LearningRunner"],"mappings":"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","file":"cli.js","sourcesContent":["import { z } from 'zod';\n\nexport const EvalCategorySchema = z.enum(['tool', 'code-gen', 'multi-turn', 'routing', 'basic']);\nexport type EvalCategory = z.infer<typeof EvalCategorySchema>;\n\nexport const EvalAgentTypeSchema = z.enum(['coding', 'conversational', 'research', 'computer-use', 'general']);\nexport type EvalAgentType = z.infer<typeof EvalAgentTypeSchema>;\n\nexport const ReferenceSolutionSchema = z.object({\n  files: z.array(z.string()).optional(),\n  description: z.string().optional(),\n  code: z.string().optional(),\n});\nexport type ReferenceSolution = z.infer<typeof ReferenceSolutionSchema>;\n\nexport const TrialConfigSchema = z.object({\n  count: z.number().min(1).max(10).default(1),\n  passThreshold: z.number().min(0).max(1).default(0.5),\n});\nexport type TrialConfig = z.infer<typeof TrialConfigSchema>;\n\nconst BaseEvalCaseSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  description: z.string(),\n  category: EvalCategorySchema,\n  tags: z.array(z.string()).optional(),\n  enabled: z.boolean().default(true),\n  timeout: z.number().optional(),\n  agentType: EvalAgentTypeSchema.optional(),\n  trials: TrialConfigSchema.optional(),\n  referenceSolution: ReferenceSolutionSchema.optional(),\n});\n\nexport const ExpectedToolCallSchema = z.object({\n  toolName: z.string(),\n  expectedInput: z.record(z.unknown()).optional(),\n  minCalls: z.number().optional(),\n  maxCalls: z.number().optional(),\n});\nexport type ExpectedToolCall = z.infer<typeof ExpectedToolCallSchema>;\n\nexport const ExpectedSkillSchema = z.object({\n  skillName: z.string(),\n  minCalls: z.number().optional().default(1),\n});\nexport type ExpectedSkill = z.infer<typeof ExpectedSkillSchema>;\n\nexport const ToolEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('tool'),\n  prompt: z.string(),\n  expectedToolCalls: z.array(ExpectedToolCallSchema),\n  expectedSkills: z.array(ExpectedSkillSchema).optional(),\n  judges: z.array(z.string()),\n});\nexport type ToolEvalCase = z.infer<typeof ToolEvalSchema>;\n\nexport const ExpectedPatternSchema = z.object({\n  file: z.string(),\n  patterns: z.array(z.string()),\n});\nexport type ExpectedPattern = z.infer<typeof ExpectedPatternSchema>;\n\nexport const CodeGenEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('code-gen'),\n  prompt: z.string(),\n  targetFiles: z.array(z.string()),\n  expectedPatterns: z.array(ExpectedPatternSchema).optional(),\n  syntaxValidation: z.boolean().default(true),\n  buildVerification: z.boolean().default(false),\n  judges: z.array(z.string()),\n});\nexport type CodeGenEvalCase = z.infer<typeof CodeGenEvalSchema>;\n\nexport const RoutingEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('routing'),\n  prompt: z.string(),\n  expectedAgent: z.string(),\n  shouldNotRoute: z.array(z.string()).optional(),\n  judges: z.array(z.string()),\n});\nexport type RoutingEvalCase = z.infer<typeof RoutingEvalSchema>;\n\nexport const TurnSchema = z.object({\n  prompt: z.string(),\n  expectedBehavior: z.string().optional(),\n  judges: z.array(z.string()).optional(),\n});\nexport type Turn = z.infer<typeof TurnSchema>;\n\nexport const MultiTurnEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('multi-turn'),\n  turns: z.array(TurnSchema),\n  sessionPersistence: z.boolean().default(true),\n  contextValidation: z.array(z.string()).optional(),\n  judges: z.array(z.string()).optional(),\n});\nexport type MultiTurnEvalCase = z.infer<typeof MultiTurnEvalSchema>;\n\nexport const BasicEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('basic'),\n  prompt: z.string(),\n  expectedBehavior: z.string().optional(),\n  judges: z.array(z.string()),\n});\nexport type BasicEvalCase = z.infer<typeof BasicEvalSchema>;\n\nexport const EvalCaseSchema = z.discriminatedUnion('category', [\n  ToolEvalSchema,\n  CodeGenEvalSchema,\n  RoutingEvalSchema,\n  MultiTurnEvalSchema,\n  BasicEvalSchema,\n]);\nexport type EvalCase = z.infer<typeof EvalCaseSchema>;\n\nexport function parseEvalCase(data: unknown): EvalCase {\n  return EvalCaseSchema.parse(data);\n}\n\nexport function isToolEval(evalCase: EvalCase): evalCase is ToolEvalCase {\n  return evalCase.category === 'tool';\n}\n\nexport function isCodeGenEval(evalCase: EvalCase): evalCase is CodeGenEvalCase {\n  return evalCase.category === 'code-gen';\n}\n\nexport function isRoutingEval(evalCase: EvalCase): evalCase is RoutingEvalCase {\n  return evalCase.category === 'routing';\n}\n\nexport function isMultiTurnEval(evalCase: EvalCase): evalCase is MultiTurnEvalCase {\n  return evalCase.category === 'multi-turn';\n}\n\nexport function isBasicEval(evalCase: EvalCase): evalCase is BasicEvalCase {\n  return evalCase.category === 'basic';\n}\n\nexport interface JudgeResult {\n  judgeId: string;\n  passed: boolean;\n  score: number;\n  confidence: number;\n  reasoning: string;\n  details?: Record<string, unknown>;\n}\n\nexport interface EvalCaseResult {\n  evalCase: EvalCase;\n  success: boolean;\n  output: string;\n  duration: number;\n  judgeResults: JudgeResult[];\n  toolCalls?: Array<{ toolName: string; input: unknown; output?: unknown; isError?: boolean }>;\n  error?: Error;\n  retryCount?: number;\n  trialResults?: boolean[];\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { glob } from 'glob';\nimport { EvalCase, parseEvalCase, EvalCategory } from '../config/schemas.js';\n\nexport interface LoadOptions {\n  testDir: string;\n  testMatch: string[];\n  categories?: EvalCategory[];\n  tags?: string[];\n  ids?: string[];\n  enabledOnly?: boolean;\n}\n\nexport async function loadEvalCases(options: LoadOptions): Promise<EvalCase[]> {\n  const { testDir, testMatch } = options;\n\n  const patterns = testMatch.map(pattern => path.join(testDir, pattern));\n  const files = await glob(patterns, { absolute: true });\n\n  const evalCases: EvalCase[] = [];\n\n  for (const file of files) {\n    try {\n      const content = await fs.readFile(file, 'utf-8');\n      const data = JSON.parse(content);\n      const evalCase = parseEvalCase(data);\n      evalCases.push(evalCase);\n    } catch (error) {\n      console.warn(`Failed to load eval case from ${file}:`, error);\n    }\n  }\n\n  return filterEvalCases(evalCases, options);\n}\n\nexport async function loadEvalCase(id: string, options: LoadOptions): Promise<EvalCase | null> {\n  const cases = await loadEvalCases({ ...options, ids: [id] });\n  return cases[0] || null;\n}\n\nfunction filterEvalCases(cases: EvalCase[], options: LoadOptions): EvalCase[] {\n  let filtered = cases;\n\n  if (options.enabledOnly !== false) {\n    filtered = filtered.filter((c) => c.enabled !== false);\n  }\n\n  if (options.categories && options.categories.length > 0) {\n    filtered = filtered.filter((c) => options.categories!.includes(c.category));\n  }\n\n  if (options.tags && options.tags.length > 0) {\n    filtered = filtered.filter((c) => c.tags?.some((t) => options.tags!.includes(t)));\n  }\n\n  if (options.ids && options.ids.length > 0) {\n    filtered = filtered.filter((c) => options.ids!.includes(c.id));\n  }\n\n  return filtered;\n}\n\nexport function groupByCategory(cases: EvalCase[]): Record<EvalCategory, EvalCase[]> {\n  const grouped: Record<EvalCategory, EvalCase[]> = {\n    tool: [],\n    'code-gen': [],\n    'multi-turn': [],\n    routing: [],\n    basic: [],\n  };\n\n  for (const evalCase of cases) {\n    grouped[evalCase.category].push(evalCase);\n  }\n\n  return grouped;\n}\n","/**\n * Configuration for the Prompt Learning System\n */\n\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport interface LearningConfig {\n  // Analysis settings\n  /** Minimum number of failures to form a pattern */\n  minFailuresForPattern: number;\n\n  /** Similarity threshold for grouping failures (0-1) */\n  similarityThreshold: number;\n\n  /** Maximum failures to process per iteration */\n  maxFailuresPerIteration: number;\n\n  // Rule generation settings\n  /** Model to use for explanation generation */\n  explanationModel: string;\n\n  /** Model to use for rule generation */\n  ruleGenerationModel: string;\n\n  /** Maximum rules to suggest per iteration */\n  maxRulesPerIteration: number;\n\n  /** Minimum confidence to include a rule */\n  minRuleConfidence: number;\n\n  // Validation settings\n  /** Number of evals to run for validation */\n  validationRunSize: number;\n\n  /** Maximum acceptable regression percentage */\n  regressionThreshold: number;\n\n  // Directories\n  /** Directory for the learning system */\n  learningDir: string;\n\n  /** Directory for prompts */\n  promptsDir: string;\n\n  /** Directory for rules */\n  rulesDir: string;\n\n  /** Directory for pending rules */\n  pendingDir: string;\n\n  /** Directory for approved rules */\n  approvedDir: string;\n\n  /** Directory for rejected rules */\n  rejectedDir: string;\n\n  /** Path to learned rules JSON */\n  learnedRulesPath: string;\n\n  /** Path to learning history */\n  historyPath: string;\n\n  /** Directory for eval results (to read from) */\n  evalResultsDir: string;\n}\n\nconst LEARNING_DIR = path.join(__dirname);\nconst RULES_DIR = path.join(LEARNING_DIR, 'rules');\nconst EVAL_RESULTS_DIR = path.join(__dirname, '..', 'results');\n\nexport const DEFAULT_LEARNING_CONFIG: LearningConfig = {\n  // Analysis settings\n  minFailuresForPattern: 2,\n  similarityThreshold: 0.7,\n  maxFailuresPerIteration: 100,\n\n  // Rule generation settings\n  explanationModel: 'claude-sonnet-4-20250514',\n  ruleGenerationModel: 'claude-sonnet-4-20250514',\n  maxRulesPerIteration: 5,\n  minRuleConfidence: 0.6,\n\n  // Validation settings\n  validationRunSize: 10,\n  regressionThreshold: 5, // 5% max regression\n\n  // Directories\n  learningDir: LEARNING_DIR,\n  promptsDir: path.join(LEARNING_DIR, 'prompts'),\n  rulesDir: RULES_DIR,\n  pendingDir: path.join(RULES_DIR, 'pending'),\n  approvedDir: path.join(RULES_DIR, 'approved'),\n  rejectedDir: path.join(RULES_DIR, 'rejected'),\n  learnedRulesPath: path.join(RULES_DIR, 'learned-rules.json'),\n  historyPath: path.join(RULES_DIR, 'history.json'),\n  evalResultsDir: EVAL_RESULTS_DIR,\n};\n\n/**\n * Get the learning configuration, optionally with overrides\n */\nexport function getLearningConfig(\n  overrides?: Partial<LearningConfig>\n): LearningConfig {\n  return {\n    ...DEFAULT_LEARNING_CONFIG,\n    ...overrides,\n  };\n}\n\n/**\n * Environment variable overrides\n */\nexport function getConfigFromEnv(): Partial<LearningConfig> {\n  const overrides: Partial<LearningConfig> = {};\n\n  if (process.env.LEARNING_EXPLANATION_MODEL) {\n    overrides.explanationModel = process.env.LEARNING_EXPLANATION_MODEL;\n  }\n\n  if (process.env.LEARNING_RULE_MODEL) {\n    overrides.ruleGenerationModel = process.env.LEARNING_RULE_MODEL;\n  }\n\n  if (process.env.LEARNING_MIN_PATTERN_SIZE) {\n    overrides.minFailuresForPattern = parseInt(\n      process.env.LEARNING_MIN_PATTERN_SIZE,\n      10\n    );\n  }\n\n  if (process.env.LEARNING_SIMILARITY_THRESHOLD) {\n    overrides.similarityThreshold = parseFloat(\n      process.env.LEARNING_SIMILARITY_THRESHOLD\n    );\n  }\n\n  if (process.env.LEARNING_MAX_RULES) {\n    overrides.maxRulesPerIteration = parseInt(\n      process.env.LEARNING_MAX_RULES,\n      10\n    );\n  }\n\n  return overrides;\n}\n\nexport default getLearningConfig;\n","/**\n * Data source for extracting failures from eval results.\n * Reads from __evals__/results/ directory.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport type { DataSource, FailureInput, CollectOptions, ToolCall } from './types.js';\nimport type { EvalSuiteResult, EvalCaseResult } from '../../runner/eval-runner.js';\nimport type { EvalCase } from '../../config/schemas.js';\nimport { getLearningConfig } from '../config.js';\n\n/**\n * Extracts the prompt from an eval case based on its category\n */\nfunction getPromptFromEvalCase(evalCase: EvalCase): string {\n  if ('prompt' in evalCase) {\n    return evalCase.prompt;\n  }\n  if ('turns' in evalCase && evalCase.turns.length > 0) {\n    return evalCase.turns.map((t) => t.prompt).join('\\n---\\n');\n  }\n  return '';\n}\n\n/**\n * Extracts expected behavior from an eval case\n */\nfunction getExpectedBehavior(evalCase: EvalCase): string | undefined {\n  if ('expectedBehavior' in evalCase) {\n    return evalCase.expectedBehavior;\n  }\n  if ('expectedToolCalls' in evalCase) {\n    return `Expected tool calls: ${evalCase.expectedToolCalls.map((t) => t.toolName).join(', ')}`;\n  }\n  if ('expectedAgent' in evalCase) {\n    return `Expected to route to: ${evalCase.expectedAgent}`;\n  }\n  if ('targetFiles' in evalCase) {\n    return `Expected to create/modify files: ${evalCase.targetFiles.join(', ')}`;\n  }\n  return undefined;\n}\n\n/**\n * Converts an EvalCaseResult to a FailureInput\n */\nfunction evalResultToFailureInput(result: EvalCaseResult): FailureInput {\n  const toolCalls: ToolCall[] =\n    result.toolCalls?.map((tc) => ({\n      name: tc.toolName,\n      input: tc.input as Record<string, unknown>,\n      output: typeof tc.output === 'string' ? tc.output : JSON.stringify(tc.output),\n    })) ?? [];\n\n  return {\n    id: result.evalCase.id,\n    source: 'eval',\n    sourceId: result.evalCase.id,\n    prompt: getPromptFromEvalCase(result.evalCase),\n    expectedBehavior: getExpectedBehavior(result.evalCase),\n    category: result.evalCase.category,\n    output: result.output ?? '',\n    toolCalls,\n    error: result.error?.message,\n    judgeResults: result.judgeResults,\n    timestamp: new Date().toISOString(),\n    metadata: {\n      evalName: result.evalCase.name,\n      evalDescription: result.evalCase.description,\n      evalTags: result.evalCase.tags,\n      duration: result.duration,\n      retryCount: result.retryCount,\n    },\n  };\n}\n\nexport class EvalDataSource implements DataSource {\n  name = 'eval';\n  private resultsDir: string;\n\n  constructor(resultsDir?: string) {\n    const config = getLearningConfig();\n    this.resultsDir = resultsDir ?? config.evalResultsDir;\n  }\n\n  async isAvailable(): Promise<boolean> {\n    try {\n      await fs.access(this.resultsDir);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Gets the path to the latest results file\n   */\n  private async getLatestResultsPath(): Promise<string | null> {\n    try {\n      // First check for latest.json symlink/file\n      const latestPath = path.join(this.resultsDir, 'latest.json');\n      try {\n        await fs.access(latestPath);\n        return latestPath;\n      } catch {\n        // No latest.json, look for most recent eval-results file\n      }\n\n      const files = await fs.readdir(this.resultsDir);\n      const resultFiles = files\n        .filter((f) => f.startsWith('eval-results-') && f.endsWith('.json'))\n        .sort()\n        .reverse();\n\n      if (resultFiles.length === 0) {\n        return null;\n      }\n\n      return path.join(this.resultsDir, resultFiles[0]);\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Reads eval results from a file\n   */\n  private async readResults(filePath: string): Promise<EvalSuiteResult | null> {\n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n      return JSON.parse(content) as EvalSuiteResult;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Collects failed evals from the results directory\n   */\n  async collect(options?: CollectOptions): Promise<FailureInput[]> {\n    const resultsPath = await this.getLatestResultsPath();\n    if (!resultsPath) {\n      console.warn('No eval results found in', this.resultsDir);\n      return [];\n    }\n\n    const suiteResult = await this.readResults(resultsPath);\n    if (!suiteResult) {\n      console.warn('Could not parse eval results from', resultsPath);\n      return [];\n    }\n\n    // Filter to only failed results\n    let failures = suiteResult.results.filter((r) => !r.success);\n\n    // Apply category filter\n    if (options?.categories && options.categories.length > 0) {\n      failures = failures.filter((r) =>\n        options.categories!.includes(r.evalCase.category)\n      );\n    }\n\n    // Apply ID filter\n    if (options?.ids && options.ids.length > 0) {\n      failures = failures.filter((r) => options.ids!.includes(r.evalCase.id));\n    }\n\n    // Apply limit\n    if (options?.limit && options.limit > 0) {\n      failures = failures.slice(0, options.limit);\n    }\n\n    // Convert to FailureInput format\n    return failures.map(evalResultToFailureInput);\n  }\n\n  /**\n   * Gets summary statistics about available results\n   */\n  async getStats(): Promise<{\n    totalRuns: number;\n    latestRun: EvalSuiteResult | null;\n    failuresInLatest: number;\n  }> {\n    const files = await fs.readdir(this.resultsDir).catch(() => []);\n    const resultFiles = files.filter(\n      (f) => f.startsWith('eval-results-') && f.endsWith('.json')\n    );\n\n    const latestPath = await this.getLatestResultsPath();\n    const latestRun = latestPath ? await this.readResults(latestPath) : null;\n    const failuresInLatest = latestRun\n      ? latestRun.results.filter((r) => !r.success).length\n      : 0;\n\n    return {\n      totalRuns: resultFiles.length,\n      latestRun,\n      failuresInLatest,\n    };\n  }\n}\n\nexport default EvalDataSource;\n","/**\n * Data source for extracting failures from production JSONL logs.\n * Scans prompt-runs/project-* folders for .claude session logs.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { createReadStream } from 'fs';\nimport readline from 'readline';\nimport type { DataSource, FailureInput, CollectOptions, ToolCall } from './types.js';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Structure of a JSONL message entry\n */\ninterface JsonlMessage {\n  uuid: string;\n  parentUuid: string | null;\n  type: 'user' | 'assistant';\n  sessionId: string;\n  agentId?: string;\n  timestamp: string;\n  cwd?: string;\n  message: {\n    role: 'user' | 'assistant';\n    content: string | ContentBlock[];\n    model?: string;\n    id?: string;\n    stop_reason?: string | null;\n    usage?: {\n      input_tokens: number;\n      output_tokens: number;\n    };\n  };\n  toolUseResult?: string;\n  isSidechain?: boolean;\n}\n\ninterface ContentBlock {\n  type: 'text' | 'tool_use' | 'tool_result';\n  text?: string;\n  id?: string;\n  name?: string;\n  input?: Record<string, unknown>;\n  content?: string;\n  is_error?: boolean;\n  tool_use_id?: string;\n}\n\n/**\n * A session with all its messages\n */\ninterface Session {\n  sessionId: string;\n  agentId?: string;\n  messages: JsonlMessage[];\n  firstMessage: JsonlMessage;\n  lastMessage: JsonlMessage;\n  hasErrors: boolean;\n  errors: SessionError[];\n}\n\ninterface SessionError {\n  messageUuid: string;\n  toolName?: string;\n  errorMessage: string;\n  timestamp: string;\n  parentUuid?: string;\n}\n\nexport class JsonlDataSource implements DataSource {\n  name = 'jsonl';\n  private promptRunsDir: string;\n\n  constructor(promptRunsDir?: string) {\n    // Default to cdk/dev-server-manager/prompt-runs relative to project root\n    this.promptRunsDir = promptRunsDir ||\n      path.join(__dirname, '..', '..', '..', 'cdk', 'dev-server-manager', 'prompt-runs');\n  }\n\n  async isAvailable(): Promise<boolean> {\n    try {\n      await fs.access(this.promptRunsDir);\n      const projects = await this.findProjectFolders();\n      return projects.length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Finds all project-* folders in prompt-runs\n   */\n  private async findProjectFolders(): Promise<string[]> {\n    try {\n      const entries = await fs.readdir(this.promptRunsDir, { withFileTypes: true });\n      return entries\n        .filter(e => e.isDirectory() && e.name.startsWith('project-'))\n        .map(e => path.join(this.promptRunsDir, e.name));\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Finds all .jsonl files in a project's .claude folders\n   */\n  private async findJsonlFiles(projectDir: string): Promise<string[]> {\n    const jsonlFiles: string[] = [];\n\n    const searchDir = async (dir: string) => {\n      try {\n        const entries = await fs.readdir(dir, { withFileTypes: true });\n        for (const entry of entries) {\n          const fullPath = path.join(dir, entry.name);\n          if (entry.isDirectory()) {\n            await searchDir(fullPath);\n          } else if (entry.isFile() && entry.name.endsWith('.jsonl')) {\n            jsonlFiles.push(fullPath);\n          }\n        }\n      } catch {\n        // Ignore permission errors\n      }\n    };\n\n    await searchDir(projectDir);\n    return jsonlFiles;\n  }\n\n  /**\n   * Parses a JSONL file into messages\n   */\n  private async parseJsonlFile(filePath: string): Promise<JsonlMessage[]> {\n    const messages: JsonlMessage[] = [];\n\n    const fileStream = createReadStream(filePath);\n    const rl = readline.createInterface({\n      input: fileStream,\n      crlfDelay: Infinity,\n    });\n\n    for await (const line of rl) {\n      if (line.trim()) {\n        try {\n          const parsed = JSON.parse(line) as JsonlMessage;\n          messages.push(parsed);\n        } catch {\n          // Skip malformed lines\n        }\n      }\n    }\n\n    return messages;\n  }\n\n  /**\n   * Groups messages into sessions\n   */\n  private groupIntoSessions(messages: JsonlMessage[]): Session[] {\n    const sessionMap = new Map<string, JsonlMessage[]>();\n\n    for (const msg of messages) {\n      const key = msg.agentId || msg.sessionId;\n      if (!sessionMap.has(key)) {\n        sessionMap.set(key, []);\n      }\n      sessionMap.get(key)!.push(msg);\n    }\n\n    const sessions: Session[] = [];\n\n    for (const [key, msgs] of sessionMap) {\n      // Sort by timestamp\n      msgs.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n\n      // Find errors\n      const errors: SessionError[] = [];\n      for (const msg of msgs) {\n        const msgErrors = this.extractErrors(msg);\n        errors.push(...msgErrors);\n      }\n\n      if (msgs.length > 0) {\n        sessions.push({\n          sessionId: msgs[0].sessionId,\n          agentId: msgs[0].agentId,\n          messages: msgs,\n          firstMessage: msgs[0],\n          lastMessage: msgs[msgs.length - 1],\n          hasErrors: errors.length > 0,\n          errors,\n        });\n      }\n    }\n\n    return sessions;\n  }\n\n  /**\n   * Extracts errors from a message\n   */\n  private extractErrors(msg: JsonlMessage): SessionError[] {\n    const errors: SessionError[] = [];\n\n    // Check toolUseResult for errors\n    if (msg.toolUseResult) {\n      const resultStr = typeof msg.toolUseResult === 'string'\n        ? msg.toolUseResult\n        : JSON.stringify(msg.toolUseResult);\n      if (resultStr.toLowerCase().includes('error')) {\n        errors.push({\n          messageUuid: msg.uuid,\n          errorMessage: resultStr,\n          timestamp: msg.timestamp,\n          parentUuid: msg.parentUuid || undefined,\n        });\n      }\n    }\n\n    // Check content for tool_result with is_error\n    if (Array.isArray(msg.message?.content)) {\n      for (const block of msg.message.content) {\n        if (block.type === 'tool_result' && block.is_error) {\n          errors.push({\n            messageUuid: msg.uuid,\n            toolName: this.findToolNameForResult(msg, block.tool_use_id),\n            errorMessage: typeof block.content === 'string' ? block.content : JSON.stringify(block.content),\n            timestamp: msg.timestamp,\n            parentUuid: msg.parentUuid || undefined,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Finds the tool name for a tool_use_id by looking at parent messages\n   */\n  private findToolNameForResult(msg: JsonlMessage, toolUseId?: string): string | undefined {\n    if (!toolUseId) return undefined;\n\n    // Look in the message content for matching tool_use\n    if (Array.isArray(msg.message?.content)) {\n      for (const block of msg.message.content) {\n        if (block.type === 'tool_use' && block.id === toolUseId) {\n          return block.name;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Extracts the initial prompt from a session\n   */\n  private extractPrompt(session: Session): string {\n    const firstUserMsg = session.messages.find(m => m.type === 'user');\n    if (!firstUserMsg) return '';\n\n    const content = firstUserMsg.message?.content;\n    if (typeof content === 'string') {\n      return content;\n    }\n    if (Array.isArray(content)) {\n      const textBlock = content.find(b => b.type === 'text');\n      return textBlock?.text || '';\n    }\n    return '';\n  }\n\n  /**\n   * Extracts all tool calls from a session\n   */\n  private extractToolCalls(session: Session): ToolCall[] {\n    const toolCalls: ToolCall[] = [];\n    const toolUseMap = new Map<string, ContentBlock>();\n\n    // First pass: collect tool_use blocks\n    for (const msg of session.messages) {\n      if (Array.isArray(msg.message?.content)) {\n        for (const block of msg.message.content) {\n          if (block.type === 'tool_use' && block.id) {\n            toolUseMap.set(block.id, block);\n          }\n        }\n      }\n    }\n\n    // Second pass: match with tool_result\n    for (const msg of session.messages) {\n      if (Array.isArray(msg.message?.content)) {\n        for (const block of msg.message.content) {\n          if (block.type === 'tool_result' && block.tool_use_id) {\n            const toolUse = toolUseMap.get(block.tool_use_id);\n            if (toolUse) {\n              toolCalls.push({\n                name: toolUse.name || 'unknown',\n                input: toolUse.input,\n                output: typeof block.content === 'string' ? block.content : JSON.stringify(block.content),\n                error: block.is_error ? (typeof block.content === 'string' ? block.content : JSON.stringify(block.content)) : undefined,\n                timestamp: msg.timestamp,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return toolCalls;\n  }\n\n  /**\n   * Extracts the final output from a session\n   */\n  private extractOutput(session: Session): string {\n    // Find last assistant message with text content\n    for (let i = session.messages.length - 1; i >= 0; i--) {\n      const msg = session.messages[i];\n      if (msg.type === 'assistant') {\n        const content = msg.message?.content;\n        if (typeof content === 'string') {\n          return content;\n        }\n        if (Array.isArray(content)) {\n          const textBlock = content.find(b => b.type === 'text');\n          if (textBlock?.text) {\n            return textBlock.text;\n          }\n        }\n      }\n    }\n    return '';\n  }\n\n  /**\n   * Converts a session with errors to a FailureInput\n   */\n  private sessionToFailureInput(session: Session, filePath: string): FailureInput {\n    const prompt = this.extractPrompt(session);\n    const output = this.extractOutput(session);\n    const toolCalls = this.extractToolCalls(session);\n\n    // Combine all errors into a single error message\n    const errorMessage = session.errors\n      .map(e => e.toolName ? `${e.toolName}: ${e.errorMessage}` : e.errorMessage)\n      .join('\\n');\n\n    return {\n      id: `jsonl-${session.agentId || session.sessionId}-${Date.now()}`,\n      source: 'production',\n      sourceId: filePath,\n      prompt,\n      output,\n      toolCalls,\n      error: errorMessage,\n      timestamp: session.firstMessage.timestamp,\n      metadata: {\n        sessionId: session.sessionId,\n        agentId: session.agentId,\n        errorCount: session.errors.length,\n        messageCount: session.messages.length,\n        cwd: session.firstMessage.cwd,\n        errors: session.errors,\n      },\n    };\n  }\n\n  /**\n   * Collects failures from production JSONL logs\n   */\n  async collect(options?: CollectOptions): Promise<FailureInput[]> {\n    const failures: FailureInput[] = [];\n    const projectFolders = await this.findProjectFolders();\n\n    if (projectFolders.length === 0) {\n      console.warn(`No project-* folders found in ${this.promptRunsDir}`);\n      return [];\n    }\n\n    for (const projectDir of projectFolders) {\n      const jsonlFiles = await this.findJsonlFiles(projectDir);\n\n      for (const filePath of jsonlFiles) {\n        // Apply date filters\n        if (options?.since || options?.until) {\n          const stats = await fs.stat(filePath);\n          if (options.since && stats.mtime < options.since) continue;\n          if (options.until && stats.mtime > options.until) continue;\n        }\n\n        const messages = await this.parseJsonlFile(filePath);\n        const sessions = this.groupIntoSessions(messages);\n\n        for (const session of sessions) {\n          if (session.hasErrors) {\n            const failure = this.sessionToFailureInput(session, filePath);\n            failures.push(failure);\n          }\n        }\n\n        // Check limit\n        if (options?.limit && failures.length >= options.limit) {\n          return failures.slice(0, options.limit);\n        }\n      }\n    }\n\n    return failures;\n  }\n\n  /**\n   * Gets statistics about available JSONL data\n   */\n  async getStats(): Promise<{\n    projectCount: number;\n    jsonlFileCount: number;\n    sessionCount: number;\n    errorSessionCount: number;\n  }> {\n    const projectFolders = await this.findProjectFolders();\n    let jsonlFileCount = 0;\n    let sessionCount = 0;\n    let errorSessionCount = 0;\n\n    for (const projectDir of projectFolders) {\n      const jsonlFiles = await this.findJsonlFiles(projectDir);\n      jsonlFileCount += jsonlFiles.length;\n\n      for (const filePath of jsonlFiles) {\n        const messages = await this.parseJsonlFile(filePath);\n        const sessions = this.groupIntoSessions(messages);\n        sessionCount += sessions.length;\n        errorSessionCount += sessions.filter(s => s.hasErrors).length;\n      }\n    }\n\n    return {\n      projectCount: projectFolders.length,\n      jsonlFileCount,\n      sessionCount,\n      errorSessionCount,\n    };\n  }\n}\n\nexport default JsonlDataSource;\n","/**\n * Common types for all data sources in the learning system.\n * All data sources output FailureInput[] which feeds into the learning pipeline.\n */\n\nimport type { JudgeResult, EvalCategory } from '../../config/schemas.js';\n\n/**\n * Represents a tool call made by the agent\n */\nexport interface ToolCall {\n  name: string;\n  input?: Record<string, unknown>;\n  output?: string;\n  error?: string;\n  timestamp?: string;\n}\n\n/**\n * Common input format for all data sources.\n * This is the interface between data sources and the learning pipeline.\n */\nexport interface FailureInput {\n  /** Unique identifier for this failure */\n  id: string;\n\n  /** Source type: eval results, production logs, or custom */\n  source: 'eval' | 'production' | 'custom';\n\n  /** Source-specific identifier (eval ID, JSONL file path, etc.) */\n  sourceId: string;\n\n  /** The prompt/request given to the agent */\n  prompt: string;\n\n  /** Expected behavior (optional for production logs) */\n  expectedBehavior?: string;\n\n  /** Category of the eval (optional for production logs) */\n  category?: EvalCategory;\n\n  /** The agent's output/response */\n  output: string;\n\n  /** Tool calls made during execution */\n  toolCalls?: ToolCall[];\n\n  /** Error message if the agent failed */\n  error?: string;\n\n  /** Existing judge results if available */\n  judgeResults?: JudgeResult[];\n\n  /** When this failure occurred */\n  timestamp: string;\n\n  /** Additional metadata from the source */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Options for collecting failures from a data source\n */\nexport interface CollectOptions {\n  /** Filter by date range */\n  since?: Date;\n  until?: Date;\n\n  /** Maximum number of failures to collect */\n  limit?: number;\n\n  /** Filter by category (for eval sources) */\n  categories?: EvalCategory[];\n\n  /** Filter by specific IDs */\n  ids?: string[];\n\n  /** Project ID for production data source (fetches from S3) */\n  projectId?: string;\n\n  /** Task ID for production data source (optional, fetches all tasks if not specified) */\n  taskId?: string;\n\n  /** Custom filters */\n  filters?: Record<string, unknown>;\n}\n\n/**\n * Interface for data sources that can provide failure data\n */\nexport interface DataSource {\n  /** Name of the data source */\n  name: string;\n\n  /** Collects failures from the source */\n  collect(options?: CollectOptions): Promise<FailureInput[]>;\n\n  /** Optional: Check if the source is available/configured */\n  isAvailable?(): Promise<boolean>;\n}\n\n/**\n * Registry of available data sources\n */\nexport type DataSourceRegistry = Record<string, DataSource>;\n","/**\n * Data source registry and factory for the learning system.\n */\n\nimport type { DataSource, DataSourceRegistry, CollectOptions, FailureInput } from './types.js';\nimport { EvalDataSource } from './eval-source.js';\nimport { JsonlDataSource } from './jsonl-source.js';\n\n// Export types\nexport * from './types.js';\n\n// Export data sources\nexport { EvalDataSource } from './eval-source.js';\nexport { JsonlDataSource } from './jsonl-source.js';\n\n/**\n * Creates a data source by name\n */\nexport function createDataSource(\n  name: string,\n  options?: Record<string, unknown>\n): DataSource | null {\n  switch (name) {\n    case 'eval':\n      return new EvalDataSource(options?.resultsDir as string | undefined);\n\n    case 'jsonl':\n      return new JsonlDataSource(options?.promptRunsDir as string | undefined);\n\n    default:\n      console.warn(`Unknown data source: ${name}`);\n      return null;\n  }\n}\n\n/**\n * Registry of all available data sources\n */\nexport function getDataSourceRegistry(): DataSourceRegistry {\n  return {\n    eval: new EvalDataSource(),\n    jsonl: new JsonlDataSource(),\n  };\n}\n\n/**\n * Collects failures from multiple data sources\n */\nexport async function collectFromSources(\n  sources: string[],\n  options?: CollectOptions\n): Promise<FailureInput[]> {\n  const failures: FailureInput[] = [];\n\n  for (const sourceName of sources) {\n    const source = createDataSource(sourceName);\n    if (!source) {\n      console.warn(`Skipping unknown source: ${sourceName}`);\n      continue;\n    }\n\n    const isAvailable = await source.isAvailable?.();\n    if (isAvailable === false) {\n      console.warn(`Source not available: ${sourceName}`);\n      continue;\n    }\n\n    const sourceFailures = await source.collect(options);\n    failures.push(...sourceFailures);\n  }\n\n  return failures;\n}\n\n/**\n * Gets statistics about available data sources\n */\nexport async function getSourceStats(): Promise<\n  Record<string, { available: boolean; failureCount?: number; details?: Record<string, number> }>\n> {\n  const registry = getDataSourceRegistry();\n  const stats: Record<string, { available: boolean; failureCount?: number; details?: Record<string, number> }> = {};\n\n  for (const [name, source] of Object.entries(registry)) {\n    const available = (await source.isAvailable?.()) ?? true;\n    let failureCount: number | undefined;\n    let details: Record<string, number> | undefined;\n\n    if (available && name === 'eval') {\n      const evalSource = source as EvalDataSource;\n      const evalStats = await evalSource.getStats();\n      failureCount = evalStats.failuresInLatest;\n    }\n\n    if (available && name === 'jsonl') {\n      const jsonlSource = source as JsonlDataSource;\n      const jsonlStats = await jsonlSource.getStats();\n      failureCount = jsonlStats.errorSessionCount;\n      details = {\n        projects: jsonlStats.projectCount,\n        files: jsonlStats.jsonlFileCount,\n        sessions: jsonlStats.sessionCount,\n      };\n    }\n\n    stats[name] = { available, failureCount, details };\n  }\n\n  return stats;\n}\n","/**\n * Generates LLM-powered explanations for why failures occurred.\n * This is the critical component - quality of explanations drives learning quality.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport * as dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\nimport type { FailureInput } from './data-sources/types.js';\nimport type { FailureExplanation } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\ninterface ExplanationResult {\n  whatWentWrong: string;\n  whyItFailed: string;\n  rootCause: string;\n  suggestedFix: string;\n  patternCategory: string;\n  affectedComponent?: string;\n  confidence: number;\n}\n\ntype AnthropicClient = import('@anthropic-ai/sdk').default;\n\nexport class ExplanationGenerator {\n  private anthropic: AnthropicClient | null = null;\n  private config: LearningConfig;\n  private promptTemplate: string | null = null;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  private async getAnthropicClient(): Promise<AnthropicClient> {\n    if (!this.anthropic) {\n      const { default: Anthropic } = await import('@anthropic-ai/sdk');\n      this.anthropic = new Anthropic();\n    }\n    return this.anthropic;\n  }\n\n  /**\n   * Loads the failure analysis prompt template\n   */\n  private async loadPromptTemplate(): Promise<string> {\n    if (this.promptTemplate) {\n      return this.promptTemplate;\n    }\n\n    const promptPath = path.join(\n      this.config.promptsDir,\n      'failure-analysis.md'\n    );\n\n    try {\n      this.promptTemplate = await fs.readFile(promptPath, 'utf-8');\n      return this.promptTemplate;\n    } catch (error) {\n      throw new Error(\n        `Failed to load failure analysis prompt from ${promptPath}: ${error}`\n      );\n    }\n  }\n\n  /**\n   * Builds the prompt for a specific failure\n   */\n  private async buildPrompt(failure: FailureInput): Promise<string> {\n    const template = await this.loadPromptTemplate();\n\n    // Format tool calls\n    const toolCallsFormatted = failure.toolCalls?.length\n      ? failure.toolCalls\n          .map(\n            (tc) =>\n              `- ${tc.name}${tc.error ? ` (error: ${tc.error})` : ''}`\n          )\n          .join('\\n')\n      : 'None';\n\n    // Format judge results\n    const judgeResultsFormatted = failure.judgeResults?.length\n      ? failure.judgeResults\n          .map(\n            (jr) =>\n              `- ${jr.judgeId}: ${jr.passed ? 'PASSED' : 'FAILED'} (score: ${jr.score})\\n  Reasoning: ${jr.reasoning}`\n          )\n          .join('\\n')\n      : 'None';\n\n    // Replace template variables\n    let prompt = template\n      .replace('{{evalName}}', failure.metadata?.evalName as string ?? failure.id)\n      .replace('{{category}}', failure.category ?? 'unknown')\n      .replace('{{description}}', failure.metadata?.evalDescription as string ?? '')\n      .replace('{{prompt}}', failure.prompt)\n      .replace('{{expectedBehavior}}', failure.expectedBehavior ?? 'Not specified')\n      .replace('{{toolCalls}}', toolCallsFormatted)\n      .replace('{{output}}', failure.output || 'No output')\n      .replace('{{judgeResults}}', judgeResultsFormatted);\n\n    // Handle conditional error section\n    if (failure.error) {\n      prompt = prompt.replace('{{#if error}}', '').replace('{{/if}}', '');\n      prompt = prompt.replace('{{error}}', failure.error);\n    } else {\n      // Remove the error section if no error\n      prompt = prompt.replace(/{{#if error}}[\\s\\S]*?{{\\/if}}/g, '');\n    }\n\n    return prompt;\n  }\n\n  /**\n   * Parses the LLM response into a structured explanation\n   */\n  private parseResponse(text: string): ExplanationResult {\n    // Try to extract JSON from markdown code block\n    const jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n    const jsonContent = jsonMatch ? jsonMatch[1] : text;\n\n    try {\n      const parsed = JSON.parse(jsonContent.trim());\n\n      return {\n        whatWentWrong: parsed.whatWentWrong || 'Unknown',\n        whyItFailed: parsed.whyItFailed || 'Unknown',\n        rootCause: parsed.rootCause || 'Unknown',\n        suggestedFix: parsed.suggestedFix || 'No suggestion',\n        patternCategory: parsed.patternCategory || 'other',\n        affectedComponent: parsed.affectedComponent,\n        confidence: Math.max(0, Math.min(1, parsed.confidence || 0.5)),\n      };\n    } catch (error) {\n      console.warn('Failed to parse LLM response:', text.substring(0, 200));\n      return {\n        whatWentWrong: 'Failed to parse response',\n        whyItFailed: text.substring(0, 500),\n        rootCause: 'Parse error',\n        suggestedFix: 'Manual review required',\n        patternCategory: 'other',\n        confidence: 0,\n      };\n    }\n  }\n\n  /**\n   * Generates an explanation for a single failure\n   */\n  async generateExplanation(failure: FailureInput): Promise<FailureExplanation> {\n    const prompt = await this.buildPrompt(failure);\n\n    try {\n      const client = await this.getAnthropicClient();\n      const response = await client.messages.create({\n        model: this.config.explanationModel,\n        max_tokens: 1024,\n        messages: [{ role: 'user', content: prompt }],\n      });\n\n      const content = response.content[0];\n      if (content.type !== 'text') {\n        throw new Error('Unexpected response type from LLM');\n      }\n\n      const explanation = this.parseResponse(content.text);\n\n      return {\n        id: `explanation-${failure.id}-${Date.now()}`,\n        failureInput: failure,\n        explanation,\n        confidence: explanation.confidence,\n        generatedAt: new Date().toISOString(),\n        model: this.config.explanationModel,\n      };\n    } catch (error) {\n      console.error(`Failed to generate explanation for ${failure.id}:`, error);\n\n      return {\n        id: `explanation-${failure.id}-${Date.now()}`,\n        failureInput: failure,\n        explanation: {\n          whatWentWrong: 'Failed to generate explanation',\n          whyItFailed: error instanceof Error ? error.message : 'Unknown error',\n          rootCause: 'LLM error',\n          suggestedFix: 'Manual review required',\n          patternCategory: 'other',\n        },\n        confidence: 0,\n        generatedAt: new Date().toISOString(),\n        model: this.config.explanationModel,\n      };\n    }\n  }\n\n  /**\n   * Generates explanations for multiple failures\n   */\n  async generateExplanations(\n    failures: FailureInput[],\n    options?: {\n      concurrency?: number;\n      onProgress?: (completed: number, total: number) => void;\n    }\n  ): Promise<FailureExplanation[]> {\n    const concurrency = options?.concurrency ?? 3;\n    const explanations: FailureExplanation[] = [];\n    let completed = 0;\n\n    // Process in batches\n    for (let i = 0; i < failures.length; i += concurrency) {\n      const batch = failures.slice(i, i + concurrency);\n      const batchResults = await Promise.all(\n        batch.map((f) => this.generateExplanation(f))\n      );\n      explanations.push(...batchResults);\n\n      completed += batch.length;\n      options?.onProgress?.(completed, failures.length);\n    }\n\n    return explanations;\n  }\n\n  /**\n   * Filters explanations by confidence threshold\n   */\n  filterByConfidence(\n    explanations: FailureExplanation[],\n    minConfidence: number = 0.5\n  ): FailureExplanation[] {\n    return explanations.filter((e) => e.confidence >= minConfidence);\n  }\n\n  /**\n   * Groups explanations by pattern category\n   */\n  groupByCategory(\n    explanations: FailureExplanation[]\n  ): Record<string, FailureExplanation[]> {\n    const grouped: Record<string, FailureExplanation[]> = {};\n\n    for (const explanation of explanations) {\n      const category = explanation.explanation.patternCategory;\n      if (!grouped[category]) {\n        grouped[category] = [];\n      }\n      grouped[category].push(explanation);\n    }\n\n    return grouped;\n  }\n}\n\nexport default ExplanationGenerator;\n","/**\n * Detects patterns across multiple failure explanations.\n * Groups similar failures to identify systemic issues.\n */\n\nimport type { FailureExplanation, FailurePattern } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\n/**\n * Simple text similarity using Jaccard index on word sets\n */\nfunction textSimilarity(a: string, b: string): number {\n  const wordsA = new Set(a.toLowerCase().split(/\\s+/).filter(w => w.length > 2));\n  const wordsB = new Set(b.toLowerCase().split(/\\s+/).filter(w => w.length > 2));\n\n  if (wordsA.size === 0 || wordsB.size === 0) {\n    return 0;\n  }\n\n  const intersection = new Set([...wordsA].filter(w => wordsB.has(w)));\n  const union = new Set([...wordsA, ...wordsB]);\n\n  return intersection.size / union.size;\n}\n\n/**\n * Calculates similarity between two failure explanations\n */\nfunction explanationSimilarity(a: FailureExplanation, b: FailureExplanation): number {\n  // If categories don't match, low similarity\n  if (a.explanation.patternCategory !== b.explanation.patternCategory) {\n    return 0.2;\n  }\n\n  // Compare root causes\n  const rootCauseSim = textSimilarity(\n    a.explanation.rootCause,\n    b.explanation.rootCause\n  );\n\n  // Compare what went wrong\n  const whatWrongSim = textSimilarity(\n    a.explanation.whatWentWrong,\n    b.explanation.whyItFailed\n  );\n\n  // Compare suggested fixes\n  const fixSim = textSimilarity(\n    a.explanation.suggestedFix,\n    b.explanation.suggestedFix\n  );\n\n  // Weighted average: root cause is most important\n  return rootCauseSim * 0.5 + whatWrongSim * 0.25 + fixSim * 0.25;\n}\n\n/**\n * Generates a pattern ID from a category and common words\n */\nfunction generatePatternId(\n  category: string,\n  explanations: FailureExplanation[]\n): string {\n  // Extract common words from root causes\n  const allWords = explanations\n    .flatMap(e => e.explanation.rootCause.toLowerCase().split(/\\s+/))\n    .filter(w => w.length > 3);\n\n  const wordCounts = new Map<string, number>();\n  for (const word of allWords) {\n    wordCounts.set(word, (wordCounts.get(word) || 0) + 1);\n  }\n\n  // Get top 2 most common words\n  const topWords = [...wordCounts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 2)\n    .map(([word]) => word);\n\n  const suffix = topWords.length > 0 ? `-${topWords.join('-')}` : '';\n  return `${category}${suffix}-${Date.now().toString(36)}`;\n}\n\n/**\n * Generates a human-readable pattern name\n */\nfunction generatePatternName(\n  category: string,\n  explanations: FailureExplanation[]\n): string {\n  // Use the most common affected component if available\n  const components = explanations\n    .map(e => e.explanation.affectedComponent)\n    .filter(Boolean);\n\n  const componentCounts = new Map<string, number>();\n  for (const comp of components) {\n    if (comp) {\n      componentCounts.set(comp, (componentCounts.get(comp) || 0) + 1);\n    }\n  }\n\n  const topComponent = [...componentCounts.entries()]\n    .sort((a, b) => b[1] - a[1])[0]?.[0];\n\n  const categoryName = category.replace(/-/g, ' ');\n\n  if (topComponent) {\n    return `${categoryName} in ${topComponent}`;\n  }\n\n  return `${categoryName} pattern`;\n}\n\n/**\n * Extracts common root causes from a group of explanations\n */\nfunction extractCommonRootCauses(explanations: FailureExplanation[]): string[] {\n  // Collect all root causes\n  const rootCauses = explanations.map(e => e.explanation.rootCause);\n\n  // Find unique-ish causes (not too similar to each other)\n  const uniqueCauses: string[] = [];\n\n  for (const cause of rootCauses) {\n    const isDuplicate = uniqueCauses.some(\n      existing => textSimilarity(existing, cause) > 0.7\n    );\n    if (!isDuplicate) {\n      uniqueCauses.push(cause);\n    }\n  }\n\n  return uniqueCauses.slice(0, 5); // Max 5 causes\n}\n\nexport class PatternDetector {\n  private config: LearningConfig;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  /**\n   * Detects patterns in a set of failure explanations\n   */\n  detectPatterns(explanations: FailureExplanation[]): FailurePattern[] {\n    if (explanations.length === 0) {\n      return [];\n    }\n\n    // First, group by category\n    const byCategory = new Map<string, FailureExplanation[]>();\n    for (const exp of explanations) {\n      const category = exp.explanation.patternCategory;\n      if (!byCategory.has(category)) {\n        byCategory.set(category, []);\n      }\n      byCategory.get(category)!.push(exp);\n    }\n\n    const patterns: FailurePattern[] = [];\n\n    // Process each category\n    for (const [category, categoryExplanations] of byCategory) {\n      // Skip if not enough failures to form a pattern\n      if (categoryExplanations.length < this.config.minFailuresForPattern) {\n        continue;\n      }\n\n      // Cluster within category using similarity\n      const clusters = this.clusterExplanations(\n        categoryExplanations,\n        this.config.similarityThreshold\n      );\n\n      // Convert clusters to patterns\n      for (const cluster of clusters) {\n        if (cluster.length >= this.config.minFailuresForPattern) {\n          patterns.push(this.createPattern(category, cluster));\n        }\n      }\n    }\n\n    // Sort by frequency (most common patterns first)\n    return patterns.sort((a, b) => b.frequency - a.frequency);\n  }\n\n  /**\n   * Clusters explanations by similarity\n   */\n  private clusterExplanations(\n    explanations: FailureExplanation[],\n    threshold: number\n  ): FailureExplanation[][] {\n    const clusters: FailureExplanation[][] = [];\n    const assigned = new Set<string>();\n\n    for (const exp of explanations) {\n      if (assigned.has(exp.id)) {\n        continue;\n      }\n\n      // Start a new cluster\n      const cluster = [exp];\n      assigned.add(exp.id);\n\n      // Find similar explanations\n      for (const other of explanations) {\n        if (assigned.has(other.id)) {\n          continue;\n        }\n\n        // Check similarity against all cluster members\n        const avgSimilarity =\n          cluster.reduce(\n            (sum, member) => sum + explanationSimilarity(member, other),\n            0\n          ) / cluster.length;\n\n        if (avgSimilarity >= threshold) {\n          cluster.push(other);\n          assigned.add(other.id);\n        }\n      }\n\n      clusters.push(cluster);\n    }\n\n    return clusters;\n  }\n\n  /**\n   * Creates a FailurePattern from a cluster of explanations\n   */\n  private createPattern(\n    category: string,\n    explanations: FailureExplanation[]\n  ): FailurePattern {\n    // Calculate average similarity within cluster\n    let totalSim = 0;\n    let pairCount = 0;\n    for (let i = 0; i < explanations.length; i++) {\n      for (let j = i + 1; j < explanations.length; j++) {\n        totalSim += explanationSimilarity(explanations[i], explanations[j]);\n        pairCount++;\n      }\n    }\n    const avgSimilarity = pairCount > 0 ? totalSim / pairCount : 1;\n\n    // Collect affected components\n    const components = new Set<string>();\n    for (const exp of explanations) {\n      if (exp.explanation.affectedComponent) {\n        components.add(exp.explanation.affectedComponent);\n      }\n    }\n\n    return {\n      patternId: generatePatternId(category, explanations),\n      patternName: generatePatternName(category, explanations),\n      category,\n      failures: explanations,\n      frequency: explanations.length,\n      affectedComponents: [...components],\n      commonRootCauses: extractCommonRootCauses(explanations),\n      similarityScore: avgSimilarity,\n      detectedAt: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Merges similar patterns across different runs\n   */\n  mergeWithExisting(\n    newPatterns: FailurePattern[],\n    existingPatterns: FailurePattern[]\n  ): FailurePattern[] {\n    const merged: FailurePattern[] = [...existingPatterns];\n\n    for (const newPattern of newPatterns) {\n      // Find existing pattern with same category and high similarity\n      const existingIndex = merged.findIndex(\n        existing =>\n          existing.category === newPattern.category &&\n          this.patternsAreSimilar(existing, newPattern)\n      );\n\n      if (existingIndex >= 0) {\n        // Merge into existing pattern\n        const existing = merged[existingIndex];\n        merged[existingIndex] = {\n          ...existing,\n          failures: [...existing.failures, ...newPattern.failures],\n          frequency: existing.frequency + newPattern.frequency,\n          affectedComponents: [\n            ...new Set([\n              ...existing.affectedComponents,\n              ...newPattern.affectedComponents,\n            ]),\n          ],\n          commonRootCauses: extractCommonRootCauses([\n            ...existing.failures,\n            ...newPattern.failures,\n          ]),\n        };\n      } else {\n        // Add as new pattern\n        merged.push(newPattern);\n      }\n    }\n\n    return merged;\n  }\n\n  /**\n   * Checks if two patterns are similar enough to merge\n   */\n  private patternsAreSimilar(a: FailurePattern, b: FailurePattern): boolean {\n    // Compare root causes\n    const aCauses = a.commonRootCauses.join(' ');\n    const bCauses = b.commonRootCauses.join(' ');\n\n    return textSimilarity(aCauses, bCauses) > 0.6;\n  }\n\n  /**\n   * Gets pattern statistics\n   */\n  getStats(patterns: FailurePattern[]): {\n    totalPatterns: number;\n    totalFailures: number;\n    avgPatterSize: number;\n    byCategory: Record<string, number>;\n  } {\n    const totalPatterns = patterns.length;\n    const totalFailures = patterns.reduce((sum, p) => sum + p.frequency, 0);\n    const avgPatterSize =\n      totalPatterns > 0 ? totalFailures / totalPatterns : 0;\n\n    const byCategory: Record<string, number> = {};\n    for (const pattern of patterns) {\n      byCategory[pattern.category] =\n        (byCategory[pattern.category] || 0) + pattern.frequency;\n    }\n\n    return {\n      totalPatterns,\n      totalFailures,\n      avgPatterSize,\n      byCategory,\n    };\n  }\n}\n\nexport default PatternDetector;\n","/**\n * Generates new prompt rules based on detected failure patterns.\n * Uses LLM to synthesize rules from pattern analysis.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport * as dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\nimport type { FailurePattern, ProposedRule } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\ninterface RuleGenerationResult {\n  rule: string;\n  targetSection: string;\n  placement?: string;\n  rationale: string;\n  expectedImpact: {\n    evalIds: string[];\n    confidenceScore: number;\n  };\n}\n\n/**\n * Maps pattern categories to prompt sections\n */\nconst CATEGORY_TO_SECTION: Record<string, string> = {\n  'routing-error': 'CHAT_PROMPT.delegationPrinciple',\n  'delegation-error': 'CHAT_PROMPT.delegationPrinciple',\n  'missing-tool-call': 'CHAT_PROMPT.troubleshooting',\n  'incorrect-code-pattern': 'CORE_INSTRUCTIONS',\n  'validation-failure': 'CORE_INSTRUCTIONS.coreSafetyRules',\n  'context-missing': 'CHAT_PROMPT.reasoningAndPlanning',\n  other: 'CORE_INSTRUCTIONS',\n};\n\ntype AnthropicClient = import('@anthropic-ai/sdk').default;\n\nexport class RuleGenerator {\n  private anthropic: AnthropicClient | null = null;\n  private config: LearningConfig;\n  private promptTemplate: string | null = null;\n  private currentInstructions: Map<string, string> = new Map();\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  private async getAnthropicClient(): Promise<AnthropicClient> {\n    if (!this.anthropic) {\n      const { default: Anthropic } = await import('@anthropic-ai/sdk');\n      this.anthropic = new Anthropic();\n    }\n    return this.anthropic;\n  }\n\n  /**\n   * Loads the rule generation prompt template\n   */\n  private async loadPromptTemplate(): Promise<string> {\n    if (this.promptTemplate) {\n      return this.promptTemplate;\n    }\n\n    const promptPath = path.join(this.config.promptsDir, 'rule-generation.md');\n\n    try {\n      this.promptTemplate = await fs.readFile(promptPath, 'utf-8');\n      return this.promptTemplate;\n    } catch (error) {\n      throw new Error(\n        `Failed to load rule generation prompt from ${promptPath}: ${error}`\n      );\n    }\n  }\n\n  /**\n   * Loads current instructions from prompt-templates.ts\n   * (Reads a simplified version for context)\n   */\n  async loadCurrentInstructions(): Promise<void> {\n    const templatePath = path.join(\n      this.config.learningDir,\n      '..',\n      '..',\n      'lib',\n      'ai',\n      'claude-code',\n      'prompt-templates.ts'\n    );\n\n    try {\n      const content = await fs.readFile(templatePath, 'utf-8');\n\n      // Extract major sections (simplified parsing)\n      const sections = [\n        'CORE_INSTRUCTIONS',\n        'CHAT_PROMPT',\n        'delegationPrinciple',\n        'coreSafetyRules',\n        'troubleshooting',\n      ];\n\n      for (const section of sections) {\n        const regex = new RegExp(\n          `${section}[:\\\\s]*[\\`'\"](.*?)[\\`'\"]`,\n          'gs'\n        );\n        const match = content.match(regex);\n        if (match) {\n          this.currentInstructions.set(\n            section,\n            match[0].substring(0, 500) + '...'\n          );\n        }\n      }\n    } catch (error) {\n      console.warn('Could not load current instructions:', error);\n    }\n  }\n\n  /**\n   * Gets the target section for a pattern\n   */\n  private getTargetSection(pattern: FailurePattern): string {\n    return (\n      CATEGORY_TO_SECTION[pattern.category] ||\n      CATEGORY_TO_SECTION['other']\n    );\n  }\n\n  /**\n   * Builds the prompt for rule generation\n   */\n  private async buildPrompt(pattern: FailurePattern): Promise<string> {\n    const template = await this.loadPromptTemplate();\n    const targetSection = this.getTargetSection(pattern);\n\n    // Get current instructions for the target section\n    const sectionKey = targetSection.split('.')[0];\n    const currentInstructions =\n      this.currentInstructions.get(sectionKey) ||\n      '(Instructions not loaded)';\n\n    // Format failures\n    const failuresFormatted = pattern.failures\n      .slice(0, 5) // Limit to 5 examples\n      .map((f, i) => {\n        const evalName =\n          (f.failureInput.metadata?.evalName as string) ||\n          f.failureInput.id;\n        return `#### Failure ${i + 1}\n- **Eval**: ${evalName}\n- **What Went Wrong**: ${f.explanation.whatWentWrong}\n- **Why It Failed**: ${f.explanation.whyItFailed}\n- **Suggested Fix**: ${f.explanation.suggestedFix}`;\n      })\n      .join('\\n\\n');\n\n    // Replace template variables\n    let prompt = template\n      .replace('{{targetSection}}', targetSection)\n      .replace('{{currentInstructions}}', currentInstructions)\n      .replace('{{patternName}}', pattern.patternName)\n      .replace('{{patternCategory}}', pattern.category)\n      .replace('{{frequency}}', pattern.frequency.toString())\n      .replace('{{affectedComponents}}', pattern.affectedComponents.join(', ') || 'None specified')\n      .replace('{{commonRootCauses}}', pattern.commonRootCauses.join('\\n- ') || 'None identified');\n\n    // Handle the failures loop\n    prompt = prompt.replace(\n      /{{#each failures}}[\\s\\S]*?{{\\/each}}/g,\n      failuresFormatted\n    );\n\n    return prompt;\n  }\n\n  /**\n   * Parses the LLM response into a rule result\n   */\n  private parseResponse(text: string, pattern: FailurePattern): RuleGenerationResult {\n    // Try to extract JSON from markdown code block\n    const jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n    const jsonContent = jsonMatch ? jsonMatch[1] : text;\n\n    try {\n      const parsed = JSON.parse(jsonContent.trim());\n\n      // Get failure IDs for expected impact\n      const evalIds = pattern.failures\n        .slice(0, 10)\n        .map((f) => f.failureInput.id);\n\n      return {\n        rule: parsed.rule || 'No rule generated',\n        targetSection: parsed.targetSection || this.getTargetSection(pattern),\n        placement: parsed.placement,\n        rationale: parsed.rationale || 'No rationale provided',\n        expectedImpact: {\n          evalIds: parsed.expectedImpact?.evalIds || evalIds,\n          confidenceScore: Math.max(\n            0,\n            Math.min(1, parsed.expectedImpact?.confidenceScore || 0.5)\n          ),\n        },\n      };\n    } catch (error) {\n      console.warn('Failed to parse rule generation response:', text.substring(0, 200));\n      return {\n        rule: text.substring(0, 500),\n        targetSection: this.getTargetSection(pattern),\n        rationale: 'Failed to parse structured response',\n        expectedImpact: {\n          evalIds: pattern.failures.slice(0, 5).map((f) => f.failureInput.id),\n          confidenceScore: 0.3,\n        },\n      };\n    }\n  }\n\n  /**\n   * Generates a rule for a single pattern\n   */\n  async generateRule(pattern: FailurePattern): Promise<ProposedRule> {\n    const prompt = await this.buildPrompt(pattern);\n\n    try {\n      const client = await this.getAnthropicClient();\n      const response = await client.messages.create({\n        model: this.config.ruleGenerationModel,\n        max_tokens: 1024,\n        messages: [{ role: 'user', content: prompt }],\n      });\n\n      const content = response.content[0];\n      if (content.type !== 'text') {\n        throw new Error('Unexpected response type from LLM');\n      }\n\n      const result = this.parseResponse(content.text, pattern);\n\n      return {\n        ruleId: `rule-${pattern.patternId}`,\n        ruleContent: result.rule,\n        targetSection: result.targetSection,\n        placement: result.placement,\n        rationale: result.rationale,\n        addressesPatterns: [pattern.patternId],\n        expectedImpact: {\n          failureIds: result.expectedImpact.evalIds,\n          confidenceScore: result.expectedImpact.confidenceScore,\n        },\n        status: 'pending',\n        generatedAt: new Date().toISOString(),\n        model: this.config.ruleGenerationModel,\n        source: `iteration-${new Date().toISOString().split('T')[0]}`,\n      };\n    } catch (error) {\n      console.error(`Failed to generate rule for pattern ${pattern.patternId}:`, error);\n\n      return {\n        ruleId: `rule-${pattern.patternId}`,\n        ruleContent: `[Generation failed: ${error instanceof Error ? error.message : 'Unknown error'}]`,\n        targetSection: this.getTargetSection(pattern),\n        rationale: 'Rule generation failed',\n        addressesPatterns: [pattern.patternId],\n        expectedImpact: {\n          failureIds: [],\n          confidenceScore: 0,\n        },\n        status: 'pending',\n        generatedAt: new Date().toISOString(),\n        model: this.config.ruleGenerationModel,\n        source: `iteration-${new Date().toISOString().split('T')[0]}`,\n      };\n    }\n  }\n\n  /**\n   * Generates rules for multiple patterns\n   */\n  async generateRules(\n    patterns: FailurePattern[],\n    options?: {\n      maxRules?: number;\n      onProgress?: (completed: number, total: number) => void;\n    }\n  ): Promise<ProposedRule[]> {\n    // Load current instructions first\n    await this.loadCurrentInstructions();\n\n    // Limit patterns to process\n    const maxRules = options?.maxRules ?? this.config.maxRulesPerIteration;\n    const patternsToProcess = patterns.slice(0, maxRules);\n\n    const rules: ProposedRule[] = [];\n\n    for (let i = 0; i < patternsToProcess.length; i++) {\n      const pattern = patternsToProcess[i];\n      const rule = await this.generateRule(pattern);\n      rules.push(rule);\n\n      options?.onProgress?.(i + 1, patternsToProcess.length);\n    }\n\n    return rules;\n  }\n\n  /**\n   * Filters rules by confidence\n   */\n  filterByConfidence(\n    rules: ProposedRule[],\n    minConfidence?: number\n  ): ProposedRule[] {\n    const threshold = minConfidence ?? this.config.minRuleConfidence;\n    return rules.filter(\n      (r) => r.expectedImpact.confidenceScore >= threshold\n    );\n  }\n\n  /**\n   * Checks for conflicts between a new rule and existing rules\n   */\n  checkForConflicts(\n    newRule: ProposedRule,\n    existingRules: ProposedRule[]\n  ): { hasConflict: boolean; conflictingRules: ProposedRule[] } {\n    const conflicting = existingRules.filter((existing) => {\n      // Same target section\n      if (existing.targetSection !== newRule.targetSection) {\n        return false;\n      }\n\n      // Check for contradictory keywords\n      const newLower = newRule.ruleContent.toLowerCase();\n      const existingLower = existing.ruleContent.toLowerCase();\n\n      // Simple conflict detection: opposite instructions\n      const hasAlways = newLower.includes('always');\n      const hasNever = newLower.includes('never');\n      const existingHasAlways = existingLower.includes('always');\n      const existingHasNever = existingLower.includes('never');\n\n      if ((hasAlways && existingHasNever) || (hasNever && existingHasAlways)) {\n        // Check if they're about the same topic (rough heuristic)\n        const newWords = new Set(newLower.split(/\\s+/).filter(w => w.length > 4));\n        const existingWords = new Set(existingLower.split(/\\s+/).filter(w => w.length > 4));\n        const commonWords = [...newWords].filter(w => existingWords.has(w));\n\n        if (commonWords.length > 2) {\n          return true;\n        }\n      }\n\n      return false;\n    });\n\n    return {\n      hasConflict: conflicting.length > 0,\n      conflictingRules: conflicting,\n    };\n  }\n}\n\nexport default RuleGenerator;\n","/**\n * Interactive CLI for reviewing proposed rules.\n * Provides a human-in-the-loop interface for approving/rejecting rules.\n */\n\nimport * as readline from 'readline';\nimport type { ProposedRule, FailurePattern } from './types.js';\n\nexport interface ReviewDecision {\n  rule: ProposedRule;\n  decision: 'approve' | 'reject' | 'modify' | 'skip';\n  notes?: string;\n  modifiedRule?: string;\n}\n\nexport interface ReviewSession {\n  decisions: ReviewDecision[];\n  approved: ProposedRule[];\n  rejected: ProposedRule[];\n  skipped: ProposedRule[];\n}\n\n/**\n * Formats a rule for display\n */\nfunction formatRuleDisplay(rule: ProposedRule, index: number, total: number): string {\n  const header = `\n\n  PROMPT LEARNING: RULE REVIEW (${index + 1}/${total})\n`;\n\n  const ruleBox = `\n\n ${rule.ruleContent.split('\\n').map(line => line.padEnd(63)).join('\\n ')}\n`;\n\n  const evidence = `\nEvidence:\n  - Pattern: ${rule.addressesPatterns.join(', ')}\n  - Target: ${rule.targetSection}\n  - Confidence: ${(rule.expectedImpact.confidenceScore * 100).toFixed(0)}%\n  - Affects: ${rule.expectedImpact.failureIds.slice(0, 3).join(', ')}${rule.expectedImpact.failureIds.length > 3 ? '...' : ''}\n\nRationale:\n  ${rule.rationale}`;\n\n  return header + '\\n' + ruleBox + evidence;\n}\n\n/**\n * Interactive CLI reviewer for proposed rules\n */\nexport class CLIReviewer {\n  private rl: readline.Interface | null = null;\n\n  /**\n   * Creates readline interface\n   */\n  private createInterface(): readline.Interface {\n    return readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n  }\n\n  /**\n   * Prompts user for input\n   */\n  private async prompt(question: string): Promise<string> {\n    return new Promise((resolve) => {\n      this.rl?.question(question, (answer) => {\n        resolve(answer.trim().toLowerCase());\n      });\n    });\n  }\n\n  /**\n   * Prompts for multi-line input\n   */\n  private async promptMultiline(prompt: string): Promise<string> {\n    console.log(prompt);\n    console.log('(Enter an empty line to finish)');\n\n    const lines: string[] = [];\n    let line = await this.prompt('> ');\n\n    while (line !== '') {\n      lines.push(line);\n      line = await this.prompt('> ');\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Reviews a single rule\n   */\n  private async reviewRule(\n    rule: ProposedRule,\n    index: number,\n    total: number\n  ): Promise<ReviewDecision> {\n    console.log(formatRuleDisplay(rule, index, total));\n    console.log('\\n[A]pprove  [R]eject  [M]odify  [S]kip  [Q]uit\\n');\n\n    const answer = await this.prompt('Your choice: ');\n\n    switch (answer) {\n      case 'a':\n      case 'approve':\n        const approveNotes = await this.prompt('Notes (optional): ');\n        return {\n          rule: { ...rule, status: 'approved' },\n          decision: 'approve',\n          notes: approveNotes || undefined,\n        };\n\n      case 'r':\n      case 'reject':\n        const rejectReason = await this.prompt('Reason for rejection: ');\n        return {\n          rule: { ...rule, status: 'rejected', reviewNotes: rejectReason },\n          decision: 'reject',\n          notes: rejectReason,\n        };\n\n      case 'm':\n      case 'modify':\n        console.log('\\nCurrent rule:');\n        console.log(rule.ruleContent);\n        const modified = await this.promptMultiline('\\nEnter modified rule:');\n        return {\n          rule: { ...rule, status: 'approved', ruleContent: modified },\n          decision: 'modify',\n          modifiedRule: modified,\n        };\n\n      case 's':\n      case 'skip':\n        return {\n          rule,\n          decision: 'skip',\n        };\n\n      case 'q':\n      case 'quit':\n        throw new Error('Review session aborted by user');\n\n      default:\n        console.log('Invalid choice. Please try again.');\n        return this.reviewRule(rule, index, total);\n    }\n  }\n\n  /**\n   * Starts an interactive review session\n   */\n  async startReviewSession(rules: ProposedRule[]): Promise<ReviewSession> {\n    if (rules.length === 0) {\n      console.log('No rules to review.');\n      return { decisions: [], approved: [], rejected: [], skipped: [] };\n    }\n\n    this.rl = this.createInterface();\n\n    console.log(`\\n`);\n    console.log(`              PROMPT LEARNING SYSTEM                            `);\n    console.log(`              Interactive Rule Review                           `);\n    console.log(``);\n    console.log(`  ${rules.length} rule(s) to review                                          `);\n    console.log(`                                                                `);\n    console.log(`  Commands:                                                     `);\n    console.log(`    [A]pprove - Accept the rule as-is                          `);\n    console.log(`    [R]eject  - Reject the rule with reason                    `);\n    console.log(`    [M]odify  - Edit the rule before approving                 `);\n    console.log(`    [S]kip    - Skip for now, review later                     `);\n    console.log(`    [Q]uit    - Exit review session                            `);\n    console.log(`\\n`);\n\n    const decisions: ReviewDecision[] = [];\n    const approved: ProposedRule[] = [];\n    const rejected: ProposedRule[] = [];\n    const skipped: ProposedRule[] = [];\n\n    try {\n      for (let i = 0; i < rules.length; i++) {\n        const decision = await this.reviewRule(rules[i], i, rules.length);\n        decisions.push(decision);\n\n        switch (decision.decision) {\n          case 'approve':\n          case 'modify':\n            approved.push(decision.rule);\n            break;\n          case 'reject':\n            rejected.push(decision.rule);\n            break;\n          case 'skip':\n            skipped.push(decision.rule);\n            break;\n        }\n      }\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('aborted')) {\n        console.log('\\nReview session aborted.');\n      } else {\n        throw error;\n      }\n    } finally {\n      this.rl?.close();\n      this.rl = null;\n    }\n\n    // Print summary\n    console.log('\\n');\n    console.log('  REVIEW SESSION COMPLETE');\n    console.log('');\n    console.log(`  Approved: ${approved.length}`);\n    console.log(`  Rejected: ${rejected.length}`);\n    console.log(`  Skipped:  ${skipped.length}`);\n    console.log('\\n');\n\n    return { decisions, approved, rejected, skipped };\n  }\n\n  /**\n   * Prints a summary of rules without interactive review\n   */\n  printRulesSummary(rules: ProposedRule[]): void {\n    console.log('\\n');\n    console.log('              PROPOSED RULES SUMMARY                            ');\n    console.log('\\n');\n\n    for (const [i, rule] of rules.entries()) {\n      console.log(`[${i + 1}] ${rule.ruleId}`);\n      console.log(`    Target: ${rule.targetSection}`);\n      console.log(`    Confidence: ${(rule.expectedImpact.confidenceScore * 100).toFixed(0)}%`);\n      console.log(`    Rule: ${rule.ruleContent.substring(0, 80)}...`);\n      console.log('');\n    }\n  }\n\n  /**\n   * Quick approve all rules (for non-interactive mode)\n   */\n  autoApproveAll(\n    rules: ProposedRule[],\n    minConfidence: number = 0.8\n  ): ReviewSession {\n    const decisions: ReviewDecision[] = [];\n    const approved: ProposedRule[] = [];\n    const rejected: ProposedRule[] = [];\n    const skipped: ProposedRule[] = [];\n\n    for (const rule of rules) {\n      if (rule.expectedImpact.confidenceScore >= minConfidence) {\n        const approvedRule = { ...rule, status: 'approved' as const };\n        decisions.push({ rule: approvedRule, decision: 'approve' });\n        approved.push(approvedRule);\n      } else {\n        decisions.push({ rule, decision: 'skip' });\n        skipped.push(rule);\n      }\n    }\n\n    return { decisions, approved, rejected, skipped };\n  }\n}\n\nexport default CLIReviewer;\n","/**\n * Writes approved rules to the learned-rules.json file.\n * Manages the rules storage lifecycle.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport type { ProposedRule, LearnedRulesFile, LearningHistory, LearningIterationResult } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\nexport class RuleWriter {\n  private config: LearningConfig;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  /**\n   * Ensures rules directories exist\n   */\n  async ensureDirectories(): Promise<void> {\n    await fs.mkdir(this.config.rulesDir, { recursive: true });\n    await fs.mkdir(this.config.pendingDir, { recursive: true });\n    await fs.mkdir(this.config.approvedDir, { recursive: true });\n    await fs.mkdir(this.config.rejectedDir, { recursive: true });\n  }\n\n  /**\n   * Reads the current learned rules file\n   */\n  async readLearnedRules(): Promise<LearnedRulesFile> {\n    try {\n      const content = await fs.readFile(this.config.learnedRulesPath, 'utf-8');\n      return JSON.parse(content) as LearnedRulesFile;\n    } catch {\n      // File doesn't exist or is invalid, return empty\n      return {\n        rules: [],\n        lastUpdated: new Date().toISOString(),\n        iterations: [],\n      };\n    }\n  }\n\n  /**\n   * Writes rules to the learned rules file\n   */\n  async writeLearnedRules(rules: LearnedRulesFile): Promise<void> {\n    await this.ensureDirectories();\n\n    const content = JSON.stringify(rules, null, 2);\n    await fs.writeFile(this.config.learnedRulesPath, content, 'utf-8');\n  }\n\n  /**\n   * Adds approved rules to the learned rules file\n   */\n  async addApprovedRules(\n    rules: ProposedRule[],\n    iterationId: string\n  ): Promise<void> {\n    const current = await this.readLearnedRules();\n\n    // Add new rules\n    for (const rule of rules) {\n      // Check if rule already exists (by ID)\n      const existingIndex = current.rules.findIndex(\n        (r) => r.ruleId === rule.ruleId\n      );\n\n      if (existingIndex >= 0) {\n        // Update existing rule\n        current.rules[existingIndex] = { ...rule, status: 'approved' };\n      } else {\n        // Add new rule\n        current.rules.push({ ...rule, status: 'approved' });\n      }\n    }\n\n    // Update metadata\n    current.lastUpdated = new Date().toISOString();\n    if (!current.iterations.includes(iterationId)) {\n      current.iterations.push(iterationId);\n    }\n\n    await this.writeLearnedRules(current);\n  }\n\n  /**\n   * Saves a rule to the pending directory for later review\n   */\n  async savePendingRule(rule: ProposedRule): Promise<string> {\n    await this.ensureDirectories();\n\n    const filename = `${rule.ruleId}.json`;\n    const filepath = path.join(this.config.pendingDir, filename);\n\n    await fs.writeFile(filepath, JSON.stringify(rule, null, 2), 'utf-8');\n\n    return filepath;\n  }\n\n  /**\n   * Saves multiple pending rules\n   */\n  async savePendingRules(rules: ProposedRule[]): Promise<string[]> {\n    const paths: string[] = [];\n    for (const rule of rules) {\n      const filepath = await this.savePendingRule(rule);\n      paths.push(filepath);\n    }\n    return paths;\n  }\n\n  /**\n   * Loads pending rules from the pending directory\n   */\n  async loadPendingRules(): Promise<ProposedRule[]> {\n    try {\n      const files = await fs.readdir(this.config.pendingDir);\n      const jsonFiles = files.filter((f) => f.endsWith('.json'));\n\n      const rules: ProposedRule[] = [];\n      for (const file of jsonFiles) {\n        const filepath = path.join(this.config.pendingDir, file);\n        const content = await fs.readFile(filepath, 'utf-8');\n        rules.push(JSON.parse(content) as ProposedRule);\n      }\n\n      return rules;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Moves a pending rule to approved\n   */\n  async approvePendingRule(ruleId: string): Promise<void> {\n    const pendingPath = path.join(this.config.pendingDir, `${ruleId}.json`);\n    const approvedPath = path.join(this.config.approvedDir, `${ruleId}.json`);\n\n    try {\n      const content = await fs.readFile(pendingPath, 'utf-8');\n      const rule = JSON.parse(content) as ProposedRule;\n      rule.status = 'approved';\n\n      await fs.writeFile(approvedPath, JSON.stringify(rule, null, 2), 'utf-8');\n      await fs.unlink(pendingPath);\n\n      // Also add to learned rules\n      await this.addApprovedRules([rule], `manual-${Date.now()}`);\n    } catch (error) {\n      throw new Error(`Failed to approve rule ${ruleId}: ${error}`);\n    }\n  }\n\n  /**\n   * Moves a pending rule to rejected\n   */\n  async rejectPendingRule(ruleId: string, reason: string): Promise<void> {\n    const pendingPath = path.join(this.config.pendingDir, `${ruleId}.json`);\n    const rejectedPath = path.join(this.config.rejectedDir, `${ruleId}.json`);\n\n    try {\n      const content = await fs.readFile(pendingPath, 'utf-8');\n      const rule = JSON.parse(content) as ProposedRule;\n      rule.status = 'rejected';\n      rule.reviewNotes = reason;\n\n      await fs.writeFile(rejectedPath, JSON.stringify(rule, null, 2), 'utf-8');\n      await fs.unlink(pendingPath);\n    } catch (error) {\n      throw new Error(`Failed to reject rule ${ruleId}: ${error}`);\n    }\n  }\n\n  /**\n   * Clears all pending rules\n   */\n  async clearPendingRules(): Promise<number> {\n    try {\n      const files = await fs.readdir(this.config.pendingDir);\n      for (const file of files) {\n        await fs.unlink(path.join(this.config.pendingDir, file));\n      }\n      return files.length;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Reads the learning history\n   */\n  async readHistory(): Promise<LearningHistory> {\n    try {\n      const content = await fs.readFile(this.config.historyPath, 'utf-8');\n      return JSON.parse(content) as LearningHistory;\n    } catch {\n      return {\n        iterations: [],\n        totalRulesGenerated: 0,\n        totalRulesApproved: 0,\n        totalRulesRejected: 0,\n        lastRunAt: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Writes the learning history\n   */\n  async writeHistory(history: LearningHistory): Promise<void> {\n    await this.ensureDirectories();\n    await fs.writeFile(\n      this.config.historyPath,\n      JSON.stringify(history, null, 2),\n      'utf-8'\n    );\n  }\n\n  /**\n   * Adds a learning iteration to the history\n   */\n  async addIterationToHistory(\n    iteration: LearningIterationResult\n  ): Promise<void> {\n    const history = await this.readHistory();\n\n    history.iterations.push(iteration);\n    history.totalRulesGenerated += iteration.rulesProposed.length;\n    history.totalRulesApproved += iteration.rulesApproved.length;\n    history.totalRulesRejected += iteration.rulesRejected.length;\n    history.lastRunAt = iteration.timestamp;\n\n    await this.writeHistory(history);\n  }\n\n  /**\n   * Gets statistics about stored rules\n   */\n  async getStats(): Promise<{\n    totalRules: number;\n    pendingCount: number;\n    approvedCount: number;\n    rejectedCount: number;\n    iterationsCount: number;\n  }> {\n    const rules = await this.readLearnedRules();\n    const pending = await this.loadPendingRules();\n    const history = await this.readHistory();\n\n    let approvedCount = 0;\n    let rejectedCount = 0;\n\n    try {\n      approvedCount = (await fs.readdir(this.config.approvedDir)).length;\n    } catch {\n      // Directory doesn't exist\n    }\n\n    try {\n      rejectedCount = (await fs.readdir(this.config.rejectedDir)).length;\n    } catch {\n      // Directory doesn't exist\n    }\n\n    return {\n      totalRules: rules.rules.length,\n      pendingCount: pending.length,\n      approvedCount,\n      rejectedCount,\n      iterationsCount: history.iterations.length,\n    };\n  }\n}\n\nexport default RuleWriter;\n","/**\n * Learning Loop Runner\n * Orchestrates the full prompt learning pipeline.\n */\n\nimport { collectFromSources, getSourceStats } from './data-sources/index.js';\nimport { ExplanationGenerator } from './explanation-generator.js';\nimport { PatternDetector } from './pattern-detector.js';\nimport { RuleGenerator } from './rule-generator.js';\nimport { CLIReviewer } from './cli-reviewer.js';\nimport { RuleWriter } from './rule-writer.js';\nimport type {\n  FailureInput,\n  FailureExplanation,\n  FailurePattern,\n  ProposedRule,\n  LearningIterationResult,\n  CollectOptions,\n} from './types.js';\nimport { getLearningConfig, getConfigFromEnv, type LearningConfig } from './config';\n\nexport interface LearningOptions {\n  /** Data sources to use */\n  sources?: string[];\n\n  /** Options for collecting failures */\n  collectOptions?: CollectOptions;\n\n  /** Project ID for production data source (fetches from S3) */\n  projectId?: string;\n\n  /** Task ID for production data source (optional) */\n  taskId?: string;\n\n  /** Skip interactive review (use auto-approve) */\n  autoApprove?: boolean;\n\n  /** Minimum confidence for auto-approve */\n  autoApproveThreshold?: number;\n\n  /** Save pending rules for later review */\n  savePending?: boolean;\n\n  /** Run validation after applying rules */\n  validate?: boolean;\n\n  /** Progress callback */\n  onProgress?: (stage: string, progress: number, total: number) => void;\n}\n\nexport class LearningRunner {\n  private config: LearningConfig;\n  private explanationGenerator: ExplanationGenerator;\n  private patternDetector: PatternDetector;\n  private ruleGenerator: RuleGenerator;\n  private cliReviewer: CLIReviewer;\n  private ruleWriter: RuleWriter;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig({ ...getConfigFromEnv(), ...config });\n    this.explanationGenerator = new ExplanationGenerator(this.config);\n    this.patternDetector = new PatternDetector(this.config);\n    this.ruleGenerator = new RuleGenerator(this.config);\n    this.cliReviewer = new CLIReviewer();\n    this.ruleWriter = new RuleWriter(this.config);\n  }\n\n  /**\n   * Runs a full learning iteration\n   */\n  async runIteration(options: LearningOptions = {}): Promise<LearningIterationResult> {\n    const startTime = Date.now();\n    const iterationId = `iteration-${new Date().toISOString().replace(/[:.]/g, '-')}`;\n\n    console.log('\\n');\n    console.log('              PROMPT LEARNING SYSTEM                            ');\n    console.log('              Starting Learning Iteration                       ');\n    console.log('\\n');\n\n    // Phase 1: Collect failures\n    console.log(' Phase 1: Collecting failures...');\n    const sources = options.sources || ['eval', 'jsonl'];\n\n    // Merge projectId and taskId into collectOptions for production source\n    const collectOptions: CollectOptions = {\n      ...options.collectOptions,\n      projectId: options.projectId,\n      taskId: options.taskId,\n    };\n\n    const failures = await collectFromSources(sources, collectOptions);\n    console.log(`   Found ${failures.length} failures from ${sources.join(', ')}`);\n\n    if (failures.length === 0) {\n      console.log('\\n No failures to analyze. System is performing well!\\n');\n      return this.createEmptyResult(iterationId, startTime, sources);\n    }\n\n    // Phase 2: Generate explanations\n    console.log('\\n Phase 2: Generating failure explanations...');\n    const explanations = await this.explanationGenerator.generateExplanations(\n      failures,\n      {\n        concurrency: 3,\n        onProgress: (completed, total) => {\n          process.stdout.write(`\\r   Progress: ${completed}/${total}`);\n          options.onProgress?.('explanations', completed, total);\n        },\n      }\n    );\n    console.log(`\\n   Generated ${explanations.length} explanations`);\n\n    // Phase 3: Detect patterns\n    console.log('\\n Phase 3: Detecting patterns...');\n    const patterns = this.patternDetector.detectPatterns(explanations);\n    console.log(`   Detected ${patterns.length} patterns`);\n\n    if (patterns.length === 0) {\n      console.log('\\n  No patterns detected. Failures may be too diverse.\\n');\n      return this.createResult(\n        iterationId,\n        startTime,\n        sources,\n        failures.length,\n        explanations.length,\n        [],\n        [],\n        [],\n        []\n      );\n    }\n\n    // Print pattern summary\n    this.printPatternSummary(patterns);\n\n    // Phase 4: Generate rules\n    console.log('\\n Phase 4: Generating rules...');\n    const proposedRules = await this.ruleGenerator.generateRules(patterns, {\n      maxRules: this.config.maxRulesPerIteration,\n      onProgress: (completed, total) => {\n        process.stdout.write(`\\r   Progress: ${completed}/${total}`);\n        options.onProgress?.('rules', completed, total);\n      },\n    });\n    console.log(`\\n   Generated ${proposedRules.length} proposed rules`);\n\n    // Filter low-confidence rules\n    const filteredRules = this.ruleGenerator.filterByConfidence(proposedRules);\n    console.log(`   ${filteredRules.length} rules pass confidence threshold`);\n\n    if (filteredRules.length === 0) {\n      console.log('\\n  No rules passed confidence threshold.\\n');\n      return this.createResult(\n        iterationId,\n        startTime,\n        sources,\n        failures.length,\n        explanations.length,\n        patterns,\n        proposedRules,\n        [],\n        []\n      );\n    }\n\n    // Phase 5: Human review or auto-approve\n    let approvedRules: ProposedRule[] = [];\n    let rejectedRules: ProposedRule[] = [];\n\n    if (options.autoApprove) {\n      console.log('\\n Phase 5: Auto-approving rules...');\n      const session = this.cliReviewer.autoApproveAll(\n        filteredRules,\n        options.autoApproveThreshold || 0.8\n      );\n      approvedRules = session.approved;\n      rejectedRules = session.rejected;\n      console.log(`   Auto-approved: ${approvedRules.length}, Skipped: ${session.skipped.length}`);\n    } else if (options.savePending) {\n      console.log('\\n Phase 5: Saving rules for later review...');\n      await this.ruleWriter.savePendingRules(filteredRules);\n      console.log(`   Saved ${filteredRules.length} rules to pending/`);\n      console.log('   Run \"npm run learn:review\" to review them');\n    } else {\n      console.log('\\n Phase 5: Interactive review...');\n      const session = await this.cliReviewer.startReviewSession(filteredRules);\n      approvedRules = session.approved;\n      rejectedRules = session.rejected;\n    }\n\n    // Phase 6: Save approved rules\n    if (approvedRules.length > 0) {\n      console.log('\\n Phase 6: Saving approved rules...');\n      await this.ruleWriter.addApprovedRules(approvedRules, iterationId);\n      console.log(`   Saved ${approvedRules.length} rules to learned-rules.json`);\n    }\n\n    // Create and save iteration result\n    const result = this.createResult(\n      iterationId,\n      startTime,\n      sources,\n      failures.length,\n      explanations.length,\n      patterns,\n      proposedRules,\n      approvedRules,\n      rejectedRules\n    );\n\n    await this.ruleWriter.addIterationToHistory(result);\n\n    // Print summary\n    this.printIterationSummary(result);\n\n    return result;\n  }\n\n  /**\n   * Analyzes failures without generating rules\n   */\n  async analyze(options: LearningOptions = {}): Promise<{\n    failures: FailureInput[];\n    explanations: FailureExplanation[];\n    patterns: FailurePattern[];\n  }> {\n    console.log('\\n ANALYZE MODE: Collecting and analyzing failures...\\n');\n\n    const sources = options.sources || ['eval', 'jsonl'];\n\n    // Merge projectId and taskId into collectOptions for production source\n    const collectOptions: CollectOptions = {\n      ...options.collectOptions,\n      projectId: options.projectId,\n      taskId: options.taskId,\n    };\n\n    const failures = await collectFromSources(sources, collectOptions);\n    console.log(`Found ${failures.length} failures`);\n\n    if (failures.length === 0) {\n      return { failures: [], explanations: [], patterns: [] };\n    }\n\n    const explanations = await this.explanationGenerator.generateExplanations(\n      failures,\n      { concurrency: 3 }\n    );\n    console.log(`Generated ${explanations.length} explanations`);\n\n    const patterns = this.patternDetector.detectPatterns(explanations);\n    console.log(`Detected ${patterns.length} patterns`);\n\n    this.printPatternSummary(patterns);\n\n    return { failures, explanations, patterns };\n  }\n\n  /**\n   * Reviews pending rules\n   */\n  async reviewPending(): Promise<void> {\n    const pending = await this.ruleWriter.loadPendingRules();\n\n    if (pending.length === 0) {\n      console.log('No pending rules to review.');\n      return;\n    }\n\n    const session = await this.cliReviewer.startReviewSession(pending);\n\n    // Process decisions\n    for (const decision of session.decisions) {\n      if (decision.decision === 'approve' || decision.decision === 'modify') {\n        await this.ruleWriter.approvePendingRule(decision.rule.ruleId);\n      } else if (decision.decision === 'reject') {\n        await this.ruleWriter.rejectPendingRule(\n          decision.rule.ruleId,\n          decision.notes || 'Rejected'\n        );\n      }\n      // Skip leaves the rule in pending\n    }\n\n    console.log(`\\nApproved: ${session.approved.length}`);\n    console.log(`Rejected: ${session.rejected.length}`);\n    console.log(`Remaining pending: ${session.skipped.length}`);\n  }\n\n  /**\n   * Shows current stats\n   */\n  async showStats(): Promise<void> {\n    console.log('\\n');\n    console.log('              PROMPT LEARNING SYSTEM STATUS                     ');\n    console.log('\\n');\n\n    // Source stats\n    const sourceStats = await getSourceStats();\n    console.log('Data Sources:');\n    for (const [name, stats] of Object.entries(sourceStats)) {\n      const status = stats.available ? '' : '';\n      const count = stats.failureCount !== undefined ? ` (${stats.failureCount} failures)` : '';\n      console.log(`  ${status} ${name}${count}`);\n\n      // Show JSONL details if available\n      if (stats.details) {\n        console.log(`      Projects: ${stats.details.projects}`);\n        console.log(`      Files: ${stats.details.files}`);\n        console.log(`      Sessions: ${stats.details.sessions}`);\n      }\n    }\n\n    // Rule stats\n    const ruleStats = await this.ruleWriter.getStats();\n    console.log('\\nRules:');\n    console.log(`  Total learned: ${ruleStats.totalRules}`);\n    console.log(`  Pending review: ${ruleStats.pendingCount}`);\n    console.log(`  Approved: ${ruleStats.approvedCount}`);\n    console.log(`  Rejected: ${ruleStats.rejectedCount}`);\n    console.log(`  Iterations: ${ruleStats.iterationsCount}`);\n\n    console.log('');\n  }\n\n  /**\n   * Creates an empty result for no-failures case\n   */\n  private createEmptyResult(\n    iterationId: string,\n    startTime: number,\n    sources: string[]\n  ): LearningIterationResult {\n    return {\n      iterationId,\n      timestamp: new Date().toISOString(),\n      sources,\n      failuresCollected: 0,\n      explanationsGenerated: 0,\n      patternsDetected: [],\n      rulesProposed: [],\n      rulesApproved: [],\n      rulesRejected: [],\n      durationMs: Date.now() - startTime,\n    };\n  }\n\n  /**\n   * Creates a full result\n   */\n  private createResult(\n    iterationId: string,\n    startTime: number,\n    sources: string[],\n    failuresCollected: number,\n    explanationsGenerated: number,\n    patterns: FailurePattern[],\n    proposed: ProposedRule[],\n    approved: ProposedRule[],\n    rejected: ProposedRule[]\n  ): LearningIterationResult {\n    return {\n      iterationId,\n      timestamp: new Date().toISOString(),\n      sources,\n      failuresCollected,\n      explanationsGenerated,\n      patternsDetected: patterns,\n      rulesProposed: proposed,\n      rulesApproved: approved,\n      rulesRejected: rejected,\n      durationMs: Date.now() - startTime,\n    };\n  }\n\n  /**\n   * Prints pattern summary\n   */\n  private printPatternSummary(patterns: FailurePattern[]): void {\n    console.log('\\n   Patterns detected:');\n    for (const pattern of patterns.slice(0, 5)) {\n      console.log(`     - ${pattern.patternName} (${pattern.frequency} failures)`);\n    }\n    if (patterns.length > 5) {\n      console.log(`     ... and ${patterns.length - 5} more`);\n    }\n  }\n\n  /**\n   * Prints iteration summary\n   */\n  private printIterationSummary(result: LearningIterationResult): void {\n    console.log('\\n');\n    console.log('  LEARNING ITERATION COMPLETE');\n    console.log('');\n    console.log(`  Iteration ID: ${result.iterationId}`);\n    console.log(`  Duration: ${(result.durationMs / 1000).toFixed(1)}s`);\n    console.log('');\n    console.log(`  Failures analyzed: ${result.failuresCollected}`);\n    console.log(`  Explanations generated: ${result.explanationsGenerated}`);\n    console.log(`  Patterns detected: ${result.patternsDetected.length}`);\n    console.log(`  Rules proposed: ${result.rulesProposed.length}`);\n    console.log(`  Rules approved: ${result.rulesApproved.length}`);\n    console.log(`  Rules rejected: ${result.rulesRejected.length}`);\n    console.log('');\n    console.log('  Next steps:');\n    console.log('    1. Review learned-rules.json');\n    console.log('    2. Manually integrate approved rules into prompt-templates.ts');\n    console.log('    3. Run evals to validate improvements');\n    console.log('\\n');\n  }\n}\n\nexport default LearningRunner;\n","import type { EvalCase, EvalCaseResult } from './schemas.js';\nimport type { Judge } from '../judges/judge-interface.js';\n\nexport interface ToolCall {\n  toolName: string;\n  input: unknown;\n  output?: unknown;\n  isError?: boolean;\n}\n\nexport interface AgentContext {\n  workingDirectory: string;\n  evalId: string;\n  evalName: string;\n  sessionId?: string;\n  timeout?: number;\n}\n\nexport interface AgentResult {\n  output: string;\n  success: boolean;\n  toolCalls?: ToolCall[];\n  sessionId?: string;\n  error?: Error;\n  duration?: number;\n  numTurns?: number;\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalCostUsd?: number;\n  };\n}\n\nexport type AgentFunction = (\n  prompt: string,\n  context: AgentContext\n) => Promise<AgentResult>;\n\nexport type AgentType = 'claude-code' | 'claude-sdk' | 'generic';\n\nexport interface LearningConfig {\n  enabled?: boolean;\n  ruleOutputDir?: string;\n  minFailuresForPattern?: number;\n  similarityThreshold?: number;\n  maxRulesPerIteration?: number;\n  minRuleConfidence?: number;\n  autoApprove?: boolean;\n  autoApproveThreshold?: number;\n}\n\nexport interface VibeCheckConfig {\n  agent: AgentFunction;\n  agentType?: AgentType;\n  testMatch?: string[];\n  testDir?: string;\n  parallel?: boolean;\n  maxConcurrency?: number;\n  timeout?: number;\n  maxRetries?: number;\n  retryDelayMs?: number;\n  retryBackoffMultiplier?: number;\n  trials?: number;\n  trialPassThreshold?: number;\n  judges?: Judge[];\n  llmJudgeModel?: string;\n  rubricsDir?: string;\n  outputDir?: string;\n  verbose?: boolean;\n  workspaceTemplate?: string;\n  preserveWorkspaces?: boolean;\n  learning?: LearningConfig;\n  setup?: () => Promise<void>;\n  teardown?: () => Promise<void>;\n  beforeEach?: (evalCase: EvalCase) => Promise<void>;\n  afterEach?: (result: EvalCaseResult) => Promise<void>;\n}\n\nexport interface ResolvedConfig extends Required<Omit<VibeCheckConfig, 'setup' | 'teardown' | 'beforeEach' | 'afterEach' | 'learning' | 'judges' | 'workspaceTemplate'>> {\n  setup?: () => Promise<void>;\n  teardown?: () => Promise<void>;\n  beforeEach?: (evalCase: EvalCase) => Promise<void>;\n  afterEach?: (result: EvalCaseResult) => Promise<void>;\n  learning: Required<LearningConfig>;\n  judges: Judge[];\n  workspaceTemplate?: string;\n}\n\nexport function defineConfig(config: VibeCheckConfig): VibeCheckConfig {\n  return config;\n}\n\nexport const defaultConfig: Omit<ResolvedConfig, 'agent'> = {\n  agentType: 'generic',\n  testMatch: ['**/*.eval.json'],\n  testDir: './__evals__',\n  parallel: true,\n  maxConcurrency: 3,\n  timeout: 300000,\n  maxRetries: 2,\n  retryDelayMs: 1000,\n  retryBackoffMultiplier: 2,\n  trials: 1,\n  trialPassThreshold: 0.5,\n  judges: [],\n  llmJudgeModel: 'claude-sonnet-4-20250514',\n  rubricsDir: './__evals__/rubrics',\n  outputDir: './__evals__/results',\n  verbose: false,\n  preserveWorkspaces: false,\n  learning: {\n    enabled: false,\n    ruleOutputDir: './prompts',\n    minFailuresForPattern: 2,\n    similarityThreshold: 0.7,\n    maxRulesPerIteration: 5,\n    minRuleConfidence: 0.6,\n    autoApprove: false,\n    autoApproveThreshold: 0.8,\n  },\n};\n","import * as path from 'path';\nimport * as fs from 'fs/promises';\nimport { pathToFileURL } from 'url';\nimport type { VibeCheckConfig, ResolvedConfig } from './types.js';\nimport { defaultConfig } from './types.js';\n\nconst CONFIG_FILE_NAMES = [\n  'vibe-check.config.ts',\n  'vibe-check.config.js',\n  'vibe-check.config.mjs',\n];\n\nexport async function loadConfig(configPath?: string): Promise<ResolvedConfig> {\n  const cwd = process.cwd();\n\n  let configFile: string | undefined;\n\n  if (configPath) {\n    configFile = path.isAbsolute(configPath) ? configPath : path.join(cwd, configPath);\n  } else {\n    for (const name of CONFIG_FILE_NAMES) {\n      const candidate = path.join(cwd, name);\n      try {\n        await fs.access(candidate);\n        configFile = candidate;\n        break;\n      } catch {\n        // Continue to next candidate\n      }\n    }\n  }\n\n  if (!configFile) {\n    throw new Error(\n      `No config file found. Create one of: ${CONFIG_FILE_NAMES.join(', ')}`\n    );\n  }\n\n  const userConfig = await importConfig(configFile);\n\n  if (!userConfig.agent) {\n    throw new Error('Config must specify an \"agent\" function');\n  }\n\n  return resolveConfig(userConfig);\n}\n\nasync function importConfig(configPath: string): Promise<VibeCheckConfig> {\n  const fileUrl = pathToFileURL(configPath).href;\n\n  try {\n    const module = await import(fileUrl);\n    return module.default || module;\n  } catch (error) {\n    if (configPath.endsWith('.ts')) {\n      throw new Error(\n        `Failed to import TypeScript config. Run with tsx: npx vibe-check\\n${error}`\n      );\n    }\n    throw error;\n  }\n}\n\nfunction resolveConfig(userConfig: VibeCheckConfig): ResolvedConfig {\n  return {\n    agent: userConfig.agent,\n    agentType: userConfig.agentType ?? defaultConfig.agentType,\n    testMatch: userConfig.testMatch ?? defaultConfig.testMatch,\n    testDir: userConfig.testDir ?? defaultConfig.testDir,\n    parallel: userConfig.parallel ?? defaultConfig.parallel,\n    maxConcurrency: userConfig.maxConcurrency ?? defaultConfig.maxConcurrency,\n    timeout: userConfig.timeout ?? defaultConfig.timeout,\n    maxRetries: userConfig.maxRetries ?? defaultConfig.maxRetries,\n    retryDelayMs: userConfig.retryDelayMs ?? defaultConfig.retryDelayMs,\n    retryBackoffMultiplier: userConfig.retryBackoffMultiplier ?? defaultConfig.retryBackoffMultiplier,\n    trials: userConfig.trials ?? defaultConfig.trials,\n    trialPassThreshold: userConfig.trialPassThreshold ?? defaultConfig.trialPassThreshold,\n    judges: userConfig.judges ?? defaultConfig.judges,\n    llmJudgeModel: userConfig.llmJudgeModel ?? defaultConfig.llmJudgeModel,\n    rubricsDir: userConfig.rubricsDir ?? defaultConfig.rubricsDir,\n    outputDir: userConfig.outputDir ?? defaultConfig.outputDir,\n    verbose: userConfig.verbose ?? defaultConfig.verbose,\n    workspaceTemplate: userConfig.workspaceTemplate,\n    preserveWorkspaces: userConfig.preserveWorkspaces ?? defaultConfig.preserveWorkspaces,\n    learning: {\n      enabled: userConfig.learning?.enabled ?? defaultConfig.learning.enabled,\n      ruleOutputDir: userConfig.learning?.ruleOutputDir ?? defaultConfig.learning.ruleOutputDir,\n      minFailuresForPattern: userConfig.learning?.minFailuresForPattern ?? defaultConfig.learning.minFailuresForPattern,\n      similarityThreshold: userConfig.learning?.similarityThreshold ?? defaultConfig.learning.similarityThreshold,\n      maxRulesPerIteration: userConfig.learning?.maxRulesPerIteration ?? defaultConfig.learning.maxRulesPerIteration,\n      minRuleConfidence: userConfig.learning?.minRuleConfidence ?? defaultConfig.learning.minRuleConfidence,\n      autoApprove: userConfig.learning?.autoApprove ?? defaultConfig.learning.autoApprove,\n      autoApproveThreshold: userConfig.learning?.autoApproveThreshold ?? defaultConfig.learning.autoApproveThreshold,\n    },\n    setup: userConfig.setup,\n    teardown: userConfig.teardown,\n    beforeEach: userConfig.beforeEach,\n    afterEach: userConfig.afterEach,\n  };\n}\n","import type { EvalCase, EvalCaseResult, EvalCategory, JudgeResult } from '../config/schemas.js';\nimport type { ResolvedConfig } from '../config/types.js';\nimport { isMultiTurnEval } from '../config/schemas.js';\nimport { TestHarness } from '../harness/test-harness.js';\nimport { getJudgeRegistry } from '../judges/judge-registry.js';\nimport type { JudgeContext, ExecutionResult } from '../judges/judge-interface.js';\nimport { loadEvalCases } from '../utils/eval-loader.js';\n\nexport interface RunnerOptions {\n  categories?: EvalCategory[];\n  tags?: string[];\n  ids?: string[];\n}\n\nexport interface EvalSuiteResult {\n  runId: string;\n  total: number;\n  passed: number;\n  failed: number;\n  skipped: number;\n  errors: number;\n  passRate: number;\n  results: EvalCaseResult[];\n  duration: number;\n  timestamp: string;\n}\n\nexport class EvalRunner {\n  private config: ResolvedConfig;\n  private harness: TestHarness;\n\n  constructor(config: ResolvedConfig) {\n    this.config = config;\n    this.harness = new TestHarness({ config });\n  }\n\n  async run(options: RunnerOptions = {}): Promise<EvalSuiteResult> {\n    const startTime = Date.now();\n    const runId = `run-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n\n    if (this.config.setup) {\n      await this.config.setup();\n    }\n\n    const evalCases = await loadEvalCases({\n      testDir: this.config.testDir,\n      testMatch: this.config.testMatch,\n      categories: options.categories,\n      tags: options.tags,\n      ids: options.ids,\n      enabledOnly: true,\n    });\n\n    if (this.config.verbose) {\n      console.log(`Found ${evalCases.length} eval cases to run`);\n    }\n\n    const results: EvalCaseResult[] = [];\n\n    if (this.config.parallel && evalCases.length > 1) {\n      results.push(...await this.runParallel(evalCases));\n    } else {\n      results.push(...await this.runSequential(evalCases));\n    }\n\n    if (this.config.teardown) {\n      await this.config.teardown();\n    }\n\n    await this.harness.cleanup();\n\n    const passed = results.filter(r => r.success).length;\n    const failed = results.filter(r => !r.success && !r.error).length;\n    const errors = results.filter(r => r.error).length;\n\n    return {\n      runId,\n      total: results.length,\n      passed,\n      failed,\n      skipped: 0,\n      errors,\n      passRate: results.length > 0 ? passed / results.length : 0,\n      results,\n      duration: Date.now() - startTime,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  private async runParallel(evalCases: EvalCase[]): Promise<EvalCaseResult[]> {\n    const results: EvalCaseResult[] = [];\n    const { maxConcurrency } = this.config;\n\n    for (let i = 0; i < evalCases.length; i += maxConcurrency) {\n      const batch = evalCases.slice(i, i + maxConcurrency);\n      const batchResults = await Promise.all(\n        batch.map(evalCase => this.runSingle(evalCase))\n      );\n      results.push(...batchResults);\n    }\n\n    return results;\n  }\n\n  private async runSequential(evalCases: EvalCase[]): Promise<EvalCaseResult[]> {\n    const results: EvalCaseResult[] = [];\n\n    for (const evalCase of evalCases) {\n      const result = await this.runSingle(evalCase);\n      results.push(result);\n    }\n\n    return results;\n  }\n\n  private async runSingle(evalCase: EvalCase): Promise<EvalCaseResult> {\n    const startTime = Date.now();\n\n    if (this.config.beforeEach) {\n      await this.config.beforeEach(evalCase);\n    }\n\n    let result: EvalCaseResult;\n\n    try {\n      result = await this.runWithRetries(evalCase);\n    } catch (error) {\n      result = {\n        evalCase,\n        success: false,\n        output: '',\n        duration: Date.now() - startTime,\n        judgeResults: [],\n        error: error instanceof Error ? error : new Error(String(error)),\n      };\n    }\n\n    if (this.config.afterEach) {\n      await this.config.afterEach(result);\n    }\n\n    if (this.config.verbose) {\n      const status = result.success ? '' : '';\n      console.log(`${status} ${evalCase.name} (${result.duration}ms)`);\n    }\n\n    return result;\n  }\n\n  private async runWithRetries(evalCase: EvalCase): Promise<EvalCaseResult> {\n    let lastError: Error | undefined;\n    let retryCount = 0;\n\n    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {\n      try {\n        const result = await this.executeAndJudge(evalCase);\n\n        if (result.success || attempt === this.config.maxRetries) {\n          return { ...result, retryCount };\n        }\n\n        retryCount++;\n        const delay = this.config.retryDelayMs * Math.pow(this.config.retryBackoffMultiplier, attempt);\n        await this.sleep(delay);\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        retryCount++;\n\n        if (attempt < this.config.maxRetries) {\n          const delay = this.config.retryDelayMs * Math.pow(this.config.retryBackoffMultiplier, attempt);\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    return {\n      evalCase,\n      success: false,\n      output: '',\n      duration: 0,\n      judgeResults: [],\n      error: lastError,\n      retryCount,\n    };\n  }\n\n  private async executeAndJudge(evalCase: EvalCase): Promise<EvalCaseResult> {\n    let executionResult: ExecutionResult;\n    let turnResults: ExecutionResult[] | undefined;\n\n    if (isMultiTurnEval(evalCase)) {\n      turnResults = await this.harness.executeMultiTurn(evalCase);\n      executionResult = turnResults[turnResults.length - 1];\n    } else {\n      executionResult = await this.harness.execute(evalCase);\n    }\n\n    const judgeResults = await this.runJudges(evalCase, executionResult);\n    const allPassed = judgeResults.every(r => r.passed);\n\n    return {\n      evalCase,\n      success: executionResult.success && allPassed,\n      output: executionResult.output,\n      duration: executionResult.duration,\n      judgeResults,\n      toolCalls: executionResult.toolCalls,\n      error: executionResult.error,\n    };\n  }\n\n  private async runJudges(evalCase: EvalCase, executionResult: ExecutionResult): Promise<JudgeResult[]> {\n    const judgeIds = this.getJudgeIds(evalCase);\n    const registry = getJudgeRegistry();\n    const results: JudgeResult[] = [];\n\n    for (const judgeId of judgeIds) {\n      const judge = registry.get(judgeId);\n\n      if (!judge) {\n        if (this.config.verbose) {\n          console.warn(`Judge not found: ${judgeId}`);\n        }\n        continue;\n      }\n\n      const context: JudgeContext = {\n        evalCase,\n        executionResult,\n        workingDirectory: executionResult.workingDirectory || '',\n      };\n\n      try {\n        const result = await judge.evaluate(context);\n        results.push(result);\n      } catch (error) {\n        results.push({\n          judgeId,\n          passed: false,\n          score: 0,\n          confidence: 1,\n          reasoning: `Judge error: ${error instanceof Error ? error.message : String(error)}`,\n        });\n      }\n    }\n\n    return results;\n  }\n\n  private getJudgeIds(evalCase: EvalCase): string[] {\n    if ('judges' in evalCase && evalCase.judges) {\n      return evalCase.judges;\n    }\n    return [];\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n","import type { EvalCase, JudgeResult } from '../config/schemas.js';\nimport type { AgentResult } from '../config/types.js';\n\nexport interface ExecutionResult {\n  success: boolean;\n  output: string;\n  error?: Error;\n  toolCalls: ToolCallRecord[];\n  duration: number;\n  numTurns?: number;\n  sessionId?: string;\n  workingDirectory?: string;\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalCostUsd?: number;\n  };\n}\n\nexport interface ToolCallRecord {\n  toolName: string;\n  toolUseId?: string;\n  input: unknown;\n  output?: unknown;\n  timestamp?: number;\n  duration?: number;\n  isError?: boolean;\n}\n\nexport interface JudgeContext {\n  evalCase: EvalCase;\n  executionResult: ExecutionResult;\n  workingDirectory: string;\n  turnIndex?: number;\n}\n\nexport type JudgeType = 'code' | 'llm' | 'hybrid';\n\nexport interface Judge {\n  id: string;\n  name: string;\n  type: JudgeType;\n  evaluate(context: JudgeContext): Promise<JudgeResult>;\n}\n\nexport abstract class BaseJudge implements Judge {\n  abstract id: string;\n  abstract name: string;\n  abstract type: JudgeType;\n\n  abstract evaluate(context: JudgeContext): Promise<JudgeResult>;\n\n  protected createResult(params: {\n    passed: boolean;\n    score: number;\n    reasoning: string;\n    confidence?: number;\n    details?: Record<string, unknown>;\n  }): JudgeResult {\n    return {\n      judgeId: this.id,\n      passed: params.passed,\n      score: params.score,\n      confidence: params.confidence ?? 1,\n      reasoning: params.reasoning,\n      details: params.details,\n    };\n  }\n\n  protected notApplicable(reason: string = 'Not applicable'): JudgeResult {\n    return this.createResult({\n      passed: true,\n      score: 100,\n      reasoning: reason,\n    });\n  }\n}\n\nexport function agentResultToExecutionResult(result: AgentResult): ExecutionResult {\n  return {\n    success: result.success,\n    output: result.output,\n    error: result.error,\n    toolCalls: (result.toolCalls ?? []).map(tc => ({\n      toolName: tc.toolName,\n      input: tc.input,\n      output: tc.output,\n      isError: tc.isError,\n    })),\n    duration: result.duration ?? 0,\n    numTurns: result.numTurns,\n    sessionId: result.sessionId,\n    usage: result.usage,\n  };\n}\n\nexport { JudgeResult };\n","import * as fs from 'fs/promises';\nimport * as fsSync from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\nexport interface EvalWorkspace {\n  id: string;\n  path: string;\n  createdAt: Date;\n}\n\nconst SKIP_PATTERNS = ['node_modules', '.bun', 'bun.lock', 'dist', '.git', '.next', 'coverage'];\n\nfunction getWorkspaceBaseDir(): string {\n  const cwd = process.cwd();\n  const evalsResultsDir = path.join(cwd, '__evals__', 'results', 'workspaces');\n\n  try {\n    fsSync.mkdirSync(evalsResultsDir, { recursive: true });\n    const testFile = path.join(evalsResultsDir, '.write-test');\n    fsSync.writeFileSync(testFile, '');\n    fsSync.unlinkSync(testFile);\n    return evalsResultsDir;\n  } catch {\n    const tmpDir = fsSync.realpathSync(os.tmpdir());\n    return path.join(tmpDir, 'vibe-check-evals');\n  }\n}\n\nexport class WorkspaceManager {\n  private workspaces: Map<string, EvalWorkspace> = new Map();\n  private baseDir: string;\n\n  constructor(baseDir?: string) {\n    this.baseDir = baseDir ?? getWorkspaceBaseDir();\n  }\n\n  async createWorkspace(template?: string): Promise<EvalWorkspace> {\n    const id = `ws-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n    const workspacePath = path.join(this.baseDir, id);\n\n    await fs.mkdir(workspacePath, { recursive: true });\n\n    if (template) {\n      console.log(`[WorkspaceManager] Copying template from: ${template}`);\n      try {\n        await this.copyTemplate(template, workspacePath);\n        console.log(`[WorkspaceManager] Template copied successfully to: ${workspacePath}`);\n        // Run bun install to install dependencies (node_modules is skipped during copy)\n        await this.installDependencies(workspacePath);\n        console.log(`[WorkspaceManager] Dependencies installed`);\n      } catch (error) {\n        console.error(`[WorkspaceManager] Failed to copy template from ${template}:`, error);\n        // Fall back to minimal structure\n        await this.createMinimalStructure(workspacePath);\n      }\n    } else {\n      console.log(`[WorkspaceManager] No template provided, creating minimal structure`);\n      await this.createMinimalStructure(workspacePath);\n    }\n\n    const workspace: EvalWorkspace = {\n      id,\n      path: workspacePath,\n      createdAt: new Date(),\n    };\n\n    this.workspaces.set(id, workspace);\n    return workspace;\n  }\n\n  private async installDependencies(workspacePath: string): Promise<void> {\n    try {\n      // Check if package.json exists\n      const packageJsonPath = path.join(workspacePath, 'package.json');\n      await fs.access(packageJsonPath);\n\n      // Run bun install in the workspace\n      await execAsync('bun install', { cwd: workspacePath });\n    } catch {\n      // Ignore errors - workspace may not need dependencies\n    }\n  }\n\n  private async createMinimalStructure(workspacePath: string): Promise<void> {\n    await fs.mkdir(path.join(workspacePath, 'src'), { recursive: true });\n\n    await fs.writeFile(\n      path.join(workspacePath, 'package.json'),\n      JSON.stringify({ name: 'eval-workspace', version: '1.0.0', type: 'module' }, null, 2)\n    );\n  }\n\n  private async copyTemplate(templatePath: string, workspacePath: string): Promise<void> {\n    const resolvedTemplate = path.isAbsolute(templatePath)\n      ? templatePath\n      : path.join(process.cwd(), templatePath);\n\n    // Verify template exists\n    try {\n      await fs.access(resolvedTemplate);\n    } catch {\n      throw new Error(`Template not found at: ${resolvedTemplate}`);\n    }\n\n    await this.copyDir(resolvedTemplate, workspacePath, SKIP_PATTERNS);\n  }\n\n  private async copyDir(src: string, dest: string, skipPatterns: string[] = []): Promise<void> {\n    await fs.mkdir(dest, { recursive: true });\n    const entries = await fs.readdir(src, { withFileTypes: true });\n\n    for (const entry of entries) {\n      if (skipPatterns.some(pattern => entry.name === pattern)) {\n        continue;\n      }\n\n      const srcPath = path.join(src, entry.name);\n      const destPath = path.join(dest, entry.name);\n\n      if (entry.isDirectory()) {\n        await this.copyDir(srcPath, destPath, skipPatterns);\n      } else {\n        await fs.copyFile(srcPath, destPath);\n      }\n    }\n  }\n\n  async cleanupWorkspace(id: string): Promise<void> {\n    const workspace = this.workspaces.get(id);\n    if (workspace) {\n      try {\n        await fs.rm(workspace.path, { recursive: true, force: true, maxRetries: 3, retryDelay: 100 });\n      } catch (error) {\n        console.warn(`Warning: Could not fully cleanup workspace ${id}:`, (error as Error).message);\n      }\n      this.workspaces.delete(id);\n    }\n  }\n\n  async cleanupAll(): Promise<void> {\n    for (const id of this.workspaces.keys()) {\n      await this.cleanupWorkspace(id);\n    }\n  }\n\n  getWorkspace(id: string): EvalWorkspace | undefined {\n    return this.workspaces.get(id);\n  }\n\n  listWorkspaces(): EvalWorkspace[] {\n    return Array.from(this.workspaces.values());\n  }\n}\n","import type { EvalCase } from '../config/schemas.js';\nimport type { AgentFunction, AgentContext, AgentResult, ResolvedConfig } from '../config/types.js';\nimport type { ExecutionResult } from '../judges/judge-interface.js';\nimport { agentResultToExecutionResult } from '../judges/judge-interface.js';\nimport { WorkspaceManager } from './workspace-manager.js';\n\nexport interface HarnessOptions {\n  config: ResolvedConfig;\n  workspaceManager?: WorkspaceManager;\n}\n\nexport class TestHarness {\n  private config: ResolvedConfig;\n  private workspaceManager: WorkspaceManager;\n\n  constructor(options: HarnessOptions) {\n    this.config = options.config;\n    this.workspaceManager = options.workspaceManager ?? new WorkspaceManager();\n  }\n\n  async execute(evalCase: EvalCase): Promise<ExecutionResult> {\n    const workspace = await this.workspaceManager.createWorkspace(this.config.workspaceTemplate);\n\n    try {\n      const context: AgentContext = {\n        workingDirectory: workspace.path,\n        evalId: evalCase.id,\n        evalName: evalCase.name,\n        timeout: evalCase.timeout ?? this.config.timeout,\n      };\n\n      const prompt = this.getPrompt(evalCase);\n      const startTime = Date.now();\n\n      const result = await this.executeWithTimeout(\n        this.config.agent,\n        prompt,\n        context,\n        context.timeout!\n      );\n\n      const executionResult = agentResultToExecutionResult(result);\n      executionResult.duration = result.duration ?? (Date.now() - startTime);\n      executionResult.workingDirectory = workspace.path;\n\n      return executionResult;\n    } finally {\n      if (!this.config.preserveWorkspaces) {\n        await this.workspaceManager.cleanupWorkspace(workspace.id);\n      }\n    }\n  }\n\n  async executeMultiTurn(evalCase: EvalCase & { category: 'multi-turn' }): Promise<ExecutionResult[]> {\n    const workspace = await this.workspaceManager.createWorkspace(this.config.workspaceTemplate);\n    const results: ExecutionResult[] = [];\n    let sessionId: string | undefined;\n\n    try {\n      for (let i = 0; i < evalCase.turns.length; i++) {\n        const turn = evalCase.turns[i];\n\n        const context: AgentContext = {\n          workingDirectory: workspace.path,\n          evalId: evalCase.id,\n          evalName: `${evalCase.name} - Turn ${i + 1}`,\n          timeout: evalCase.timeout ?? this.config.timeout,\n          sessionId,\n        };\n\n        const startTime = Date.now();\n\n        const result = await this.executeWithTimeout(\n          this.config.agent,\n          turn.prompt,\n          context,\n          context.timeout!\n        );\n\n        const executionResult = agentResultToExecutionResult(result);\n        executionResult.duration = result.duration ?? (Date.now() - startTime);\n        executionResult.workingDirectory = workspace.path;\n\n        results.push(executionResult);\n\n        sessionId = result.sessionId;\n      }\n\n      return results;\n    } finally {\n      if (!this.config.preserveWorkspaces) {\n        await this.workspaceManager.cleanupWorkspace(workspace.id);\n      }\n    }\n  }\n\n  private getPrompt(evalCase: EvalCase): string {\n    if ('prompt' in evalCase) {\n      return evalCase.prompt;\n    }\n    if ('turns' in evalCase && evalCase.turns.length > 0) {\n      return evalCase.turns[0].prompt;\n    }\n    throw new Error(`Eval case ${evalCase.id} has no prompt`);\n  }\n\n  private async executeWithTimeout(\n    agent: AgentFunction,\n    prompt: string,\n    context: AgentContext,\n    timeout: number\n  ): Promise<AgentResult> {\n    return new Promise(async (resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Agent execution timed out after ${timeout}ms`));\n      }, timeout);\n\n      try {\n        const result = await agent(prompt, context);\n        clearTimeout(timer);\n        resolve(result);\n      } catch (error) {\n        clearTimeout(timer);\n        reject(error);\n      }\n    });\n  }\n\n  async cleanup(): Promise<void> {\n    if (!this.config.preserveWorkspaces) {\n      await this.workspaceManager.cleanupAll();\n    }\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface FileCheckResult {\n  file: string;\n  exists: boolean;\n}\n\nexport class FileExistenceJudge extends BaseJudge {\n  id = 'file-existence';\n  name = 'File Existence Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    const targetFiles = evalCase.targetFiles || [];\n    if (targetFiles.length === 0) {\n      return this.notApplicable('No target files specified');\n    }\n\n    const baseDir = workingDirectory || process.cwd();\n    const results: FileCheckResult[] = [];\n\n    for (const file of targetFiles) {\n      const fullPath = path.join(baseDir, file);\n      try {\n        await fs.access(fullPath);\n        results.push({ file, exists: true });\n      } catch {\n        results.push({ file, exists: false });\n      }\n    }\n\n    const existingCount = results.filter((r) => r.exists).length;\n    const score = (existingCount / targetFiles.length) * 100;\n    const passed = score >= 80;\n\n    const missingFiles = results.filter((r) => !r.exists).map((r) => r.file);\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        missingFiles.length > 0\n          ? `${existingCount}/${targetFiles.length} expected files exist. Missing: ${missingFiles.join(', ')}`\n          : `All ${targetFiles.length} expected files exist`,\n      details: { results, missingFiles },\n    });\n  }\n}\n","import { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isToolEval } from '../../config/schemas.js';\nimport type { ExpectedToolCall } from '../../config/schemas.js';\n\ninterface ToolCallStats {\n  toolName: string;\n  expected: ExpectedToolCall;\n  actualCount: number;\n  passed: boolean;\n  reason: string;\n}\n\nexport class ToolInvocationJudge extends BaseJudge {\n  id = 'tool-invocation';\n  name = 'Tool Invocation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase } = context;\n\n    if (!isToolEval(evalCase)) {\n      return this.notApplicable('Only applicable for tool evals');\n    }\n\n    const expectedCalls = evalCase.expectedToolCalls || [];\n    if (expectedCalls.length === 0) {\n      return this.notApplicable('No expected tool calls specified');\n    }\n\n    const actualCalls = executionResult.toolCalls || [];\n    const toolCallCounts = new Map<string, number>();\n\n    for (const call of actualCalls) {\n      const count = toolCallCounts.get(call.toolName) || 0;\n      toolCallCounts.set(call.toolName, count + 1);\n    }\n\n    const stats: ToolCallStats[] = [];\n\n    for (const expected of expectedCalls) {\n      const actualCount = toolCallCounts.get(expected.toolName) || 0;\n      const minCalls = expected.minCalls ?? 1;\n      const maxCalls = expected.maxCalls ?? Infinity;\n\n      let passed = true;\n      let reason = '';\n\n      if (actualCount < minCalls) {\n        passed = false;\n        reason = `Expected at least ${minCalls} call(s), got ${actualCount}`;\n      } else if (actualCount > maxCalls) {\n        passed = false;\n        reason = `Expected at most ${maxCalls} call(s), got ${actualCount}`;\n      } else {\n        reason = `Called ${actualCount} time(s)`;\n      }\n\n      stats.push({\n        toolName: expected.toolName,\n        expected,\n        actualCount,\n        passed,\n        reason,\n      });\n    }\n\n    const passedCount = stats.filter((s) => s.passed).length;\n    const score = (passedCount / stats.length) * 100;\n    const passed = passedCount === stats.length;\n\n    const failedTools = stats.filter((s) => !s.passed);\n    const reasoning =\n      failedTools.length > 0\n        ? `${passedCount}/${stats.length} expected tool invocations satisfied. Failed: ${failedTools.map((s) => `${s.toolName} (${s.reason})`).join(', ')}`\n        : `All ${stats.length} expected tool invocations satisfied`;\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: {\n        stats,\n        actualToolCalls: actualCalls.map((c) => c.toolName),\n        toolCallCounts: Object.fromEntries(toolCallCounts),\n      },\n    });\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface PatternCheckResult {\n  file: string;\n  patterns: Array<{\n    pattern: string;\n    found: boolean;\n  }>;\n  allFound: boolean;\n}\n\nexport class PatternMatchJudge extends BaseJudge {\n  id = 'pattern-match';\n  name = 'Pattern Match Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    const expectedPatterns = evalCase.expectedPatterns || [];\n    if (expectedPatterns.length === 0) {\n      return this.notApplicable('No expected patterns specified');\n    }\n\n    const baseDir = workingDirectory || process.cwd();\n    const results: PatternCheckResult[] = [];\n\n    for (const { file, patterns } of expectedPatterns) {\n      const fullPath = path.join(baseDir, file);\n      let content = '';\n\n      try {\n        content = await fs.readFile(fullPath, 'utf-8');\n      } catch {\n        results.push({\n          file,\n          patterns: patterns.map((p) => ({ pattern: p, found: false })),\n          allFound: false,\n        });\n        continue;\n      }\n\n      const patternResults = patterns.map((pattern) => {\n        const regex = new RegExp(pattern, 'gm');\n        return {\n          pattern,\n          found: regex.test(content),\n        };\n      });\n\n      results.push({\n        file,\n        patterns: patternResults,\n        allFound: patternResults.every((p) => p.found),\n      });\n    }\n\n    const totalPatterns = results.reduce((sum, r) => sum + r.patterns.length, 0);\n    const foundPatterns = results.reduce(\n      (sum, r) => sum + r.patterns.filter((p) => p.found).length,\n      0\n    );\n    const score = totalPatterns > 0 ? (foundPatterns / totalPatterns) * 100 : 100;\n    const passed = score >= 80;\n\n    const failedFiles = results.filter((r) => !r.allFound);\n    const reasoning =\n      failedFiles.length > 0\n        ? `${foundPatterns}/${totalPatterns} patterns found. Missing patterns in: ${failedFiles.map((r) => r.file).join(', ')}`\n        : `All ${totalPatterns} expected patterns found`;\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: { results },\n    });\n  }\n}\n","import type { Judge, JudgeType } from './judge-interface.js';\nimport { FileExistenceJudge } from './builtin/file-existence.js';\nimport { ToolInvocationJudge } from './builtin/tool-invocation.js';\nimport { PatternMatchJudge } from './builtin/pattern-match.js';\n\nexport class JudgeRegistry {\n  private judges: Map<string, Judge> = new Map();\n\n  constructor() {\n    this.registerBuiltInJudges();\n  }\n\n  private registerBuiltInJudges(): void {\n    this.register(new FileExistenceJudge());\n    this.register(new ToolInvocationJudge());\n    this.register(new PatternMatchJudge());\n  }\n\n  register(judge: Judge): void {\n    this.judges.set(judge.id, judge);\n  }\n\n  unregister(id: string): boolean {\n    return this.judges.delete(id);\n  }\n\n  get(id: string): Judge | undefined {\n    return this.judges.get(id);\n  }\n\n  has(id: string): boolean {\n    return this.judges.has(id);\n  }\n\n  list(): string[] {\n    return Array.from(this.judges.keys());\n  }\n\n  listByType(type: JudgeType): string[] {\n    return Array.from(this.judges.entries())\n      .filter(([_, judge]) => judge.type === type)\n      .map(([id]) => id);\n  }\n\n  getAll(): Judge[] {\n    return Array.from(this.judges.values());\n  }\n}\n\nlet defaultRegistry: JudgeRegistry | null = null;\n\nexport function getJudgeRegistry(): JudgeRegistry {\n  if (!defaultRegistry) {\n    defaultRegistry = new JudgeRegistry();\n  }\n  return defaultRegistry;\n}\n\nexport function resetJudgeRegistry(): void {\n  defaultRegistry = null;\n}\n","import { Command } from 'commander';\nimport chalk from 'chalk';\nimport { loadConfig } from '../config/config-loader.js';\nimport { EvalRunner } from '../runner/eval-runner.js';\nimport type { EvalCategory } from '../config/schemas.js';\n\nconst program = new Command();\n\nprogram\n  .name('vibe-check')\n  .description('AI agent evaluation framework')\n  .version('0.1.0');\n\nprogram\n  .command('run')\n  .description('Run eval suite')\n  .option('-c, --config <path>', 'Path to config file')\n  .option('--category <categories...>', 'Filter by category (tool, code-gen, routing, multi-turn, basic)')\n  .option('--tag <tags...>', 'Filter by tag')\n  .option('--id <ids...>', 'Filter by eval ID')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) => {\n    try {\n      const config = await loadConfig(options.config);\n\n      if (options.verbose) {\n        config.verbose = true;\n      }\n\n      console.log(chalk.blue(' Running vibe-check evals...\\n'));\n\n      const runner = new EvalRunner(config);\n      const result = await runner.run({\n        categories: options.category as EvalCategory[] | undefined,\n        tags: options.tag,\n        ids: options.id,\n      });\n\n      console.log();\n      printSummary(result);\n\n      process.exit(result.failed + result.errors > 0 ? 1 : 0);\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nprogram\n  .command('list')\n  .description('List all eval cases')\n  .option('-c, --config <path>', 'Path to config file')\n  .option('--category <categories...>', 'Filter by category')\n  .option('--tag <tags...>', 'Filter by tag')\n  .option('--json', 'Output as JSON')\n  .action(async (options) => {\n    try {\n      const config = await loadConfig(options.config);\n      const { loadEvalCases } = await import('../utils/eval-loader.js');\n\n      const evalCases = await loadEvalCases({\n        testDir: config.testDir,\n        testMatch: config.testMatch,\n        categories: options.category as EvalCategory[] | undefined,\n        tags: options.tag,\n        enabledOnly: true,\n      });\n\n      if (options.json) {\n        console.log(JSON.stringify(evalCases, null, 2));\n      } else {\n        console.log(chalk.blue(`Found ${evalCases.length} eval cases:\\n`));\n\n        for (const evalCase of evalCases) {\n          const tags = evalCase.tags?.length ? chalk.gray(`[${evalCase.tags.join(', ')}]`) : '';\n          console.log(`  ${chalk.cyan(evalCase.id)} - ${evalCase.name} ${tags}`);\n          console.log(`    Category: ${evalCase.category}`);\n          if (evalCase.description) {\n            console.log(`    ${chalk.gray(evalCase.description)}`);\n          }\n          console.log();\n        }\n      }\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nprogram\n  .command('init')\n  .description('Initialize vibe-check in current project')\n  .option('--typescript', 'Create TypeScript config (default)')\n  .action(async () => {\n    const fs = await import('fs/promises');\n    const path = await import('path');\n\n    const configContent = `import { defineConfig } from '@pooflabs/vibe-check';\n\n// TODO: Import your AI agent SDK\n// import { query } from '@anthropic-ai/claude-agent-sdk';\n\nexport default defineConfig({\n  testDir: './__evals__',\n\n  // Implement your agent function\n  agent: async (prompt, context) => {\n    // TODO: Replace with your agent implementation\n    // For Claude Agent SDK:\n    // for await (const msg of query({ prompt, options: { cwd: context.workingDirectory } })) {\n    //   if (msg.type === 'result') {\n    //     return { output: msg.result || '', success: msg.subtype === 'success' };\n    //   }\n    // }\n\n    throw new Error('Agent not implemented - update vibe-check.config.ts');\n  },\n});\n`;\n\n    const evalExampleContent = `{\n  \"id\": \"example-eval\",\n  \"name\": \"Example Evaluation\",\n  \"description\": \"An example eval case\",\n  \"category\": \"basic\",\n  \"prompt\": \"Say hello world\",\n  \"judges\": []\n}\n`;\n\n    try {\n      const cwd = process.cwd();\n\n      await fs.writeFile(path.join(cwd, 'vibe-check.config.ts'), configContent);\n      console.log(chalk.green(''), 'Created vibe-check.config.ts');\n\n      await fs.mkdir(path.join(cwd, '__evals__'), { recursive: true });\n      await fs.writeFile(path.join(cwd, '__evals__', 'example.eval.json'), evalExampleContent);\n      console.log(chalk.green(''), 'Created __evals__/example.eval.json');\n\n      console.log();\n      console.log(chalk.blue('Next steps:'));\n      console.log('  1. Update vibe-check.config.ts with your agent function');\n      console.log('  2. Create eval cases in __evals__/*.eval.json');\n      console.log('  3. Run: bunx vibe-check run');\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Learning commands\nconst learn = program.command('learn').description('Learning loop commands');\n\nlearn\n  .command('run')\n  .description('Run full learning iteration')\n  .option('--source <source>', 'Data source to use (eval, jsonl, both)', 'eval')\n  .option('--auto-approve', 'Auto-approve high-confidence rules')\n  .option('--save-pending', 'Save rules for later review')\n  .action(async (options) => {\n    try {\n      const { LearningRunner } = await import('../learning/learning-runner.js');\n      const runner = new LearningRunner();\n\n      const sources = options.source === 'both' ? ['eval', 'jsonl'] : [options.source];\n\n      await runner.runIteration({\n        sources,\n        autoApprove: options.autoApprove,\n        savePending: options.savePending,\n      });\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nlearn\n  .command('analyze')\n  .description('Analyze failures without generating rules')\n  .option('--source <source>', 'Data source to use (eval, jsonl, both)', 'eval')\n  .action(async (options) => {\n    try {\n      const { LearningRunner } = await import('../learning/learning-runner.js');\n      const runner = new LearningRunner();\n\n      const sources = options.source === 'both' ? ['eval', 'jsonl'] : [options.source];\n\n      await runner.analyze({ sources });\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nlearn\n  .command('review')\n  .description('Review pending rules')\n  .action(async () => {\n    try {\n      const { LearningRunner } = await import('../learning/learning-runner.js');\n      const runner = new LearningRunner();\n      await runner.reviewPending();\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nlearn\n  .command('stats')\n  .description('Show learning system statistics')\n  .action(async () => {\n    try {\n      const { LearningRunner } = await import('../learning/learning-runner.js');\n      const runner = new LearningRunner();\n      await runner.showStats();\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nfunction printSummary(result: import('../runner/eval-runner.js').EvalSuiteResult): void {\n  const { total, passed, failed, errors, passRate, duration } = result;\n\n  console.log(chalk.bold('Results:'));\n  console.log(`  Total:  ${total}`);\n  console.log(`  ${chalk.green('Passed:')} ${passed}`);\n\n  if (failed > 0) {\n    console.log(`  ${chalk.red('Failed:')} ${failed}`);\n  }\n\n  if (errors > 0) {\n    console.log(`  ${chalk.yellow('Errors:')} ${errors}`);\n  }\n\n  console.log();\n  console.log(`  Pass rate: ${chalk.bold((passRate * 100).toFixed(1) + '%')}`);\n  console.log(`  Duration:  ${(duration / 1000).toFixed(2)}s`);\n\n  if (result.results.length > 0 && (failed > 0 || errors > 0)) {\n    console.log();\n    console.log(chalk.bold('Failed cases:'));\n\n    for (const r of result.results) {\n      if (!r.success) {\n        console.log(`  ${chalk.red('')} ${r.evalCase.name}`);\n        if (r.error) {\n          console.log(`    ${chalk.gray(r.error.message)}`);\n        }\n        for (const judge of r.judgeResults) {\n          if (!judge.passed) {\n            console.log(`    ${chalk.gray(`[${judge.judgeId}] ${judge.reasoning}`)}`);\n          }\n        }\n      }\n    }\n  }\n}\n\nprogram.parse();\n"]}