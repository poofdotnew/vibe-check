{"version":3,"sources":["../../src/config/schemas.ts","../../src/utils/eval-loader.ts","../../src/learning/config.ts","../../src/learning/data-sources/eval-source.ts","../../src/learning/data-sources/jsonl-source.ts","../../src/learning/data-sources/types.ts","../../src/learning/data-sources/index.ts","../../src/learning/explanation-generator.ts","../../src/learning/pattern-detector.ts","../../src/learning/rule-generator.ts","../../src/learning/cli-reviewer.ts","../../src/learning/rule-writer.ts","../../src/learning/learning-runner.ts","../../src/config/types.ts","../../src/config/config-loader.ts","../../src/runner/eval-runner.ts","../../src/judges/judge-interface.ts","../../src/harness/test-harness.ts","../../src/judges/builtin/file-existence.ts","../../src/judges/builtin/tool-invocation.ts","../../src/judges/builtin/pattern-match.ts","../../src/judges/builtin/agent-routing.ts","../../src/judges/builtin/skill-invocation.ts","../../src/judges/builtin/syntax-validation.ts","../../src/judges/builtin/llm-judge.ts","../../src/judges/judge-registry.ts","../../src/bin/cli.ts"],"names":["path9","fs9","__filename","__dirname","path","config","fs","fileURLToPath","readline","Anthropic","dotenv2","readline2","path2","fs2","stat","path3","fs3","passed","path4","fs4","path5","fs5","path6","fs6","path7","fs7","path8","fs8","loadEvalCases","LearningRunner"],"mappings":"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","file":"cli.js","sourcesContent":["import { z } from 'zod';\n\nexport const EvalCategorySchema = z.enum(['tool', 'code-gen', 'multi-turn', 'routing', 'basic']);\nexport type EvalCategory = z.infer<typeof EvalCategorySchema>;\n\nexport const EvalAgentTypeSchema = z.enum(['coding', 'conversational', 'research', 'computer-use', 'general']);\nexport type EvalAgentType = z.infer<typeof EvalAgentTypeSchema>;\n\nexport const ReferenceSolutionSchema = z.object({\n  files: z.array(z.string()).optional(),\n  description: z.string().optional(),\n  code: z.string().optional(),\n});\nexport type ReferenceSolution = z.infer<typeof ReferenceSolutionSchema>;\n\nexport const TrialConfigSchema = z.object({\n  count: z.number().min(1).max(10).default(1),\n  passThreshold: z.number().min(0).max(1).default(0.5),\n});\nexport type TrialConfig = z.infer<typeof TrialConfigSchema>;\n\nconst BaseEvalCaseSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  description: z.string(),\n  category: EvalCategorySchema,\n  tags: z.array(z.string()).optional(),\n  enabled: z.boolean().default(true),\n  timeout: z.number().optional(),\n  agentType: EvalAgentTypeSchema.optional(),\n  trials: TrialConfigSchema.optional(),\n  referenceSolution: ReferenceSolutionSchema.optional(),\n});\n\nexport const ExpectedToolCallSchema = z.object({\n  toolName: z.string(),\n  expectedInput: z.record(z.unknown()).optional(),\n  minCalls: z.number().optional(),\n  maxCalls: z.number().optional(),\n});\nexport type ExpectedToolCall = z.infer<typeof ExpectedToolCallSchema>;\n\nexport const ExpectedSkillSchema = z.object({\n  skillName: z.string(),\n  minCalls: z.number().optional().default(1),\n});\nexport type ExpectedSkill = z.infer<typeof ExpectedSkillSchema>;\n\nexport const ToolEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('tool'),\n  prompt: z.string(),\n  expectedToolCalls: z.array(ExpectedToolCallSchema),\n  expectedSkills: z.array(ExpectedSkillSchema).optional(),\n  judges: z.array(z.string()),\n});\nexport type ToolEvalCase = z.infer<typeof ToolEvalSchema>;\n\nexport const ExpectedPatternSchema = z.object({\n  file: z.string(),\n  patterns: z.array(z.string()),\n});\nexport type ExpectedPattern = z.infer<typeof ExpectedPatternSchema>;\n\nexport const CodeGenEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('code-gen'),\n  prompt: z.string(),\n  targetFiles: z.array(z.string()),\n  expectedPatterns: z.array(ExpectedPatternSchema).optional(),\n  syntaxValidation: z.boolean().default(true),\n  buildVerification: z.boolean().default(false),\n  judges: z.array(z.string()),\n});\nexport type CodeGenEvalCase = z.infer<typeof CodeGenEvalSchema>;\n\nexport const RoutingEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('routing'),\n  prompt: z.string(),\n  expectedAgent: z.string(),\n  shouldNotRoute: z.array(z.string()).optional(),\n  judges: z.array(z.string()),\n});\nexport type RoutingEvalCase = z.infer<typeof RoutingEvalSchema>;\n\nexport const TurnSchema = z.object({\n  prompt: z.string(),\n  expectedBehavior: z.string().optional(),\n  judges: z.array(z.string()).optional(),\n});\nexport type Turn = z.infer<typeof TurnSchema>;\n\nexport const MultiTurnEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('multi-turn'),\n  turns: z.array(TurnSchema),\n  sessionPersistence: z.boolean().default(true),\n  contextValidation: z.array(z.string()).optional(),\n  judges: z.array(z.string()).optional(),\n});\nexport type MultiTurnEvalCase = z.infer<typeof MultiTurnEvalSchema>;\n\nexport const BasicEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('basic'),\n  prompt: z.string(),\n  expectedBehavior: z.string().optional(),\n  judges: z.array(z.string()),\n});\nexport type BasicEvalCase = z.infer<typeof BasicEvalSchema>;\n\nexport const EvalCaseSchema = z.discriminatedUnion('category', [\n  ToolEvalSchema,\n  CodeGenEvalSchema,\n  RoutingEvalSchema,\n  MultiTurnEvalSchema,\n  BasicEvalSchema,\n]);\nexport type EvalCase = z.infer<typeof EvalCaseSchema>;\n\nexport function parseEvalCase(data: unknown): EvalCase {\n  return EvalCaseSchema.parse(data);\n}\n\nexport function isToolEval(evalCase: EvalCase): evalCase is ToolEvalCase {\n  return evalCase.category === 'tool';\n}\n\nexport function isCodeGenEval(evalCase: EvalCase): evalCase is CodeGenEvalCase {\n  return evalCase.category === 'code-gen';\n}\n\nexport function isRoutingEval(evalCase: EvalCase): evalCase is RoutingEvalCase {\n  return evalCase.category === 'routing';\n}\n\nexport function isMultiTurnEval(evalCase: EvalCase): evalCase is MultiTurnEvalCase {\n  return evalCase.category === 'multi-turn';\n}\n\nexport function isBasicEval(evalCase: EvalCase): evalCase is BasicEvalCase {\n  return evalCase.category === 'basic';\n}\n\nexport interface JudgeResult {\n  judgeId: string;\n  passed: boolean;\n  score: number;\n  confidence: number;\n  reasoning: string;\n  details?: Record<string, unknown>;\n}\n\nexport type ErrorType = 'api' | 'timeout' | 'judge' | 'unknown';\n\nexport interface EvalCaseResult {\n  evalCase: EvalCase;\n  success: boolean;\n  output: string;\n  duration: number;\n  judgeResults: JudgeResult[];\n  toolCalls?: Array<{ toolName: string; input: unknown; output?: unknown; isError?: boolean; timestamp?: number; duration?: number }>;\n  error?: Error;\n  errorType?: ErrorType;\n  retryCount?: number;\n  trialResults?: boolean[];\n  /** Whether this test passed on a retry (indicates flaky test) */\n  flaky?: boolean;\n  /** Error messages from each failed retry attempt */\n  retryErrors?: string[];\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { glob } from 'glob';\nimport { EvalCase, parseEvalCase, EvalCategory } from '../config/schemas.js';\n\nexport interface EvalLoadOptions {\n  testDir: string;\n  testMatch: string[];\n  categories?: EvalCategory[];\n  tags?: string[];\n  ids?: string[];\n  enabledOnly?: boolean;\n}\n\n/** @deprecated Use EvalLoadOptions instead */\nexport type LoadOptions = EvalLoadOptions;\n\nexport async function loadEvalCases(options: EvalLoadOptions): Promise<EvalCase[]> {\n  const { testDir, testMatch } = options;\n\n  const patterns = testMatch.map(pattern => path.join(testDir, pattern));\n  const files = await glob(patterns, { absolute: true });\n\n  const evalCases: EvalCase[] = [];\n\n  for (const file of files) {\n    try {\n      const content = await fs.readFile(file, 'utf-8');\n      const data = JSON.parse(content);\n      const evalCase = parseEvalCase(data);\n      evalCases.push(evalCase);\n    } catch (error) {\n      console.warn(`Failed to load eval case from ${file}:`, error);\n    }\n  }\n\n  return filterEvalCases(evalCases, options);\n}\n\nexport async function loadEvalCase(id: string, options: EvalLoadOptions): Promise<EvalCase | null> {\n  const cases = await loadEvalCases({ ...options, ids: [id] });\n  return cases[0] || null;\n}\n\nfunction filterEvalCases(cases: EvalCase[], options: EvalLoadOptions): EvalCase[] {\n  let filtered = cases;\n\n  if (options.enabledOnly !== false) {\n    filtered = filtered.filter((c) => c.enabled !== false);\n  }\n\n  if (options.categories && options.categories.length > 0) {\n    filtered = filtered.filter((c) => options.categories!.includes(c.category));\n  }\n\n  if (options.tags && options.tags.length > 0) {\n    filtered = filtered.filter((c) => c.tags?.some((t) => options.tags!.includes(t)));\n  }\n\n  if (options.ids && options.ids.length > 0) {\n    filtered = filtered.filter((c) => options.ids!.includes(c.id));\n  }\n\n  return filtered;\n}\n\nexport function groupByCategory(cases: EvalCase[]): Record<EvalCategory, EvalCase[]> {\n  const grouped: Record<EvalCategory, EvalCase[]> = {\n    tool: [],\n    'code-gen': [],\n    'multi-turn': [],\n    routing: [],\n    basic: [],\n  };\n\n  for (const evalCase of cases) {\n    grouped[evalCase.category].push(evalCase);\n  }\n\n  return grouped;\n}\n","/**\n * Configuration for the Prompt Learning System\n */\n\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport interface LearningConfig {\n  // Analysis settings\n  /** Minimum number of failures to form a pattern */\n  minFailuresForPattern: number;\n\n  /** Similarity threshold for grouping failures (0-1) */\n  similarityThreshold: number;\n\n  /** Maximum failures to process per iteration */\n  maxFailuresPerIteration: number;\n\n  // Rule generation settings\n  /** Model to use for explanation generation */\n  explanationModel: string;\n\n  /** Model to use for rule generation */\n  ruleGenerationModel: string;\n\n  /** Maximum rules to suggest per iteration */\n  maxRulesPerIteration: number;\n\n  /** Minimum confidence to include a rule */\n  minRuleConfidence: number;\n\n  // Validation settings\n  /** Number of evals to run for validation */\n  validationRunSize: number;\n\n  /** Maximum acceptable regression percentage */\n  regressionThreshold: number;\n\n  // Directories\n  /** Directory for the learning system */\n  learningDir: string;\n\n  /** Directory for prompts */\n  promptsDir: string;\n\n  /** Directory for rules */\n  rulesDir: string;\n\n  /** Directory for pending rules */\n  pendingDir: string;\n\n  /** Directory for approved rules */\n  approvedDir: string;\n\n  /** Directory for rejected rules */\n  rejectedDir: string;\n\n  /** Path to learned rules JSON */\n  learnedRulesPath: string;\n\n  /** Path to learning history */\n  historyPath: string;\n\n  /** Directory for eval results (to read from) */\n  evalResultsDir: string;\n}\n\nconst LEARNING_DIR = path.join(__dirname);\nconst RULES_DIR = path.join(LEARNING_DIR, 'rules');\nconst EVAL_RESULTS_DIR = path.join(__dirname, '..', 'results');\n\nexport const DEFAULT_LEARNING_CONFIG: LearningConfig = {\n  // Analysis settings\n  minFailuresForPattern: 2,\n  similarityThreshold: 0.7,\n  maxFailuresPerIteration: 100,\n\n  // Rule generation settings\n  explanationModel: 'claude-sonnet-4-20250514',\n  ruleGenerationModel: 'claude-sonnet-4-20250514',\n  maxRulesPerIteration: 5,\n  minRuleConfidence: 0.6,\n\n  // Validation settings\n  validationRunSize: 10,\n  regressionThreshold: 5, // 5% max regression\n\n  // Directories\n  learningDir: LEARNING_DIR,\n  promptsDir: path.join(LEARNING_DIR, 'prompts'),\n  rulesDir: RULES_DIR,\n  pendingDir: path.join(RULES_DIR, 'pending'),\n  approvedDir: path.join(RULES_DIR, 'approved'),\n  rejectedDir: path.join(RULES_DIR, 'rejected'),\n  learnedRulesPath: path.join(RULES_DIR, 'learned-rules.json'),\n  historyPath: path.join(RULES_DIR, 'history.json'),\n  evalResultsDir: EVAL_RESULTS_DIR,\n};\n\n/**\n * Get the learning configuration, optionally with overrides\n */\nexport function getLearningConfig(\n  overrides?: Partial<LearningConfig>\n): LearningConfig {\n  return {\n    ...DEFAULT_LEARNING_CONFIG,\n    ...overrides,\n  };\n}\n\n/**\n * Environment variable overrides\n */\nexport function getConfigFromEnv(): Partial<LearningConfig> {\n  const overrides: Partial<LearningConfig> = {};\n\n  if (process.env.LEARNING_EXPLANATION_MODEL) {\n    overrides.explanationModel = process.env.LEARNING_EXPLANATION_MODEL;\n  }\n\n  if (process.env.LEARNING_RULE_MODEL) {\n    overrides.ruleGenerationModel = process.env.LEARNING_RULE_MODEL;\n  }\n\n  if (process.env.LEARNING_MIN_PATTERN_SIZE) {\n    overrides.minFailuresForPattern = parseInt(\n      process.env.LEARNING_MIN_PATTERN_SIZE,\n      10\n    );\n  }\n\n  if (process.env.LEARNING_SIMILARITY_THRESHOLD) {\n    overrides.similarityThreshold = parseFloat(\n      process.env.LEARNING_SIMILARITY_THRESHOLD\n    );\n  }\n\n  if (process.env.LEARNING_MAX_RULES) {\n    overrides.maxRulesPerIteration = parseInt(\n      process.env.LEARNING_MAX_RULES,\n      10\n    );\n  }\n\n  return overrides;\n}\n\nexport default getLearningConfig;\n","/**\n * Data source for extracting failures from eval results.\n * Reads from __evals__/results/ directory.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport type { DataSource, FailureInput, CollectOptions, ToolCall } from './types.js';\nimport type { EvalSuiteResult, EvalCaseResult } from '../../runner/eval-runner.js';\nimport type { EvalCase } from '../../config/schemas.js';\nimport { getLearningConfig } from '../config.js';\n\n/**\n * Extracts the prompt from an eval case based on its category\n */\nfunction getPromptFromEvalCase(evalCase: EvalCase): string {\n  if ('prompt' in evalCase) {\n    return evalCase.prompt;\n  }\n  if ('turns' in evalCase && evalCase.turns.length > 0) {\n    return evalCase.turns.map((t) => t.prompt).join('\\n---\\n');\n  }\n  return '';\n}\n\n/**\n * Extracts expected behavior from an eval case\n */\nfunction getExpectedBehavior(evalCase: EvalCase): string | undefined {\n  if ('expectedBehavior' in evalCase) {\n    return evalCase.expectedBehavior;\n  }\n  if ('expectedToolCalls' in evalCase) {\n    return `Expected tool calls: ${evalCase.expectedToolCalls.map((t) => t.toolName).join(', ')}`;\n  }\n  if ('expectedAgent' in evalCase) {\n    return `Expected to route to: ${evalCase.expectedAgent}`;\n  }\n  if ('targetFiles' in evalCase) {\n    return `Expected to create/modify files: ${evalCase.targetFiles.join(', ')}`;\n  }\n  return undefined;\n}\n\n/**\n * Converts an EvalCaseResult to a FailureInput\n */\nfunction evalResultToFailureInput(result: EvalCaseResult): FailureInput {\n  const toolCalls: ToolCall[] =\n    result.toolCalls?.map((tc) => ({\n      name: tc.toolName,\n      input: tc.input as Record<string, unknown>,\n      output: typeof tc.output === 'string' ? tc.output : JSON.stringify(tc.output),\n    })) ?? [];\n\n  return {\n    id: result.evalCase.id,\n    source: 'eval',\n    sourceId: result.evalCase.id,\n    prompt: getPromptFromEvalCase(result.evalCase),\n    expectedBehavior: getExpectedBehavior(result.evalCase),\n    category: result.evalCase.category,\n    output: result.output ?? '',\n    toolCalls,\n    error: result.error?.message,\n    judgeResults: result.judgeResults,\n    timestamp: new Date().toISOString(),\n    metadata: {\n      evalName: result.evalCase.name,\n      evalDescription: result.evalCase.description,\n      evalTags: result.evalCase.tags,\n      duration: result.duration,\n      retryCount: result.retryCount,\n    },\n  };\n}\n\nexport class EvalDataSource implements DataSource {\n  name = 'eval';\n  private resultsDir: string;\n\n  constructor(resultsDir?: string) {\n    const config = getLearningConfig();\n    this.resultsDir = resultsDir ?? config.evalResultsDir;\n  }\n\n  async isAvailable(): Promise<boolean> {\n    try {\n      await fs.access(this.resultsDir);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Gets the path to the latest results file\n   */\n  private async getLatestResultsPath(): Promise<string | null> {\n    try {\n      // First check for latest.json symlink/file\n      const latestPath = path.join(this.resultsDir, 'latest.json');\n      try {\n        await fs.access(latestPath);\n        return latestPath;\n      } catch {\n        // No latest.json, look for most recent eval-results file\n      }\n\n      const files = await fs.readdir(this.resultsDir);\n      const resultFiles = files\n        .filter((f) => f.startsWith('eval-results-') && f.endsWith('.json'))\n        .sort()\n        .reverse();\n\n      if (resultFiles.length === 0) {\n        return null;\n      }\n\n      return path.join(this.resultsDir, resultFiles[0]);\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Reads eval results from a file\n   */\n  private async readResults(filePath: string): Promise<EvalSuiteResult | null> {\n    try {\n      const content = await fs.readFile(filePath, 'utf-8');\n      return JSON.parse(content) as EvalSuiteResult;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Collects failed evals from the results directory\n   */\n  async collect(options?: CollectOptions): Promise<FailureInput[]> {\n    const resultsPath = await this.getLatestResultsPath();\n    if (!resultsPath) {\n      console.warn('No eval results found in', this.resultsDir);\n      return [];\n    }\n\n    const suiteResult = await this.readResults(resultsPath);\n    if (!suiteResult) {\n      console.warn('Could not parse eval results from', resultsPath);\n      return [];\n    }\n\n    // Filter to only failed results\n    let failures = suiteResult.results.filter((r) => !r.success);\n\n    // Apply category filter\n    if (options?.categories && options.categories.length > 0) {\n      failures = failures.filter((r) =>\n        options.categories!.includes(r.evalCase.category)\n      );\n    }\n\n    // Apply ID filter\n    if (options?.ids && options.ids.length > 0) {\n      failures = failures.filter((r) => options.ids!.includes(r.evalCase.id));\n    }\n\n    // Apply limit\n    if (options?.limit && options.limit > 0) {\n      failures = failures.slice(0, options.limit);\n    }\n\n    // Convert to FailureInput format\n    return failures.map(evalResultToFailureInput);\n  }\n\n  /**\n   * Gets summary statistics about available results\n   */\n  async getStats(): Promise<{\n    totalRuns: number;\n    latestRun: EvalSuiteResult | null;\n    failuresInLatest: number;\n  }> {\n    const files = await fs.readdir(this.resultsDir).catch(() => []);\n    const resultFiles = files.filter(\n      (f) => f.startsWith('eval-results-') && f.endsWith('.json')\n    );\n\n    const latestPath = await this.getLatestResultsPath();\n    const latestRun = latestPath ? await this.readResults(latestPath) : null;\n    const failuresInLatest = latestRun\n      ? latestRun.results.filter((r) => !r.success).length\n      : 0;\n\n    return {\n      totalRuns: resultFiles.length,\n      latestRun,\n      failuresInLatest,\n    };\n  }\n}\n\nexport default EvalDataSource;\n","/**\n * Data source for extracting failures from production JSONL logs.\n * Scans prompt-runs/project-* folders for .claude session logs.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { createReadStream } from 'fs';\nimport readline from 'readline';\nimport type { DataSource, FailureInput, CollectOptions, ToolCall } from './types.js';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Structure of a JSONL message entry\n */\ninterface JsonlMessage {\n  uuid: string;\n  parentUuid: string | null;\n  type: 'user' | 'assistant';\n  sessionId: string;\n  agentId?: string;\n  timestamp: string;\n  cwd?: string;\n  message: {\n    role: 'user' | 'assistant';\n    content: string | ContentBlock[];\n    model?: string;\n    id?: string;\n    stop_reason?: string | null;\n    usage?: {\n      input_tokens: number;\n      output_tokens: number;\n    };\n  };\n  toolUseResult?: string;\n  isSidechain?: boolean;\n}\n\ninterface ContentBlock {\n  type: 'text' | 'tool_use' | 'tool_result';\n  text?: string;\n  id?: string;\n  name?: string;\n  input?: Record<string, unknown>;\n  content?: string;\n  is_error?: boolean;\n  tool_use_id?: string;\n}\n\n/**\n * A session with all its messages\n */\ninterface Session {\n  sessionId: string;\n  agentId?: string;\n  messages: JsonlMessage[];\n  firstMessage: JsonlMessage;\n  lastMessage: JsonlMessage;\n  hasErrors: boolean;\n  errors: SessionError[];\n}\n\ninterface SessionError {\n  messageUuid: string;\n  toolName?: string;\n  errorMessage: string;\n  timestamp: string;\n  parentUuid?: string;\n}\n\nexport class JsonlDataSource implements DataSource {\n  name = 'jsonl';\n  private promptRunsDir: string;\n\n  constructor(promptRunsDir?: string) {\n    // Default to cdk/dev-server-manager/prompt-runs relative to project root\n    this.promptRunsDir = promptRunsDir ||\n      path.join(__dirname, '..', '..', '..', 'cdk', 'dev-server-manager', 'prompt-runs');\n  }\n\n  async isAvailable(): Promise<boolean> {\n    try {\n      await fs.access(this.promptRunsDir);\n      const projects = await this.findProjectFolders();\n      return projects.length > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Finds all project-* folders in prompt-runs\n   */\n  private async findProjectFolders(): Promise<string[]> {\n    try {\n      const entries = await fs.readdir(this.promptRunsDir, { withFileTypes: true });\n      return entries\n        .filter(e => e.isDirectory() && e.name.startsWith('project-'))\n        .map(e => path.join(this.promptRunsDir, e.name));\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Finds all .jsonl files in a project's .claude folders\n   */\n  private async findJsonlFiles(projectDir: string): Promise<string[]> {\n    const jsonlFiles: string[] = [];\n\n    const searchDir = async (dir: string) => {\n      try {\n        const entries = await fs.readdir(dir, { withFileTypes: true });\n        for (const entry of entries) {\n          const fullPath = path.join(dir, entry.name);\n          if (entry.isDirectory()) {\n            await searchDir(fullPath);\n          } else if (entry.isFile() && entry.name.endsWith('.jsonl')) {\n            jsonlFiles.push(fullPath);\n          }\n        }\n      } catch {\n        // Ignore permission errors\n      }\n    };\n\n    await searchDir(projectDir);\n    return jsonlFiles;\n  }\n\n  /**\n   * Parses a JSONL file into messages\n   */\n  private async parseJsonlFile(filePath: string): Promise<JsonlMessage[]> {\n    const messages: JsonlMessage[] = [];\n\n    const fileStream = createReadStream(filePath);\n    const rl = readline.createInterface({\n      input: fileStream,\n      crlfDelay: Infinity,\n    });\n\n    for await (const line of rl) {\n      if (line.trim()) {\n        try {\n          const parsed = JSON.parse(line) as JsonlMessage;\n          messages.push(parsed);\n        } catch {\n          // Skip malformed lines\n        }\n      }\n    }\n\n    return messages;\n  }\n\n  /**\n   * Groups messages into sessions\n   */\n  private groupIntoSessions(messages: JsonlMessage[]): Session[] {\n    const sessionMap = new Map<string, JsonlMessage[]>();\n\n    for (const msg of messages) {\n      const key = msg.agentId || msg.sessionId;\n      if (!sessionMap.has(key)) {\n        sessionMap.set(key, []);\n      }\n      sessionMap.get(key)!.push(msg);\n    }\n\n    const sessions: Session[] = [];\n\n    for (const [key, msgs] of sessionMap) {\n      // Sort by timestamp\n      msgs.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n\n      // Find errors\n      const errors: SessionError[] = [];\n      for (const msg of msgs) {\n        const msgErrors = this.extractErrors(msg);\n        errors.push(...msgErrors);\n      }\n\n      if (msgs.length > 0) {\n        sessions.push({\n          sessionId: msgs[0].sessionId,\n          agentId: msgs[0].agentId,\n          messages: msgs,\n          firstMessage: msgs[0],\n          lastMessage: msgs[msgs.length - 1],\n          hasErrors: errors.length > 0,\n          errors,\n        });\n      }\n    }\n\n    return sessions;\n  }\n\n  /**\n   * Extracts errors from a message\n   */\n  private extractErrors(msg: JsonlMessage): SessionError[] {\n    const errors: SessionError[] = [];\n\n    // Check toolUseResult for errors\n    if (msg.toolUseResult) {\n      const resultStr = typeof msg.toolUseResult === 'string'\n        ? msg.toolUseResult\n        : JSON.stringify(msg.toolUseResult);\n      if (resultStr.toLowerCase().includes('error')) {\n        errors.push({\n          messageUuid: msg.uuid,\n          errorMessage: resultStr,\n          timestamp: msg.timestamp,\n          parentUuid: msg.parentUuid || undefined,\n        });\n      }\n    }\n\n    // Check content for tool_result with is_error\n    if (Array.isArray(msg.message?.content)) {\n      for (const block of msg.message.content) {\n        if (block.type === 'tool_result' && block.is_error) {\n          errors.push({\n            messageUuid: msg.uuid,\n            toolName: this.findToolNameForResult(msg, block.tool_use_id),\n            errorMessage: typeof block.content === 'string' ? block.content : JSON.stringify(block.content),\n            timestamp: msg.timestamp,\n            parentUuid: msg.parentUuid || undefined,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Finds the tool name for a tool_use_id by looking at parent messages\n   */\n  private findToolNameForResult(msg: JsonlMessage, toolUseId?: string): string | undefined {\n    if (!toolUseId) return undefined;\n\n    // Look in the message content for matching tool_use\n    if (Array.isArray(msg.message?.content)) {\n      for (const block of msg.message.content) {\n        if (block.type === 'tool_use' && block.id === toolUseId) {\n          return block.name;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Extracts the initial prompt from a session\n   */\n  private extractPrompt(session: Session): string {\n    const firstUserMsg = session.messages.find(m => m.type === 'user');\n    if (!firstUserMsg) return '';\n\n    const content = firstUserMsg.message?.content;\n    if (typeof content === 'string') {\n      return content;\n    }\n    if (Array.isArray(content)) {\n      const textBlock = content.find(b => b.type === 'text');\n      return textBlock?.text || '';\n    }\n    return '';\n  }\n\n  /**\n   * Extracts all tool calls from a session\n   */\n  private extractToolCalls(session: Session): ToolCall[] {\n    const toolCalls: ToolCall[] = [];\n    const toolUseMap = new Map<string, ContentBlock>();\n\n    // First pass: collect tool_use blocks\n    for (const msg of session.messages) {\n      if (Array.isArray(msg.message?.content)) {\n        for (const block of msg.message.content) {\n          if (block.type === 'tool_use' && block.id) {\n            toolUseMap.set(block.id, block);\n          }\n        }\n      }\n    }\n\n    // Second pass: match with tool_result\n    for (const msg of session.messages) {\n      if (Array.isArray(msg.message?.content)) {\n        for (const block of msg.message.content) {\n          if (block.type === 'tool_result' && block.tool_use_id) {\n            const toolUse = toolUseMap.get(block.tool_use_id);\n            if (toolUse) {\n              toolCalls.push({\n                name: toolUse.name || 'unknown',\n                input: toolUse.input,\n                output: typeof block.content === 'string' ? block.content : JSON.stringify(block.content),\n                error: block.is_error ? (typeof block.content === 'string' ? block.content : JSON.stringify(block.content)) : undefined,\n                timestamp: msg.timestamp,\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return toolCalls;\n  }\n\n  /**\n   * Extracts the final output from a session\n   */\n  private extractOutput(session: Session): string {\n    // Find last assistant message with text content\n    for (let i = session.messages.length - 1; i >= 0; i--) {\n      const msg = session.messages[i];\n      if (msg.type === 'assistant') {\n        const content = msg.message?.content;\n        if (typeof content === 'string') {\n          return content;\n        }\n        if (Array.isArray(content)) {\n          const textBlock = content.find(b => b.type === 'text');\n          if (textBlock?.text) {\n            return textBlock.text;\n          }\n        }\n      }\n    }\n    return '';\n  }\n\n  /**\n   * Converts a session with errors to a FailureInput\n   */\n  private sessionToFailureInput(session: Session, filePath: string): FailureInput {\n    const prompt = this.extractPrompt(session);\n    const output = this.extractOutput(session);\n    const toolCalls = this.extractToolCalls(session);\n\n    // Combine all errors into a single error message\n    const errorMessage = session.errors\n      .map(e => e.toolName ? `${e.toolName}: ${e.errorMessage}` : e.errorMessage)\n      .join('\\n');\n\n    return {\n      id: `jsonl-${session.agentId || session.sessionId}-${Date.now()}`,\n      source: 'production',\n      sourceId: filePath,\n      prompt,\n      output,\n      toolCalls,\n      error: errorMessage,\n      timestamp: session.firstMessage.timestamp,\n      metadata: {\n        sessionId: session.sessionId,\n        agentId: session.agentId,\n        errorCount: session.errors.length,\n        messageCount: session.messages.length,\n        cwd: session.firstMessage.cwd,\n        errors: session.errors,\n      },\n    };\n  }\n\n  /**\n   * Collects failures from production JSONL logs\n   */\n  async collect(options?: CollectOptions): Promise<FailureInput[]> {\n    const failures: FailureInput[] = [];\n    const projectFolders = await this.findProjectFolders();\n\n    if (projectFolders.length === 0) {\n      console.warn(`No project-* folders found in ${this.promptRunsDir}`);\n      return [];\n    }\n\n    for (const projectDir of projectFolders) {\n      const jsonlFiles = await this.findJsonlFiles(projectDir);\n\n      for (const filePath of jsonlFiles) {\n        // Apply date filters\n        if (options?.since || options?.until) {\n          const stats = await fs.stat(filePath);\n          if (options.since && stats.mtime < options.since) continue;\n          if (options.until && stats.mtime > options.until) continue;\n        }\n\n        const messages = await this.parseJsonlFile(filePath);\n        const sessions = this.groupIntoSessions(messages);\n\n        for (const session of sessions) {\n          if (session.hasErrors) {\n            const failure = this.sessionToFailureInput(session, filePath);\n            failures.push(failure);\n          }\n        }\n\n        // Check limit\n        if (options?.limit && failures.length >= options.limit) {\n          return failures.slice(0, options.limit);\n        }\n      }\n    }\n\n    return failures;\n  }\n\n  /**\n   * Gets statistics about available JSONL data\n   */\n  async getStats(): Promise<{\n    projectCount: number;\n    jsonlFileCount: number;\n    sessionCount: number;\n    errorSessionCount: number;\n  }> {\n    const projectFolders = await this.findProjectFolders();\n    let jsonlFileCount = 0;\n    let sessionCount = 0;\n    let errorSessionCount = 0;\n\n    for (const projectDir of projectFolders) {\n      const jsonlFiles = await this.findJsonlFiles(projectDir);\n      jsonlFileCount += jsonlFiles.length;\n\n      for (const filePath of jsonlFiles) {\n        const messages = await this.parseJsonlFile(filePath);\n        const sessions = this.groupIntoSessions(messages);\n        sessionCount += sessions.length;\n        errorSessionCount += sessions.filter(s => s.hasErrors).length;\n      }\n    }\n\n    return {\n      projectCount: projectFolders.length,\n      jsonlFileCount,\n      sessionCount,\n      errorSessionCount,\n    };\n  }\n}\n\nexport default JsonlDataSource;\n","/**\n * Common types for all data sources in the learning system.\n * All data sources output FailureInput[] which feeds into the learning pipeline.\n */\n\nimport type { JudgeResult, EvalCategory } from '../../config/schemas.js';\n\n/**\n * Represents a tool call made by the agent\n */\nexport interface ToolCall {\n  name: string;\n  input?: Record<string, unknown>;\n  output?: string;\n  error?: string;\n  timestamp?: string;\n}\n\n/**\n * Common input format for all data sources.\n * This is the interface between data sources and the learning pipeline.\n */\nexport interface FailureInput {\n  /** Unique identifier for this failure */\n  id: string;\n\n  /** Source type: eval results, production logs, or custom */\n  source: 'eval' | 'production' | 'custom';\n\n  /** Source-specific identifier (eval ID, JSONL file path, etc.) */\n  sourceId: string;\n\n  /** The prompt/request given to the agent */\n  prompt: string;\n\n  /** Expected behavior (optional for production logs) */\n  expectedBehavior?: string;\n\n  /** Category of the eval (optional for production logs) */\n  category?: EvalCategory;\n\n  /** The agent's output/response */\n  output: string;\n\n  /** Tool calls made during execution */\n  toolCalls?: ToolCall[];\n\n  /** Error message if the agent failed */\n  error?: string;\n\n  /** Existing judge results if available */\n  judgeResults?: JudgeResult[];\n\n  /** When this failure occurred */\n  timestamp: string;\n\n  /** Additional metadata from the source */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Options for collecting failures from a data source\n */\nexport interface CollectOptions {\n  /** Filter by date range */\n  since?: Date;\n  until?: Date;\n\n  /** Maximum number of failures to collect */\n  limit?: number;\n\n  /** Filter by category (for eval sources) */\n  categories?: EvalCategory[];\n\n  /** Filter by specific IDs */\n  ids?: string[];\n\n  /** Project ID for production data source (fetches from S3) */\n  projectId?: string;\n\n  /** Task ID for production data source (optional, fetches all tasks if not specified) */\n  taskId?: string;\n\n  /** Custom filters */\n  filters?: Record<string, unknown>;\n}\n\n/**\n * Interface for data sources that can provide failure data\n */\nexport interface DataSource {\n  /** Name of the data source */\n  name: string;\n\n  /** Collects failures from the source */\n  collect(options?: CollectOptions): Promise<FailureInput[]>;\n\n  /** Optional: Check if the source is available/configured */\n  isAvailable?(): Promise<boolean>;\n}\n\n/**\n * Registry of available data sources\n */\nexport type DataSourceRegistry = Record<string, DataSource>;\n","/**\n * Data source registry and factory for the learning system.\n */\n\nimport type { DataSource, DataSourceRegistry, CollectOptions, FailureInput } from './types.js';\nimport { EvalDataSource } from './eval-source.js';\nimport { JsonlDataSource } from './jsonl-source.js';\n\n// Export types\nexport * from './types.js';\n\n// Export data sources\nexport { EvalDataSource } from './eval-source.js';\nexport { JsonlDataSource } from './jsonl-source.js';\n\n/**\n * Creates a data source by name\n */\nexport function createDataSource(\n  name: string,\n  options?: Record<string, unknown>\n): DataSource | null {\n  switch (name) {\n    case 'eval':\n      return new EvalDataSource(options?.resultsDir as string | undefined);\n\n    case 'jsonl':\n      return new JsonlDataSource(options?.promptRunsDir as string | undefined);\n\n    default:\n      console.warn(`Unknown data source: ${name}`);\n      return null;\n  }\n}\n\n/**\n * Registry of all available data sources\n */\nexport function getDataSourceRegistry(): DataSourceRegistry {\n  return {\n    eval: new EvalDataSource(),\n    jsonl: new JsonlDataSource(),\n  };\n}\n\n/**\n * Collects failures from multiple data sources\n */\nexport async function collectFromSources(\n  sources: string[],\n  options?: CollectOptions\n): Promise<FailureInput[]> {\n  const failures: FailureInput[] = [];\n\n  for (const sourceName of sources) {\n    const source = createDataSource(sourceName);\n    if (!source) {\n      console.warn(`Skipping unknown source: ${sourceName}`);\n      continue;\n    }\n\n    const isAvailable = await source.isAvailable?.();\n    if (isAvailable === false) {\n      console.warn(`Source not available: ${sourceName}`);\n      continue;\n    }\n\n    const sourceFailures = await source.collect(options);\n    failures.push(...sourceFailures);\n  }\n\n  return failures;\n}\n\n/**\n * Gets statistics about available data sources\n */\nexport async function getSourceStats(): Promise<\n  Record<string, { available: boolean; failureCount?: number; details?: Record<string, number> }>\n> {\n  const registry = getDataSourceRegistry();\n  const stats: Record<string, { available: boolean; failureCount?: number; details?: Record<string, number> }> = {};\n\n  for (const [name, source] of Object.entries(registry)) {\n    const available = (await source.isAvailable?.()) ?? true;\n    let failureCount: number | undefined;\n    let details: Record<string, number> | undefined;\n\n    if (available && name === 'eval') {\n      const evalSource = source as EvalDataSource;\n      const evalStats = await evalSource.getStats();\n      failureCount = evalStats.failuresInLatest;\n    }\n\n    if (available && name === 'jsonl') {\n      const jsonlSource = source as JsonlDataSource;\n      const jsonlStats = await jsonlSource.getStats();\n      failureCount = jsonlStats.errorSessionCount;\n      details = {\n        projects: jsonlStats.projectCount,\n        files: jsonlStats.jsonlFileCount,\n        sessions: jsonlStats.sessionCount,\n      };\n    }\n\n    stats[name] = { available, failureCount, details };\n  }\n\n  return stats;\n}\n","/**\n * Generates LLM-powered explanations for why failures occurred.\n * This is the critical component - quality of explanations drives learning quality.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport * as dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\nimport type { FailureInput } from './data-sources/types.js';\nimport type { FailureExplanation } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\nexport interface ExplanationResult {\n  whatWentWrong: string;\n  whyItFailed: string;\n  rootCause: string;\n  suggestedFix: string;\n  patternCategory: string;\n  affectedComponent?: string;\n  confidence: number;\n}\n\nexport function parseExplanationResponse(text: string): ExplanationResult {\n  const jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n  const jsonContent = jsonMatch ? jsonMatch[1] : text;\n\n  try {\n    const parsed = JSON.parse(jsonContent.trim());\n\n    return {\n      whatWentWrong: parsed.whatWentWrong || 'Unknown',\n      whyItFailed: parsed.whyItFailed || 'Unknown',\n      rootCause: parsed.rootCause || 'Unknown',\n      suggestedFix: parsed.suggestedFix || 'No suggestion',\n      patternCategory: parsed.patternCategory || 'other',\n      affectedComponent: parsed.affectedComponent,\n      confidence: Math.max(0, Math.min(1, parsed.confidence || 0.5)),\n    };\n  } catch {\n    return {\n      whatWentWrong: 'Failed to parse response',\n      whyItFailed: text.substring(0, 500),\n      rootCause: 'Parse error',\n      suggestedFix: 'Manual review required',\n      patternCategory: 'other',\n      confidence: 0,\n    };\n  }\n}\n\ntype AnthropicClient = import('@anthropic-ai/sdk').default;\n\nexport class ExplanationGenerator {\n  private anthropic: AnthropicClient | null = null;\n  private config: LearningConfig;\n  private promptTemplate: string | null = null;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  private async getAnthropicClient(): Promise<AnthropicClient> {\n    if (!this.anthropic) {\n      const { default: Anthropic } = await import('@anthropic-ai/sdk');\n      this.anthropic = new Anthropic();\n    }\n    return this.anthropic;\n  }\n\n  /**\n   * Loads the failure analysis prompt template\n   */\n  private async loadPromptTemplate(): Promise<string> {\n    if (this.promptTemplate) {\n      return this.promptTemplate;\n    }\n\n    const promptPath = path.join(\n      this.config.promptsDir,\n      'failure-analysis.md'\n    );\n\n    try {\n      this.promptTemplate = await fs.readFile(promptPath, 'utf-8');\n      return this.promptTemplate;\n    } catch (error) {\n      throw new Error(\n        `Failed to load failure analysis prompt from ${promptPath}: ${error}`\n      );\n    }\n  }\n\n  /**\n   * Builds the prompt for a specific failure\n   */\n  private async buildPrompt(failure: FailureInput): Promise<string> {\n    const template = await this.loadPromptTemplate();\n\n    // Format tool calls\n    const toolCallsFormatted = failure.toolCalls?.length\n      ? failure.toolCalls\n          .map(\n            (tc) =>\n              `- ${tc.name}${tc.error ? ` (error: ${tc.error})` : ''}`\n          )\n          .join('\\n')\n      : 'None';\n\n    // Format judge results\n    const judgeResultsFormatted = failure.judgeResults?.length\n      ? failure.judgeResults\n          .map(\n            (jr) =>\n              `- ${jr.judgeId}: ${jr.passed ? 'PASSED' : 'FAILED'} (score: ${jr.score})\\n  Reasoning: ${jr.reasoning}`\n          )\n          .join('\\n')\n      : 'None';\n\n    // Replace template variables\n    let prompt = template\n      .replace('{{evalName}}', failure.metadata?.evalName as string ?? failure.id)\n      .replace('{{category}}', failure.category ?? 'unknown')\n      .replace('{{description}}', failure.metadata?.evalDescription as string ?? '')\n      .replace('{{prompt}}', failure.prompt)\n      .replace('{{expectedBehavior}}', failure.expectedBehavior ?? 'Not specified')\n      .replace('{{toolCalls}}', toolCallsFormatted)\n      .replace('{{output}}', failure.output || 'No output')\n      .replace('{{judgeResults}}', judgeResultsFormatted);\n\n    // Handle conditional error section\n    if (failure.error) {\n      prompt = prompt.replace('{{#if error}}', '').replace('{{/if}}', '');\n      prompt = prompt.replace('{{error}}', failure.error);\n    } else {\n      // Remove the error section if no error\n      prompt = prompt.replace(/{{#if error}}[\\s\\S]*?{{\\/if}}/g, '');\n    }\n\n    return prompt;\n  }\n\n  private parseResponse(text: string): ExplanationResult {\n    return parseExplanationResponse(text);\n  }\n\n  /**\n   * Generates an explanation for a single failure\n   */\n  async generateExplanation(failure: FailureInput): Promise<FailureExplanation> {\n    const prompt = await this.buildPrompt(failure);\n\n    try {\n      const client = await this.getAnthropicClient();\n      const response = await client.messages.create({\n        model: this.config.explanationModel,\n        max_tokens: 1024,\n        messages: [{ role: 'user', content: prompt }],\n      });\n\n      const content = response.content[0];\n      if (content.type !== 'text') {\n        throw new Error('Unexpected response type from LLM');\n      }\n\n      const explanation = this.parseResponse(content.text);\n\n      return {\n        id: `explanation-${failure.id}-${Date.now()}`,\n        failureInput: failure,\n        explanation,\n        confidence: explanation.confidence,\n        generatedAt: new Date().toISOString(),\n        model: this.config.explanationModel,\n      };\n    } catch (error) {\n      console.error(`Failed to generate explanation for ${failure.id}:`, error);\n\n      return {\n        id: `explanation-${failure.id}-${Date.now()}`,\n        failureInput: failure,\n        explanation: {\n          whatWentWrong: 'Failed to generate explanation',\n          whyItFailed: error instanceof Error ? error.message : 'Unknown error',\n          rootCause: 'LLM error',\n          suggestedFix: 'Manual review required',\n          patternCategory: 'other',\n        },\n        confidence: 0,\n        generatedAt: new Date().toISOString(),\n        model: this.config.explanationModel,\n      };\n    }\n  }\n\n  /**\n   * Generates explanations for multiple failures\n   */\n  async generateExplanations(\n    failures: FailureInput[],\n    options?: {\n      concurrency?: number;\n      onProgress?: (completed: number, total: number) => void;\n    }\n  ): Promise<FailureExplanation[]> {\n    const concurrency = options?.concurrency ?? 3;\n    const explanations: FailureExplanation[] = [];\n    let completed = 0;\n\n    // Process in batches\n    for (let i = 0; i < failures.length; i += concurrency) {\n      const batch = failures.slice(i, i + concurrency);\n      const batchResults = await Promise.all(\n        batch.map((f) => this.generateExplanation(f))\n      );\n      explanations.push(...batchResults);\n\n      completed += batch.length;\n      options?.onProgress?.(completed, failures.length);\n    }\n\n    return explanations;\n  }\n\n  /**\n   * Filters explanations by confidence threshold\n   */\n  filterByConfidence(\n    explanations: FailureExplanation[],\n    minConfidence: number = 0.5\n  ): FailureExplanation[] {\n    return explanations.filter((e) => e.confidence >= minConfidence);\n  }\n\n  /**\n   * Groups explanations by pattern category\n   */\n  groupByCategory(\n    explanations: FailureExplanation[]\n  ): Record<string, FailureExplanation[]> {\n    const grouped: Record<string, FailureExplanation[]> = {};\n\n    for (const explanation of explanations) {\n      const category = explanation.explanation.patternCategory;\n      if (!grouped[category]) {\n        grouped[category] = [];\n      }\n      grouped[category].push(explanation);\n    }\n\n    return grouped;\n  }\n}\n\nexport default ExplanationGenerator;\n","/**\n * Detects patterns across multiple failure explanations.\n * Groups similar failures to identify systemic issues.\n */\n\nimport type { FailureExplanation, FailurePattern } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\n/**\n * Simple text similarity using Jaccard index on word sets\n */\nfunction textSimilarity(a: string, b: string): number {\n  const wordsA = new Set(a.toLowerCase().split(/\\s+/).filter(w => w.length > 2));\n  const wordsB = new Set(b.toLowerCase().split(/\\s+/).filter(w => w.length > 2));\n\n  if (wordsA.size === 0 || wordsB.size === 0) {\n    return 0;\n  }\n\n  const intersection = new Set([...wordsA].filter(w => wordsB.has(w)));\n  const union = new Set([...wordsA, ...wordsB]);\n\n  return intersection.size / union.size;\n}\n\n/**\n * Calculates similarity between two failure explanations\n */\nfunction explanationSimilarity(a: FailureExplanation, b: FailureExplanation): number {\n  // If categories don't match, low similarity\n  if (a.explanation.patternCategory !== b.explanation.patternCategory) {\n    return 0.2;\n  }\n\n  // Compare root causes\n  const rootCauseSim = textSimilarity(\n    a.explanation.rootCause,\n    b.explanation.rootCause\n  );\n\n  // Compare what went wrong\n  const whatWrongSim = textSimilarity(\n    a.explanation.whatWentWrong,\n    b.explanation.whyItFailed\n  );\n\n  // Compare suggested fixes\n  const fixSim = textSimilarity(\n    a.explanation.suggestedFix,\n    b.explanation.suggestedFix\n  );\n\n  // Weighted average: root cause is most important\n  return rootCauseSim * 0.5 + whatWrongSim * 0.25 + fixSim * 0.25;\n}\n\n/**\n * Generates a pattern ID from a category and common words\n */\nfunction generatePatternId(\n  category: string,\n  explanations: FailureExplanation[]\n): string {\n  // Extract common words from root causes\n  const allWords = explanations\n    .flatMap(e => e.explanation.rootCause.toLowerCase().split(/\\s+/))\n    .filter(w => w.length > 3);\n\n  const wordCounts = new Map<string, number>();\n  for (const word of allWords) {\n    wordCounts.set(word, (wordCounts.get(word) || 0) + 1);\n  }\n\n  // Get top 2 most common words\n  const topWords = [...wordCounts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 2)\n    .map(([word]) => word);\n\n  const suffix = topWords.length > 0 ? `-${topWords.join('-')}` : '';\n  return `${category}${suffix}-${Date.now().toString(36)}`;\n}\n\n/**\n * Generates a human-readable pattern name\n */\nfunction generatePatternName(\n  category: string,\n  explanations: FailureExplanation[]\n): string {\n  // Use the most common affected component if available\n  const components = explanations\n    .map(e => e.explanation.affectedComponent)\n    .filter(Boolean);\n\n  const componentCounts = new Map<string, number>();\n  for (const comp of components) {\n    if (comp) {\n      componentCounts.set(comp, (componentCounts.get(comp) || 0) + 1);\n    }\n  }\n\n  const topComponent = [...componentCounts.entries()]\n    .sort((a, b) => b[1] - a[1])[0]?.[0];\n\n  const categoryName = category.replace(/-/g, ' ');\n\n  if (topComponent) {\n    return `${categoryName} in ${topComponent}`;\n  }\n\n  return `${categoryName} pattern`;\n}\n\n/**\n * Extracts common root causes from a group of explanations\n */\nfunction extractCommonRootCauses(explanations: FailureExplanation[]): string[] {\n  // Collect all root causes\n  const rootCauses = explanations.map(e => e.explanation.rootCause);\n\n  // Find unique-ish causes (not too similar to each other)\n  const uniqueCauses: string[] = [];\n\n  for (const cause of rootCauses) {\n    const isDuplicate = uniqueCauses.some(\n      existing => textSimilarity(existing, cause) > 0.7\n    );\n    if (!isDuplicate) {\n      uniqueCauses.push(cause);\n    }\n  }\n\n  return uniqueCauses.slice(0, 5); // Max 5 causes\n}\n\nexport class PatternDetector {\n  private config: LearningConfig;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  /**\n   * Detects patterns in a set of failure explanations\n   */\n  detectPatterns(explanations: FailureExplanation[]): FailurePattern[] {\n    if (explanations.length === 0) {\n      return [];\n    }\n\n    // First, group by category\n    const byCategory = new Map<string, FailureExplanation[]>();\n    for (const exp of explanations) {\n      const category = exp.explanation.patternCategory;\n      if (!byCategory.has(category)) {\n        byCategory.set(category, []);\n      }\n      byCategory.get(category)!.push(exp);\n    }\n\n    const patterns: FailurePattern[] = [];\n\n    // Process each category\n    for (const [category, categoryExplanations] of byCategory) {\n      // Skip if not enough failures to form a pattern\n      if (categoryExplanations.length < this.config.minFailuresForPattern) {\n        continue;\n      }\n\n      // Cluster within category using similarity\n      const clusters = this.clusterExplanations(\n        categoryExplanations,\n        this.config.similarityThreshold\n      );\n\n      // Convert clusters to patterns\n      for (const cluster of clusters) {\n        if (cluster.length >= this.config.minFailuresForPattern) {\n          patterns.push(this.createPattern(category, cluster));\n        }\n      }\n    }\n\n    // Sort by frequency (most common patterns first)\n    return patterns.sort((a, b) => b.frequency - a.frequency);\n  }\n\n  /**\n   * Clusters explanations by similarity\n   */\n  private clusterExplanations(\n    explanations: FailureExplanation[],\n    threshold: number\n  ): FailureExplanation[][] {\n    const clusters: FailureExplanation[][] = [];\n    const assigned = new Set<string>();\n\n    for (const exp of explanations) {\n      if (assigned.has(exp.id)) {\n        continue;\n      }\n\n      // Start a new cluster\n      const cluster = [exp];\n      assigned.add(exp.id);\n\n      // Find similar explanations\n      for (const other of explanations) {\n        if (assigned.has(other.id)) {\n          continue;\n        }\n\n        // Check similarity against all cluster members\n        const avgSimilarity =\n          cluster.reduce(\n            (sum, member) => sum + explanationSimilarity(member, other),\n            0\n          ) / cluster.length;\n\n        if (avgSimilarity >= threshold) {\n          cluster.push(other);\n          assigned.add(other.id);\n        }\n      }\n\n      clusters.push(cluster);\n    }\n\n    return clusters;\n  }\n\n  /**\n   * Creates a FailurePattern from a cluster of explanations\n   */\n  private createPattern(\n    category: string,\n    explanations: FailureExplanation[]\n  ): FailurePattern {\n    // Calculate average similarity within cluster\n    let totalSim = 0;\n    let pairCount = 0;\n    for (let i = 0; i < explanations.length; i++) {\n      for (let j = i + 1; j < explanations.length; j++) {\n        totalSim += explanationSimilarity(explanations[i], explanations[j]);\n        pairCount++;\n      }\n    }\n    const avgSimilarity = pairCount > 0 ? totalSim / pairCount : 1;\n\n    // Collect affected components\n    const components = new Set<string>();\n    for (const exp of explanations) {\n      if (exp.explanation.affectedComponent) {\n        components.add(exp.explanation.affectedComponent);\n      }\n    }\n\n    return {\n      patternId: generatePatternId(category, explanations),\n      patternName: generatePatternName(category, explanations),\n      category,\n      failures: explanations,\n      frequency: explanations.length,\n      affectedComponents: [...components],\n      commonRootCauses: extractCommonRootCauses(explanations),\n      similarityScore: avgSimilarity,\n      detectedAt: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Merges similar patterns across different runs\n   */\n  mergeWithExisting(\n    newPatterns: FailurePattern[],\n    existingPatterns: FailurePattern[]\n  ): FailurePattern[] {\n    const merged: FailurePattern[] = [...existingPatterns];\n\n    for (const newPattern of newPatterns) {\n      // Find existing pattern with same category and high similarity\n      const existingIndex = merged.findIndex(\n        existing =>\n          existing.category === newPattern.category &&\n          this.patternsAreSimilar(existing, newPattern)\n      );\n\n      if (existingIndex >= 0) {\n        // Merge into existing pattern\n        const existing = merged[existingIndex];\n        merged[existingIndex] = {\n          ...existing,\n          failures: [...existing.failures, ...newPattern.failures],\n          frequency: existing.frequency + newPattern.frequency,\n          affectedComponents: [\n            ...new Set([\n              ...existing.affectedComponents,\n              ...newPattern.affectedComponents,\n            ]),\n          ],\n          commonRootCauses: extractCommonRootCauses([\n            ...existing.failures,\n            ...newPattern.failures,\n          ]),\n        };\n      } else {\n        // Add as new pattern\n        merged.push(newPattern);\n      }\n    }\n\n    return merged;\n  }\n\n  /**\n   * Checks if two patterns are similar enough to merge\n   */\n  private patternsAreSimilar(a: FailurePattern, b: FailurePattern): boolean {\n    // Compare root causes\n    const aCauses = a.commonRootCauses.join(' ');\n    const bCauses = b.commonRootCauses.join(' ');\n\n    return textSimilarity(aCauses, bCauses) > 0.6;\n  }\n\n  /**\n   * Gets pattern statistics\n   */\n  getStats(patterns: FailurePattern[]): {\n    totalPatterns: number;\n    totalFailures: number;\n    avgPatterSize: number;\n    byCategory: Record<string, number>;\n  } {\n    const totalPatterns = patterns.length;\n    const totalFailures = patterns.reduce((sum, p) => sum + p.frequency, 0);\n    const avgPatterSize =\n      totalPatterns > 0 ? totalFailures / totalPatterns : 0;\n\n    const byCategory: Record<string, number> = {};\n    for (const pattern of patterns) {\n      byCategory[pattern.category] =\n        (byCategory[pattern.category] || 0) + pattern.frequency;\n    }\n\n    return {\n      totalPatterns,\n      totalFailures,\n      avgPatterSize,\n      byCategory,\n    };\n  }\n}\n\nexport default PatternDetector;\n","/**\n * Generates new prompt rules based on detected failure patterns.\n * Uses LLM to synthesize rules from pattern analysis.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport * as dotenv from 'dotenv';\n\n// Load environment variables\ndotenv.config();\nimport type { FailurePattern, ProposedRule } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\nexport interface RuleGenerationResult {\n  rule: string;\n  targetSection: string;\n  placement?: string;\n  rationale: string;\n  expectedImpact: {\n    evalIds: string[];\n    confidenceScore: number;\n  };\n}\n\nexport function parseRuleGenerationResponse(\n  text: string,\n  defaultTargetSection: string,\n  fallbackEvalIds: string[]\n): RuleGenerationResult {\n  const jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n  const jsonContent = jsonMatch ? jsonMatch[1] : text;\n\n  try {\n    const parsed = JSON.parse(jsonContent.trim());\n\n    return {\n      rule: parsed.rule || 'No rule generated',\n      targetSection: parsed.targetSection || defaultTargetSection,\n      placement: parsed.placement,\n      rationale: parsed.rationale || 'No rationale provided',\n      expectedImpact: {\n        evalIds: parsed.expectedImpact?.evalIds || fallbackEvalIds,\n        confidenceScore: Math.max(\n          0,\n          Math.min(1, parsed.expectedImpact?.confidenceScore || 0.5)\n        ),\n      },\n    };\n  } catch {\n    return {\n      rule: text.substring(0, 500),\n      targetSection: defaultTargetSection,\n      rationale: 'Failed to parse structured response',\n      expectedImpact: {\n        evalIds: fallbackEvalIds,\n        confidenceScore: 0.3,\n      },\n    };\n  }\n}\n\nexport function getTargetSectionForCategory(category: string): string {\n  return CATEGORY_TO_SECTION[category] || CATEGORY_TO_SECTION['other'];\n}\n\n/**\n * Maps pattern categories to prompt sections\n */\nconst CATEGORY_TO_SECTION: Record<string, string> = {\n  'routing-error': 'CHAT_PROMPT.delegationPrinciple',\n  'delegation-error': 'CHAT_PROMPT.delegationPrinciple',\n  'missing-tool-call': 'CHAT_PROMPT.troubleshooting',\n  'incorrect-code-pattern': 'CORE_INSTRUCTIONS',\n  'validation-failure': 'CORE_INSTRUCTIONS.coreSafetyRules',\n  'context-missing': 'CHAT_PROMPT.reasoningAndPlanning',\n  other: 'CORE_INSTRUCTIONS',\n};\n\ntype AnthropicClient = import('@anthropic-ai/sdk').default;\n\nexport class RuleGenerator {\n  private anthropic: AnthropicClient | null = null;\n  private config: LearningConfig;\n  private promptTemplate: string | null = null;\n  private currentInstructions: Map<string, string> = new Map();\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  private async getAnthropicClient(): Promise<AnthropicClient> {\n    if (!this.anthropic) {\n      const { default: Anthropic } = await import('@anthropic-ai/sdk');\n      this.anthropic = new Anthropic();\n    }\n    return this.anthropic;\n  }\n\n  /**\n   * Loads the rule generation prompt template\n   */\n  private async loadPromptTemplate(): Promise<string> {\n    if (this.promptTemplate) {\n      return this.promptTemplate;\n    }\n\n    const promptPath = path.join(this.config.promptsDir, 'rule-generation.md');\n\n    try {\n      this.promptTemplate = await fs.readFile(promptPath, 'utf-8');\n      return this.promptTemplate;\n    } catch (error) {\n      throw new Error(\n        `Failed to load rule generation prompt from ${promptPath}: ${error}`\n      );\n    }\n  }\n\n  /**\n   * Loads current instructions from prompt-templates.ts\n   * (Reads a simplified version for context)\n   */\n  async loadCurrentInstructions(): Promise<void> {\n    const templatePath = path.join(\n      this.config.learningDir,\n      '..',\n      '..',\n      'lib',\n      'ai',\n      'claude-code',\n      'prompt-templates.ts'\n    );\n\n    try {\n      const content = await fs.readFile(templatePath, 'utf-8');\n\n      // Extract major sections (simplified parsing)\n      const sections = [\n        'CORE_INSTRUCTIONS',\n        'CHAT_PROMPT',\n        'delegationPrinciple',\n        'coreSafetyRules',\n        'troubleshooting',\n      ];\n\n      for (const section of sections) {\n        const regex = new RegExp(\n          `${section}[:\\\\s]*[\\`'\"](.*?)[\\`'\"]`,\n          'gs'\n        );\n        const match = content.match(regex);\n        if (match) {\n          this.currentInstructions.set(\n            section,\n            match[0].substring(0, 500) + '...'\n          );\n        }\n      }\n    } catch (error) {\n      console.warn('Could not load current instructions:', error);\n    }\n  }\n\n  private getTargetSection(pattern: FailurePattern): string {\n    return getTargetSectionForCategory(pattern.category);\n  }\n\n  /**\n   * Builds the prompt for rule generation\n   */\n  private async buildPrompt(pattern: FailurePattern): Promise<string> {\n    const template = await this.loadPromptTemplate();\n    const targetSection = this.getTargetSection(pattern);\n\n    // Get current instructions for the target section\n    const sectionKey = targetSection.split('.')[0];\n    const currentInstructions =\n      this.currentInstructions.get(sectionKey) ||\n      '(Instructions not loaded)';\n\n    // Format failures\n    const failuresFormatted = pattern.failures\n      .slice(0, 5) // Limit to 5 examples\n      .map((f, i) => {\n        const evalName =\n          (f.failureInput.metadata?.evalName as string) ||\n          f.failureInput.id;\n        return `#### Failure ${i + 1}\n- **Eval**: ${evalName}\n- **What Went Wrong**: ${f.explanation.whatWentWrong}\n- **Why It Failed**: ${f.explanation.whyItFailed}\n- **Suggested Fix**: ${f.explanation.suggestedFix}`;\n      })\n      .join('\\n\\n');\n\n    // Replace template variables\n    let prompt = template\n      .replace('{{targetSection}}', targetSection)\n      .replace('{{currentInstructions}}', currentInstructions)\n      .replace('{{patternName}}', pattern.patternName)\n      .replace('{{patternCategory}}', pattern.category)\n      .replace('{{frequency}}', pattern.frequency.toString())\n      .replace('{{affectedComponents}}', pattern.affectedComponents.join(', ') || 'None specified')\n      .replace('{{commonRootCauses}}', pattern.commonRootCauses.join('\\n- ') || 'None identified');\n\n    // Handle the failures loop\n    prompt = prompt.replace(\n      /{{#each failures}}[\\s\\S]*?{{\\/each}}/g,\n      failuresFormatted\n    );\n\n    return prompt;\n  }\n\n  private parseResponse(text: string, pattern: FailurePattern): RuleGenerationResult {\n    const fallbackEvalIds = pattern.failures.slice(0, 5).map((f) => f.failureInput.id);\n    return parseRuleGenerationResponse(\n      text,\n      this.getTargetSection(pattern),\n      fallbackEvalIds\n    );\n  }\n\n  /**\n   * Generates a rule for a single pattern\n   */\n  async generateRule(pattern: FailurePattern): Promise<ProposedRule> {\n    const prompt = await this.buildPrompt(pattern);\n\n    try {\n      const client = await this.getAnthropicClient();\n      const response = await client.messages.create({\n        model: this.config.ruleGenerationModel,\n        max_tokens: 1024,\n        messages: [{ role: 'user', content: prompt }],\n      });\n\n      const content = response.content[0];\n      if (content.type !== 'text') {\n        throw new Error('Unexpected response type from LLM');\n      }\n\n      const result = this.parseResponse(content.text, pattern);\n\n      return {\n        ruleId: `rule-${pattern.patternId}`,\n        ruleContent: result.rule,\n        targetSection: result.targetSection,\n        placement: result.placement,\n        rationale: result.rationale,\n        addressesPatterns: [pattern.patternId],\n        expectedImpact: {\n          failureIds: result.expectedImpact.evalIds,\n          confidenceScore: result.expectedImpact.confidenceScore,\n        },\n        status: 'pending',\n        generatedAt: new Date().toISOString(),\n        model: this.config.ruleGenerationModel,\n        source: `iteration-${new Date().toISOString().split('T')[0]}`,\n      };\n    } catch (error) {\n      console.error(`Failed to generate rule for pattern ${pattern.patternId}:`, error);\n\n      return {\n        ruleId: `rule-${pattern.patternId}`,\n        ruleContent: `[Generation failed: ${error instanceof Error ? error.message : 'Unknown error'}]`,\n        targetSection: this.getTargetSection(pattern),\n        rationale: 'Rule generation failed',\n        addressesPatterns: [pattern.patternId],\n        expectedImpact: {\n          failureIds: [],\n          confidenceScore: 0,\n        },\n        status: 'pending',\n        generatedAt: new Date().toISOString(),\n        model: this.config.ruleGenerationModel,\n        source: `iteration-${new Date().toISOString().split('T')[0]}`,\n      };\n    }\n  }\n\n  /**\n   * Generates rules for multiple patterns\n   */\n  async generateRules(\n    patterns: FailurePattern[],\n    options?: {\n      maxRules?: number;\n      onProgress?: (completed: number, total: number) => void;\n    }\n  ): Promise<ProposedRule[]> {\n    // Load current instructions first\n    await this.loadCurrentInstructions();\n\n    // Limit patterns to process\n    const maxRules = options?.maxRules ?? this.config.maxRulesPerIteration;\n    const patternsToProcess = patterns.slice(0, maxRules);\n\n    const rules: ProposedRule[] = [];\n\n    for (let i = 0; i < patternsToProcess.length; i++) {\n      const pattern = patternsToProcess[i];\n      const rule = await this.generateRule(pattern);\n      rules.push(rule);\n\n      options?.onProgress?.(i + 1, patternsToProcess.length);\n    }\n\n    return rules;\n  }\n\n  /**\n   * Filters rules by confidence\n   */\n  filterByConfidence(\n    rules: ProposedRule[],\n    minConfidence?: number\n  ): ProposedRule[] {\n    const threshold = minConfidence ?? this.config.minRuleConfidence;\n    return rules.filter(\n      (r) => r.expectedImpact.confidenceScore >= threshold\n    );\n  }\n\n  /**\n   * Checks for conflicts between a new rule and existing rules\n   */\n  checkForConflicts(\n    newRule: ProposedRule,\n    existingRules: ProposedRule[]\n  ): { hasConflict: boolean; conflictingRules: ProposedRule[] } {\n    const conflicting = existingRules.filter((existing) => {\n      // Same target section\n      if (existing.targetSection !== newRule.targetSection) {\n        return false;\n      }\n\n      // Check for contradictory keywords\n      const newLower = newRule.ruleContent.toLowerCase();\n      const existingLower = existing.ruleContent.toLowerCase();\n\n      // Simple conflict detection: opposite instructions\n      const hasAlways = newLower.includes('always');\n      const hasNever = newLower.includes('never');\n      const existingHasAlways = existingLower.includes('always');\n      const existingHasNever = existingLower.includes('never');\n\n      if ((hasAlways && existingHasNever) || (hasNever && existingHasAlways)) {\n        // Check if they're about the same topic (rough heuristic)\n        const newWords = new Set(newLower.split(/\\s+/).filter(w => w.length > 4));\n        const existingWords = new Set(existingLower.split(/\\s+/).filter(w => w.length > 4));\n        const commonWords = [...newWords].filter(w => existingWords.has(w));\n\n        if (commonWords.length > 2) {\n          return true;\n        }\n      }\n\n      return false;\n    });\n\n    return {\n      hasConflict: conflicting.length > 0,\n      conflictingRules: conflicting,\n    };\n  }\n}\n\nexport default RuleGenerator;\n","/**\n * Interactive CLI for reviewing proposed rules.\n * Provides a human-in-the-loop interface for approving/rejecting rules.\n */\n\nimport * as readline from 'readline';\nimport type { ProposedRule, FailurePattern } from './types.js';\n\nexport interface ReviewDecision {\n  rule: ProposedRule;\n  decision: 'approve' | 'reject' | 'modify' | 'skip';\n  notes?: string;\n  modifiedRule?: string;\n}\n\nexport interface ReviewSession {\n  decisions: ReviewDecision[];\n  approved: ProposedRule[];\n  rejected: ProposedRule[];\n  skipped: ProposedRule[];\n}\n\n/**\n * Formats a rule for display\n */\nfunction formatRuleDisplay(rule: ProposedRule, index: number, total: number): string {\n  const header = `\n\n  PROMPT LEARNING: RULE REVIEW (${index + 1}/${total})\n`;\n\n  const ruleBox = `\n\n ${rule.ruleContent.split('\\n').map(line => line.padEnd(63)).join('\\n ')}\n`;\n\n  const evidence = `\nEvidence:\n  - Pattern: ${rule.addressesPatterns.join(', ')}\n  - Target: ${rule.targetSection}\n  - Confidence: ${(rule.expectedImpact.confidenceScore * 100).toFixed(0)}%\n  - Affects: ${rule.expectedImpact.failureIds.slice(0, 3).join(', ')}${rule.expectedImpact.failureIds.length > 3 ? '...' : ''}\n\nRationale:\n  ${rule.rationale}`;\n\n  return header + '\\n' + ruleBox + evidence;\n}\n\n/**\n * Interactive CLI reviewer for proposed rules\n */\nexport class CLIReviewer {\n  private rl: readline.Interface | null = null;\n\n  /**\n   * Creates readline interface\n   */\n  private createInterface(): readline.Interface {\n    return readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n  }\n\n  /**\n   * Prompts user for input\n   */\n  private async prompt(question: string): Promise<string> {\n    return new Promise((resolve) => {\n      this.rl?.question(question, (answer) => {\n        resolve(answer.trim().toLowerCase());\n      });\n    });\n  }\n\n  /**\n   * Prompts for multi-line input\n   */\n  private async promptMultiline(prompt: string): Promise<string> {\n    console.log(prompt);\n    console.log('(Enter an empty line to finish)');\n\n    const lines: string[] = [];\n    let line = await this.prompt('> ');\n\n    while (line !== '') {\n      lines.push(line);\n      line = await this.prompt('> ');\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Reviews a single rule\n   */\n  private async reviewRule(\n    rule: ProposedRule,\n    index: number,\n    total: number\n  ): Promise<ReviewDecision> {\n    console.log(formatRuleDisplay(rule, index, total));\n    console.log('\\n[A]pprove  [R]eject  [M]odify  [S]kip  [Q]uit\\n');\n\n    const answer = await this.prompt('Your choice: ');\n\n    switch (answer) {\n      case 'a':\n      case 'approve':\n        const approveNotes = await this.prompt('Notes (optional): ');\n        return {\n          rule: { ...rule, status: 'approved' },\n          decision: 'approve',\n          notes: approveNotes || undefined,\n        };\n\n      case 'r':\n      case 'reject':\n        const rejectReason = await this.prompt('Reason for rejection: ');\n        return {\n          rule: { ...rule, status: 'rejected', reviewNotes: rejectReason },\n          decision: 'reject',\n          notes: rejectReason,\n        };\n\n      case 'm':\n      case 'modify':\n        console.log('\\nCurrent rule:');\n        console.log(rule.ruleContent);\n        const modified = await this.promptMultiline('\\nEnter modified rule:');\n        return {\n          rule: { ...rule, status: 'approved', ruleContent: modified },\n          decision: 'modify',\n          modifiedRule: modified,\n        };\n\n      case 's':\n      case 'skip':\n        return {\n          rule,\n          decision: 'skip',\n        };\n\n      case 'q':\n      case 'quit':\n        throw new Error('Review session aborted by user');\n\n      default:\n        console.log('Invalid choice. Please try again.');\n        return this.reviewRule(rule, index, total);\n    }\n  }\n\n  /**\n   * Starts an interactive review session\n   */\n  async startReviewSession(rules: ProposedRule[]): Promise<ReviewSession> {\n    if (rules.length === 0) {\n      console.log('No rules to review.');\n      return { decisions: [], approved: [], rejected: [], skipped: [] };\n    }\n\n    this.rl = this.createInterface();\n\n    console.log(`\\n`);\n    console.log(`              PROMPT LEARNING SYSTEM                            `);\n    console.log(`              Interactive Rule Review                           `);\n    console.log(``);\n    console.log(`  ${rules.length} rule(s) to review                                          `);\n    console.log(`                                                                `);\n    console.log(`  Commands:                                                     `);\n    console.log(`    [A]pprove - Accept the rule as-is                          `);\n    console.log(`    [R]eject  - Reject the rule with reason                    `);\n    console.log(`    [M]odify  - Edit the rule before approving                 `);\n    console.log(`    [S]kip    - Skip for now, review later                     `);\n    console.log(`    [Q]uit    - Exit review session                            `);\n    console.log(`\\n`);\n\n    const decisions: ReviewDecision[] = [];\n    const approved: ProposedRule[] = [];\n    const rejected: ProposedRule[] = [];\n    const skipped: ProposedRule[] = [];\n\n    try {\n      for (let i = 0; i < rules.length; i++) {\n        const decision = await this.reviewRule(rules[i], i, rules.length);\n        decisions.push(decision);\n\n        switch (decision.decision) {\n          case 'approve':\n          case 'modify':\n            approved.push(decision.rule);\n            break;\n          case 'reject':\n            rejected.push(decision.rule);\n            break;\n          case 'skip':\n            skipped.push(decision.rule);\n            break;\n        }\n      }\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('aborted')) {\n        console.log('\\nReview session aborted.');\n      } else {\n        throw error;\n      }\n    } finally {\n      this.rl?.close();\n      this.rl = null;\n    }\n\n    // Print summary\n    console.log('\\n');\n    console.log('  REVIEW SESSION COMPLETE');\n    console.log('');\n    console.log(`  Approved: ${approved.length}`);\n    console.log(`  Rejected: ${rejected.length}`);\n    console.log(`  Skipped:  ${skipped.length}`);\n    console.log('\\n');\n\n    return { decisions, approved, rejected, skipped };\n  }\n\n  /**\n   * Prints a summary of rules without interactive review\n   */\n  printRulesSummary(rules: ProposedRule[]): void {\n    console.log('\\n');\n    console.log('              PROPOSED RULES SUMMARY                            ');\n    console.log('\\n');\n\n    for (const [i, rule] of rules.entries()) {\n      console.log(`[${i + 1}] ${rule.ruleId}`);\n      console.log(`    Target: ${rule.targetSection}`);\n      console.log(`    Confidence: ${(rule.expectedImpact.confidenceScore * 100).toFixed(0)}%`);\n      console.log(`    Rule: ${rule.ruleContent.substring(0, 80)}...`);\n      console.log('');\n    }\n  }\n\n  /**\n   * Quick approve all rules (for non-interactive mode)\n   */\n  autoApproveAll(\n    rules: ProposedRule[],\n    minConfidence: number = 0.8\n  ): ReviewSession {\n    const decisions: ReviewDecision[] = [];\n    const approved: ProposedRule[] = [];\n    const rejected: ProposedRule[] = [];\n    const skipped: ProposedRule[] = [];\n\n    for (const rule of rules) {\n      if (rule.expectedImpact.confidenceScore >= minConfidence) {\n        const approvedRule = { ...rule, status: 'approved' as const };\n        decisions.push({ rule: approvedRule, decision: 'approve' });\n        approved.push(approvedRule);\n      } else {\n        decisions.push({ rule, decision: 'skip' });\n        skipped.push(rule);\n      }\n    }\n\n    return { decisions, approved, rejected, skipped };\n  }\n}\n\nexport default CLIReviewer;\n","/**\n * Writes approved rules to the learned-rules.json file.\n * Manages the rules storage lifecycle.\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport type { ProposedRule, LearnedRulesFile, LearningHistory, LearningIterationResult } from './types.js';\nimport { getLearningConfig, type LearningConfig } from './config.js';\n\nexport class RuleWriter {\n  private config: LearningConfig;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig(config);\n  }\n\n  /**\n   * Ensures rules directories exist\n   */\n  async ensureDirectories(): Promise<void> {\n    await fs.mkdir(this.config.rulesDir, { recursive: true });\n    await fs.mkdir(this.config.pendingDir, { recursive: true });\n    await fs.mkdir(this.config.approvedDir, { recursive: true });\n    await fs.mkdir(this.config.rejectedDir, { recursive: true });\n  }\n\n  /**\n   * Reads the current learned rules file\n   */\n  async readLearnedRules(): Promise<LearnedRulesFile> {\n    try {\n      const content = await fs.readFile(this.config.learnedRulesPath, 'utf-8');\n      return JSON.parse(content) as LearnedRulesFile;\n    } catch {\n      // File doesn't exist or is invalid, return empty\n      return {\n        rules: [],\n        lastUpdated: new Date().toISOString(),\n        iterations: [],\n      };\n    }\n  }\n\n  /**\n   * Writes rules to the learned rules file\n   */\n  async writeLearnedRules(rules: LearnedRulesFile): Promise<void> {\n    await this.ensureDirectories();\n\n    const content = JSON.stringify(rules, null, 2);\n    await fs.writeFile(this.config.learnedRulesPath, content, 'utf-8');\n  }\n\n  /**\n   * Adds approved rules to the learned rules file\n   */\n  async addApprovedRules(\n    rules: ProposedRule[],\n    iterationId: string\n  ): Promise<void> {\n    const current = await this.readLearnedRules();\n\n    // Add new rules\n    for (const rule of rules) {\n      // Check if rule already exists (by ID)\n      const existingIndex = current.rules.findIndex(\n        (r) => r.ruleId === rule.ruleId\n      );\n\n      if (existingIndex >= 0) {\n        // Update existing rule\n        current.rules[existingIndex] = { ...rule, status: 'approved' };\n      } else {\n        // Add new rule\n        current.rules.push({ ...rule, status: 'approved' });\n      }\n    }\n\n    // Update metadata\n    current.lastUpdated = new Date().toISOString();\n    if (!current.iterations.includes(iterationId)) {\n      current.iterations.push(iterationId);\n    }\n\n    await this.writeLearnedRules(current);\n  }\n\n  /**\n   * Saves a rule to the pending directory for later review\n   */\n  async savePendingRule(rule: ProposedRule): Promise<string> {\n    await this.ensureDirectories();\n\n    const filename = `${rule.ruleId}.json`;\n    const filepath = path.join(this.config.pendingDir, filename);\n\n    await fs.writeFile(filepath, JSON.stringify(rule, null, 2), 'utf-8');\n\n    return filepath;\n  }\n\n  /**\n   * Saves multiple pending rules\n   */\n  async savePendingRules(rules: ProposedRule[]): Promise<string[]> {\n    const paths: string[] = [];\n    for (const rule of rules) {\n      const filepath = await this.savePendingRule(rule);\n      paths.push(filepath);\n    }\n    return paths;\n  }\n\n  /**\n   * Loads pending rules from the pending directory\n   */\n  async loadPendingRules(): Promise<ProposedRule[]> {\n    try {\n      const files = await fs.readdir(this.config.pendingDir);\n      const jsonFiles = files.filter((f) => f.endsWith('.json'));\n\n      const rules: ProposedRule[] = [];\n      for (const file of jsonFiles) {\n        const filepath = path.join(this.config.pendingDir, file);\n        const content = await fs.readFile(filepath, 'utf-8');\n        rules.push(JSON.parse(content) as ProposedRule);\n      }\n\n      return rules;\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Moves a pending rule to approved\n   */\n  async approvePendingRule(ruleId: string): Promise<void> {\n    const pendingPath = path.join(this.config.pendingDir, `${ruleId}.json`);\n    const approvedPath = path.join(this.config.approvedDir, `${ruleId}.json`);\n\n    try {\n      const content = await fs.readFile(pendingPath, 'utf-8');\n      const rule = JSON.parse(content) as ProposedRule;\n      rule.status = 'approved';\n\n      await fs.writeFile(approvedPath, JSON.stringify(rule, null, 2), 'utf-8');\n      await fs.unlink(pendingPath);\n\n      // Also add to learned rules\n      await this.addApprovedRules([rule], `manual-${Date.now()}`);\n    } catch (error) {\n      throw new Error(`Failed to approve rule ${ruleId}: ${error}`);\n    }\n  }\n\n  /**\n   * Moves a pending rule to rejected\n   */\n  async rejectPendingRule(ruleId: string, reason: string): Promise<void> {\n    const pendingPath = path.join(this.config.pendingDir, `${ruleId}.json`);\n    const rejectedPath = path.join(this.config.rejectedDir, `${ruleId}.json`);\n\n    try {\n      const content = await fs.readFile(pendingPath, 'utf-8');\n      const rule = JSON.parse(content) as ProposedRule;\n      rule.status = 'rejected';\n      rule.reviewNotes = reason;\n\n      await fs.writeFile(rejectedPath, JSON.stringify(rule, null, 2), 'utf-8');\n      await fs.unlink(pendingPath);\n    } catch (error) {\n      throw new Error(`Failed to reject rule ${ruleId}: ${error}`);\n    }\n  }\n\n  /**\n   * Clears all pending rules\n   */\n  async clearPendingRules(): Promise<number> {\n    try {\n      const files = await fs.readdir(this.config.pendingDir);\n      for (const file of files) {\n        await fs.unlink(path.join(this.config.pendingDir, file));\n      }\n      return files.length;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Reads the learning history\n   */\n  async readHistory(): Promise<LearningHistory> {\n    try {\n      const content = await fs.readFile(this.config.historyPath, 'utf-8');\n      return JSON.parse(content) as LearningHistory;\n    } catch {\n      return {\n        iterations: [],\n        totalRulesGenerated: 0,\n        totalRulesApproved: 0,\n        totalRulesRejected: 0,\n        lastRunAt: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Writes the learning history\n   */\n  async writeHistory(history: LearningHistory): Promise<void> {\n    await this.ensureDirectories();\n    await fs.writeFile(\n      this.config.historyPath,\n      JSON.stringify(history, null, 2),\n      'utf-8'\n    );\n  }\n\n  /**\n   * Adds a learning iteration to the history\n   */\n  async addIterationToHistory(\n    iteration: LearningIterationResult\n  ): Promise<void> {\n    const history = await this.readHistory();\n\n    history.iterations.push(iteration);\n    history.totalRulesGenerated += iteration.rulesProposed.length;\n    history.totalRulesApproved += iteration.rulesApproved.length;\n    history.totalRulesRejected += iteration.rulesRejected.length;\n    history.lastRunAt = iteration.timestamp;\n\n    await this.writeHistory(history);\n  }\n\n  /**\n   * Gets statistics about stored rules\n   */\n  async getStats(): Promise<{\n    totalRules: number;\n    pendingCount: number;\n    approvedCount: number;\n    rejectedCount: number;\n    iterationsCount: number;\n  }> {\n    const rules = await this.readLearnedRules();\n    const pending = await this.loadPendingRules();\n    const history = await this.readHistory();\n\n    let approvedCount = 0;\n    let rejectedCount = 0;\n\n    try {\n      approvedCount = (await fs.readdir(this.config.approvedDir)).length;\n    } catch {\n      // Directory doesn't exist\n    }\n\n    try {\n      rejectedCount = (await fs.readdir(this.config.rejectedDir)).length;\n    } catch {\n      // Directory doesn't exist\n    }\n\n    return {\n      totalRules: rules.rules.length,\n      pendingCount: pending.length,\n      approvedCount,\n      rejectedCount,\n      iterationsCount: history.iterations.length,\n    };\n  }\n}\n\nexport default RuleWriter;\n","/**\n * Learning Loop Runner\n * Orchestrates the full prompt learning pipeline.\n */\n\nimport { collectFromSources, getSourceStats } from './data-sources/index.js';\nimport { ExplanationGenerator } from './explanation-generator.js';\nimport { PatternDetector } from './pattern-detector.js';\nimport { RuleGenerator } from './rule-generator.js';\nimport { CLIReviewer } from './cli-reviewer.js';\nimport { RuleWriter } from './rule-writer.js';\nimport type {\n  FailureInput,\n  FailureExplanation,\n  FailurePattern,\n  ProposedRule,\n  LearningIterationResult,\n  CollectOptions,\n} from './types.js';\nimport { getLearningConfig, getConfigFromEnv, type LearningConfig } from './config';\n\nexport interface LearningOptions {\n  /** Data sources to use */\n  sources?: string[];\n\n  /** Options for collecting failures */\n  collectOptions?: CollectOptions;\n\n  /** Project ID for production data source (fetches from S3) */\n  projectId?: string;\n\n  /** Task ID for production data source (optional) */\n  taskId?: string;\n\n  /** Skip interactive review (use auto-approve) */\n  autoApprove?: boolean;\n\n  /** Minimum confidence for auto-approve */\n  autoApproveThreshold?: number;\n\n  /** Save pending rules for later review */\n  savePending?: boolean;\n\n  /** Run validation after applying rules */\n  validate?: boolean;\n\n  /** Progress callback */\n  onProgress?: (stage: string, progress: number, total: number) => void;\n}\n\nexport class LearningRunner {\n  private config: LearningConfig;\n  private explanationGenerator: ExplanationGenerator;\n  private patternDetector: PatternDetector;\n  private ruleGenerator: RuleGenerator;\n  private cliReviewer: CLIReviewer;\n  private ruleWriter: RuleWriter;\n\n  constructor(config?: Partial<LearningConfig>) {\n    this.config = getLearningConfig({ ...getConfigFromEnv(), ...config });\n    this.explanationGenerator = new ExplanationGenerator(this.config);\n    this.patternDetector = new PatternDetector(this.config);\n    this.ruleGenerator = new RuleGenerator(this.config);\n    this.cliReviewer = new CLIReviewer();\n    this.ruleWriter = new RuleWriter(this.config);\n  }\n\n  /**\n   * Runs a full learning iteration\n   */\n  async runIteration(options: LearningOptions = {}): Promise<LearningIterationResult> {\n    const startTime = Date.now();\n    const iterationId = `iteration-${new Date().toISOString().replace(/[:.]/g, '-')}`;\n\n    console.log('\\n');\n    console.log('              PROMPT LEARNING SYSTEM                            ');\n    console.log('              Starting Learning Iteration                       ');\n    console.log('\\n');\n\n    // Phase 1: Collect failures\n    console.log(' Phase 1: Collecting failures...');\n    const sources = options.sources || ['eval', 'jsonl'];\n\n    // Merge projectId and taskId into collectOptions for production source\n    const collectOptions: CollectOptions = {\n      ...options.collectOptions,\n      projectId: options.projectId,\n      taskId: options.taskId,\n    };\n\n    const failures = await collectFromSources(sources, collectOptions);\n    console.log(`   Found ${failures.length} failures from ${sources.join(', ')}`);\n\n    if (failures.length === 0) {\n      console.log('\\n No failures to analyze. System is performing well!\\n');\n      return this.createEmptyResult(iterationId, startTime, sources);\n    }\n\n    // Phase 2: Generate explanations\n    console.log('\\n Phase 2: Generating failure explanations...');\n    const explanations = await this.explanationGenerator.generateExplanations(\n      failures,\n      {\n        concurrency: 3,\n        onProgress: (completed, total) => {\n          process.stdout.write(`\\r   Progress: ${completed}/${total}`);\n          options.onProgress?.('explanations', completed, total);\n        },\n      }\n    );\n    console.log(`\\n   Generated ${explanations.length} explanations`);\n\n    // Phase 3: Detect patterns\n    console.log('\\n Phase 3: Detecting patterns...');\n    const patterns = this.patternDetector.detectPatterns(explanations);\n    console.log(`   Detected ${patterns.length} patterns`);\n\n    if (patterns.length === 0) {\n      console.log('\\n  No patterns detected. Failures may be too diverse.\\n');\n      return this.createResult(\n        iterationId,\n        startTime,\n        sources,\n        failures.length,\n        explanations.length,\n        [],\n        [],\n        [],\n        []\n      );\n    }\n\n    // Print pattern summary\n    this.printPatternSummary(patterns);\n\n    // Phase 4: Generate rules\n    console.log('\\n Phase 4: Generating rules...');\n    const proposedRules = await this.ruleGenerator.generateRules(patterns, {\n      maxRules: this.config.maxRulesPerIteration,\n      onProgress: (completed, total) => {\n        process.stdout.write(`\\r   Progress: ${completed}/${total}`);\n        options.onProgress?.('rules', completed, total);\n      },\n    });\n    console.log(`\\n   Generated ${proposedRules.length} proposed rules`);\n\n    // Filter low-confidence rules\n    const filteredRules = this.ruleGenerator.filterByConfidence(proposedRules);\n    console.log(`   ${filteredRules.length} rules pass confidence threshold`);\n\n    if (filteredRules.length === 0) {\n      console.log('\\n  No rules passed confidence threshold.\\n');\n      return this.createResult(\n        iterationId,\n        startTime,\n        sources,\n        failures.length,\n        explanations.length,\n        patterns,\n        proposedRules,\n        [],\n        []\n      );\n    }\n\n    // Phase 5: Human review or auto-approve\n    let approvedRules: ProposedRule[] = [];\n    let rejectedRules: ProposedRule[] = [];\n\n    if (options.autoApprove) {\n      console.log('\\n Phase 5: Auto-approving rules...');\n      const session = this.cliReviewer.autoApproveAll(\n        filteredRules,\n        options.autoApproveThreshold || 0.8\n      );\n      approvedRules = session.approved;\n      rejectedRules = session.rejected;\n      console.log(`   Auto-approved: ${approvedRules.length}, Skipped: ${session.skipped.length}`);\n    } else if (options.savePending) {\n      console.log('\\n Phase 5: Saving rules for later review...');\n      await this.ruleWriter.savePendingRules(filteredRules);\n      console.log(`   Saved ${filteredRules.length} rules to pending/`);\n      console.log('   Run \"npm run learn:review\" to review them');\n    } else {\n      console.log('\\n Phase 5: Interactive review...');\n      const session = await this.cliReviewer.startReviewSession(filteredRules);\n      approvedRules = session.approved;\n      rejectedRules = session.rejected;\n    }\n\n    // Phase 6: Save approved rules\n    if (approvedRules.length > 0) {\n      console.log('\\n Phase 6: Saving approved rules...');\n      await this.ruleWriter.addApprovedRules(approvedRules, iterationId);\n      console.log(`   Saved ${approvedRules.length} rules to learned-rules.json`);\n    }\n\n    // Create and save iteration result\n    const result = this.createResult(\n      iterationId,\n      startTime,\n      sources,\n      failures.length,\n      explanations.length,\n      patterns,\n      proposedRules,\n      approvedRules,\n      rejectedRules\n    );\n\n    await this.ruleWriter.addIterationToHistory(result);\n\n    // Print summary\n    this.printIterationSummary(result);\n\n    return result;\n  }\n\n  /**\n   * Analyzes failures without generating rules\n   */\n  async analyze(options: LearningOptions = {}): Promise<{\n    failures: FailureInput[];\n    explanations: FailureExplanation[];\n    patterns: FailurePattern[];\n  }> {\n    console.log('\\n ANALYZE MODE: Collecting and analyzing failures...\\n');\n\n    const sources = options.sources || ['eval', 'jsonl'];\n\n    // Merge projectId and taskId into collectOptions for production source\n    const collectOptions: CollectOptions = {\n      ...options.collectOptions,\n      projectId: options.projectId,\n      taskId: options.taskId,\n    };\n\n    const failures = await collectFromSources(sources, collectOptions);\n    console.log(`Found ${failures.length} failures`);\n\n    if (failures.length === 0) {\n      return { failures: [], explanations: [], patterns: [] };\n    }\n\n    const explanations = await this.explanationGenerator.generateExplanations(\n      failures,\n      { concurrency: 3 }\n    );\n    console.log(`Generated ${explanations.length} explanations`);\n\n    const patterns = this.patternDetector.detectPatterns(explanations);\n    console.log(`Detected ${patterns.length} patterns`);\n\n    this.printPatternSummary(patterns);\n\n    return { failures, explanations, patterns };\n  }\n\n  /**\n   * Reviews pending rules\n   */\n  async reviewPending(): Promise<void> {\n    const pending = await this.ruleWriter.loadPendingRules();\n\n    if (pending.length === 0) {\n      console.log('No pending rules to review.');\n      return;\n    }\n\n    const session = await this.cliReviewer.startReviewSession(pending);\n\n    // Process decisions\n    for (const decision of session.decisions) {\n      if (decision.decision === 'approve' || decision.decision === 'modify') {\n        await this.ruleWriter.approvePendingRule(decision.rule.ruleId);\n      } else if (decision.decision === 'reject') {\n        await this.ruleWriter.rejectPendingRule(\n          decision.rule.ruleId,\n          decision.notes || 'Rejected'\n        );\n      }\n      // Skip leaves the rule in pending\n    }\n\n    console.log(`\\nApproved: ${session.approved.length}`);\n    console.log(`Rejected: ${session.rejected.length}`);\n    console.log(`Remaining pending: ${session.skipped.length}`);\n  }\n\n  /**\n   * Shows current stats\n   */\n  async showStats(): Promise<void> {\n    console.log('\\n');\n    console.log('              PROMPT LEARNING SYSTEM STATUS                     ');\n    console.log('\\n');\n\n    // Source stats\n    const sourceStats = await getSourceStats();\n    console.log('Data Sources:');\n    for (const [name, stats] of Object.entries(sourceStats)) {\n      const status = stats.available ? '' : '';\n      const count = stats.failureCount !== undefined ? ` (${stats.failureCount} failures)` : '';\n      console.log(`  ${status} ${name}${count}`);\n\n      // Show JSONL details if available\n      if (stats.details) {\n        console.log(`      Projects: ${stats.details.projects}`);\n        console.log(`      Files: ${stats.details.files}`);\n        console.log(`      Sessions: ${stats.details.sessions}`);\n      }\n    }\n\n    // Rule stats\n    const ruleStats = await this.ruleWriter.getStats();\n    console.log('\\nRules:');\n    console.log(`  Total learned: ${ruleStats.totalRules}`);\n    console.log(`  Pending review: ${ruleStats.pendingCount}`);\n    console.log(`  Approved: ${ruleStats.approvedCount}`);\n    console.log(`  Rejected: ${ruleStats.rejectedCount}`);\n    console.log(`  Iterations: ${ruleStats.iterationsCount}`);\n\n    console.log('');\n  }\n\n  /**\n   * Creates an empty result for no-failures case\n   */\n  private createEmptyResult(\n    iterationId: string,\n    startTime: number,\n    sources: string[]\n  ): LearningIterationResult {\n    return {\n      iterationId,\n      timestamp: new Date().toISOString(),\n      sources,\n      failuresCollected: 0,\n      explanationsGenerated: 0,\n      patternsDetected: [],\n      rulesProposed: [],\n      rulesApproved: [],\n      rulesRejected: [],\n      durationMs: Date.now() - startTime,\n    };\n  }\n\n  /**\n   * Creates a full result\n   */\n  private createResult(\n    iterationId: string,\n    startTime: number,\n    sources: string[],\n    failuresCollected: number,\n    explanationsGenerated: number,\n    patterns: FailurePattern[],\n    proposed: ProposedRule[],\n    approved: ProposedRule[],\n    rejected: ProposedRule[]\n  ): LearningIterationResult {\n    return {\n      iterationId,\n      timestamp: new Date().toISOString(),\n      sources,\n      failuresCollected,\n      explanationsGenerated,\n      patternsDetected: patterns,\n      rulesProposed: proposed,\n      rulesApproved: approved,\n      rulesRejected: rejected,\n      durationMs: Date.now() - startTime,\n    };\n  }\n\n  /**\n   * Prints pattern summary\n   */\n  private printPatternSummary(patterns: FailurePattern[]): void {\n    console.log('\\n   Patterns detected:');\n    for (const pattern of patterns.slice(0, 5)) {\n      console.log(`     - ${pattern.patternName} (${pattern.frequency} failures)`);\n    }\n    if (patterns.length > 5) {\n      console.log(`     ... and ${patterns.length - 5} more`);\n    }\n  }\n\n  /**\n   * Prints iteration summary\n   */\n  private printIterationSummary(result: LearningIterationResult): void {\n    console.log('\\n');\n    console.log('  LEARNING ITERATION COMPLETE');\n    console.log('');\n    console.log(`  Iteration ID: ${result.iterationId}`);\n    console.log(`  Duration: ${(result.durationMs / 1000).toFixed(1)}s`);\n    console.log('');\n    console.log(`  Failures analyzed: ${result.failuresCollected}`);\n    console.log(`  Explanations generated: ${result.explanationsGenerated}`);\n    console.log(`  Patterns detected: ${result.patternsDetected.length}`);\n    console.log(`  Rules proposed: ${result.rulesProposed.length}`);\n    console.log(`  Rules approved: ${result.rulesApproved.length}`);\n    console.log(`  Rules rejected: ${result.rulesRejected.length}`);\n    console.log('');\n    console.log('  Next steps:');\n    console.log('    1. Review learned-rules.json');\n    console.log('    2. Manually integrate approved rules into prompt-templates.ts');\n    console.log('    3. Run evals to validate improvements');\n    console.log('\\n');\n  }\n}\n\nexport default LearningRunner;\n","import type { EvalCase, EvalCaseResult } from './schemas.js';\nimport type { Judge } from '../judges/judge-interface.js';\n\nexport interface EvalWorkspace {\n  id: string;\n  path: string;\n}\n\nexport interface ToolCall {\n  toolName: string;\n  input: unknown;\n  output?: unknown;\n  isError?: boolean;\n  timestamp?: number;\n  duration?: number;\n}\n\nexport interface ProgressRecord {\n  type: string;\n  percentage: number;\n  description: string;\n  timestamp: number;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface TranscriptTurn {\n  role: 'user' | 'assistant';\n  content: string;\n  toolCalls?: ToolCall[];\n  reasoning?: string;\n  timestamp: number;\n}\n\nexport interface TranscriptOutcome {\n  files: string[];\n  success: boolean;\n  error?: string;\n  finalState?: Record<string, unknown>;\n}\n\nexport interface Transcript {\n  turns: TranscriptTurn[];\n  outcome: TranscriptOutcome;\n  duration: number;\n  startTime: number;\n  endTime: number;\n}\n\nexport interface AgentContext {\n  workingDirectory: string;\n  evalId: string;\n  evalName: string;\n  sessionId?: string;\n  timeout?: number;\n}\n\nexport interface AgentResult {\n  output: string;\n  success: boolean;\n  toolCalls?: ToolCall[];\n  sessionId?: string;\n  error?: Error;\n  duration?: number;\n  numTurns?: number;\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalCostUsd?: number;\n  };\n}\n\nexport type AgentFunction = (\n  prompt: string,\n  context: AgentContext\n) => Promise<AgentResult>;\n\nexport type AgentType = 'claude-code' | 'generic';\n\nexport interface LearningConfig {\n  enabled?: boolean;\n  ruleOutputDir?: string;\n  minFailuresForPattern?: number;\n  similarityThreshold?: number;\n  maxRulesPerIteration?: number;\n  minRuleConfidence?: number;\n  autoApprove?: boolean;\n  autoApproveThreshold?: number;\n}\n\nexport interface VibeCheckConfig {\n  agent: AgentFunction;\n  agentType?: AgentType;\n  testMatch?: string[];\n  testDir?: string;\n  parallel?: boolean;\n  maxConcurrency?: number;\n  timeout?: number;\n  maxRetries?: number;\n  retryDelayMs?: number;\n  retryBackoffMultiplier?: number;\n  trials?: number;\n  trialPassThreshold?: number;\n  judges?: Judge[];\n  llmJudgeModel?: string;\n  rubricsDir?: string;\n  outputDir?: string;\n  verbose?: boolean;\n  preserveWorkspaces?: boolean;\n  learning?: LearningConfig;\n  createWorkspace?: () => Promise<EvalWorkspace>;\n  cleanupWorkspace?: (workspace: EvalWorkspace) => Promise<void>;\n  setup?: () => Promise<void>;\n  teardown?: () => Promise<void>;\n  beforeEach?: (evalCase: EvalCase) => Promise<void>;\n  afterEach?: (result: EvalCaseResult) => Promise<void>;\n}\n\nexport interface ResolvedConfig extends Required<Omit<VibeCheckConfig, 'setup' | 'teardown' | 'beforeEach' | 'afterEach' | 'learning' | 'judges' | 'createWorkspace' | 'cleanupWorkspace'>> {\n  setup?: () => Promise<void>;\n  teardown?: () => Promise<void>;\n  beforeEach?: (evalCase: EvalCase) => Promise<void>;\n  afterEach?: (result: EvalCaseResult) => Promise<void>;\n  learning: Required<LearningConfig>;\n  judges: Judge[];\n  createWorkspace?: () => Promise<EvalWorkspace>;\n  cleanupWorkspace?: (workspace: EvalWorkspace) => Promise<void>;\n}\n\nexport function defineConfig(config: VibeCheckConfig): VibeCheckConfig {\n  return config;\n}\n\nexport const defaultConfig: Omit<ResolvedConfig, 'agent'> = {\n  agentType: 'generic',\n  testMatch: ['**/*.eval.json'],\n  testDir: './__evals__',\n  parallel: true,\n  maxConcurrency: 3,\n  timeout: 300000,\n  maxRetries: 2,\n  retryDelayMs: 1000,\n  retryBackoffMultiplier: 2,\n  trials: 1,\n  trialPassThreshold: 0.5,\n  judges: [],\n  llmJudgeModel: 'claude-sonnet-4-20250514',\n  rubricsDir: './__evals__/rubrics',\n  outputDir: './__evals__/results',\n  verbose: false,\n  preserveWorkspaces: false,\n  learning: {\n    enabled: false,\n    ruleOutputDir: './prompts',\n    minFailuresForPattern: 2,\n    similarityThreshold: 0.7,\n    maxRulesPerIteration: 5,\n    minRuleConfidence: 0.6,\n    autoApprove: false,\n    autoApproveThreshold: 0.8,\n  },\n};\n","import * as path from 'path';\nimport * as fs from 'fs/promises';\nimport { pathToFileURL } from 'url';\nimport type { VibeCheckConfig, ResolvedConfig } from './types.js';\nimport { defaultConfig } from './types.js';\n\nconst CONFIG_FILE_NAMES = [\n  'vibe-check.config.ts',\n  'vibe-check.config.js',\n  'vibe-check.config.mjs',\n];\n\nexport async function loadConfig(configPath?: string): Promise<ResolvedConfig> {\n  const cwd = process.cwd();\n\n  let configFile: string | undefined;\n\n  if (configPath) {\n    configFile = path.isAbsolute(configPath) ? configPath : path.join(cwd, configPath);\n  } else {\n    for (const name of CONFIG_FILE_NAMES) {\n      const candidate = path.join(cwd, name);\n      try {\n        await fs.access(candidate);\n        configFile = candidate;\n        break;\n      } catch {\n        // Continue to next candidate\n      }\n    }\n  }\n\n  if (!configFile) {\n    throw new Error(\n      `No config file found. Create one of: ${CONFIG_FILE_NAMES.join(', ')}`\n    );\n  }\n\n  const userConfig = await importConfig(configFile);\n\n  if (!userConfig.agent) {\n    throw new Error('Config must specify an \"agent\" function');\n  }\n\n  return resolveConfig(userConfig);\n}\n\nasync function importConfig(configPath: string): Promise<VibeCheckConfig> {\n  const fileUrl = pathToFileURL(configPath).href;\n\n  try {\n    const module = await import(fileUrl);\n    return module.default || module;\n  } catch (error) {\n    if (configPath.endsWith('.ts')) {\n      throw new Error(\n        `Failed to import TypeScript config. Run with tsx: npx vibe-check\\n${error}`\n      );\n    }\n    throw error;\n  }\n}\n\nfunction resolveConfig(userConfig: VibeCheckConfig): ResolvedConfig {\n  return {\n    agent: userConfig.agent,\n    agentType: userConfig.agentType ?? defaultConfig.agentType,\n    testMatch: userConfig.testMatch ?? defaultConfig.testMatch,\n    testDir: userConfig.testDir ?? defaultConfig.testDir,\n    parallel: userConfig.parallel ?? defaultConfig.parallel,\n    maxConcurrency: userConfig.maxConcurrency ?? defaultConfig.maxConcurrency,\n    timeout: userConfig.timeout ?? defaultConfig.timeout,\n    maxRetries: userConfig.maxRetries ?? defaultConfig.maxRetries,\n    retryDelayMs: userConfig.retryDelayMs ?? defaultConfig.retryDelayMs,\n    retryBackoffMultiplier: userConfig.retryBackoffMultiplier ?? defaultConfig.retryBackoffMultiplier,\n    trials: userConfig.trials ?? defaultConfig.trials,\n    trialPassThreshold: userConfig.trialPassThreshold ?? defaultConfig.trialPassThreshold,\n    judges: userConfig.judges ?? defaultConfig.judges,\n    llmJudgeModel: userConfig.llmJudgeModel ?? defaultConfig.llmJudgeModel,\n    rubricsDir: userConfig.rubricsDir ?? defaultConfig.rubricsDir,\n    outputDir: userConfig.outputDir ?? defaultConfig.outputDir,\n    verbose: userConfig.verbose ?? defaultConfig.verbose,\n    preserveWorkspaces: userConfig.preserveWorkspaces ?? defaultConfig.preserveWorkspaces,\n    createWorkspace: userConfig.createWorkspace,\n    cleanupWorkspace: userConfig.cleanupWorkspace,\n    learning: {\n      enabled: userConfig.learning?.enabled ?? defaultConfig.learning.enabled,\n      ruleOutputDir: userConfig.learning?.ruleOutputDir ?? defaultConfig.learning.ruleOutputDir,\n      minFailuresForPattern: userConfig.learning?.minFailuresForPattern ?? defaultConfig.learning.minFailuresForPattern,\n      similarityThreshold: userConfig.learning?.similarityThreshold ?? defaultConfig.learning.similarityThreshold,\n      maxRulesPerIteration: userConfig.learning?.maxRulesPerIteration ?? defaultConfig.learning.maxRulesPerIteration,\n      minRuleConfidence: userConfig.learning?.minRuleConfidence ?? defaultConfig.learning.minRuleConfidence,\n      autoApprove: userConfig.learning?.autoApprove ?? defaultConfig.learning.autoApprove,\n      autoApproveThreshold: userConfig.learning?.autoApproveThreshold ?? defaultConfig.learning.autoApproveThreshold,\n    },\n    setup: userConfig.setup,\n    teardown: userConfig.teardown,\n    beforeEach: userConfig.beforeEach,\n    afterEach: userConfig.afterEach,\n  };\n}\n","import type { EvalCase, EvalCaseResult, EvalCategory, JudgeResult, ErrorType } from '../config/schemas.js';\nimport type { ResolvedConfig } from '../config/types.js';\nimport { isMultiTurnEval } from '../config/schemas.js';\nimport { TestHarness } from '../harness/test-harness.js';\nimport { getJudgeRegistry } from '../judges/judge-registry.js';\nimport type { JudgeContext, ExecutionResult } from '../judges/judge-interface.js';\nimport { loadEvalCases } from '../utils/eval-loader.js';\n\nexport interface EvalRunnerOptions {\n  categories?: EvalCategory[];\n  tags?: string[];\n  ids?: string[];\n}\n\n/** @deprecated Use EvalRunnerOptions instead */\nexport type RunnerOptions = EvalRunnerOptions;\n\nexport interface EvalSuiteResult {\n  runId: string;\n  total: number;\n  passed: number;\n  failed: number;\n  skipped: number;\n  errors: number;\n  passRate: number;\n  results: EvalCaseResult[];\n  duration: number;\n  timestamp: string;\n}\n\nexport class EvalRunner {\n  private config: ResolvedConfig;\n  private harness: TestHarness;\n\n  constructor(config: ResolvedConfig) {\n    this.config = config;\n    this.harness = new TestHarness({ config });\n\n    // Register custom judges from config with the global registry\n    if (config.judges && config.judges.length > 0) {\n      const registry = getJudgeRegistry();\n      for (const judge of config.judges) {\n        registry.register(judge);\n      }\n    }\n  }\n\n  private verbose(message: string): void {\n    if (this.config.verbose) {\n      console.log(message);\n    }\n  }\n\n  async run(options: EvalRunnerOptions = {}): Promise<EvalSuiteResult> {\n    const startTime = Date.now();\n    const runId = `run-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n\n    this.verbose(`Starting eval run: ${runId}`);\n\n    if (this.config.setup) {\n      this.verbose(`Running setup hook...`);\n      await this.config.setup();\n      this.verbose(`Setup complete`);\n    }\n\n    this.verbose(`Loading eval cases from: ${this.config.testDir}`);\n    const evalCases = await loadEvalCases({\n      testDir: this.config.testDir,\n      testMatch: this.config.testMatch,\n      categories: options.categories,\n      tags: options.tags,\n      ids: options.ids,\n      enabledOnly: true,\n    });\n\n    const mode = this.config.parallel ? `parallel (${this.config.maxConcurrency} concurrent)` : 'sequential';\n    console.log(`Running ${evalCases.length} evals (${mode})...`);\n    console.log();\n\n    const results: EvalCaseResult[] = [];\n\n    if (this.config.parallel && evalCases.length > 1) {\n      results.push(...await this.runParallel(evalCases));\n    } else {\n      results.push(...await this.runSequential(evalCases));\n    }\n\n    if (this.config.teardown) {\n      this.verbose(`Running teardown hook...`);\n      await this.config.teardown();\n    }\n\n    await this.harness.cleanup();\n\n    const passed = results.filter(r => r.success).length;\n    const failed = results.filter(r => !r.success && !r.error).length;\n    const errors = results.filter(r => r.error).length;\n    const duration = Date.now() - startTime;\n\n    console.log();\n    console.log(`Completed: ${passed}/${results.length} passed (${Math.round(passed / results.length * 100)}%) in ${(duration / 1000).toFixed(1)}s`);\n\n    return {\n      runId,\n      total: results.length,\n      passed,\n      failed,\n      skipped: 0,\n      errors,\n      passRate: results.length > 0 ? passed / results.length : 0,\n      results,\n      duration,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  private async runParallel(evalCases: EvalCase[]): Promise<EvalCaseResult[]> {\n    // Pre-allocate results array to preserve original order\n    const results: EvalCaseResult[] = new Array(evalCases.length);\n    const { maxConcurrency } = this.config;\n    let nextIndex = 0;\n    let completed = 0;\n    let running = 0;\n\n    return new Promise((resolve) => {\n      const runNext = async (): Promise<void> => {\n        while (nextIndex < evalCases.length) {\n          const currentIndex = nextIndex++;\n          const evalCase = evalCases[currentIndex];\n          running++;\n\n          console.log(`[${evalCase.id}] Starting (${currentIndex + 1}/${evalCases.length})`);\n\n          try {\n            const result = await this.runSingle(evalCase);\n            results[currentIndex] = result; // Preserve order\n          } catch (error) {\n            // Catch unexpected errors to prevent crashing the pool\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            results[currentIndex] = {\n              evalCase,\n              success: false,\n              output: '',\n              duration: 0,\n              judgeResults: [],\n              error: error instanceof Error ? error : new Error(errorMessage),\n              errorType: this.classifyError(error),\n            };\n          } finally {\n            running--;\n            completed++;\n          }\n        }\n      };\n\n      // Start maxConcurrency workers\n      const workers = Array(Math.min(maxConcurrency, evalCases.length))\n        .fill(null)\n        .map(() => runNext());\n\n      Promise.all(workers).then(() => resolve(results));\n    });\n  }\n\n  private async runSequential(evalCases: EvalCase[]): Promise<EvalCaseResult[]> {\n    const results: EvalCaseResult[] = [];\n\n    for (let i = 0; i < evalCases.length; i++) {\n      const evalCase = evalCases[i];\n      console.log(`[${evalCase.id}] Starting (${i + 1}/${evalCases.length})`);\n      const result = await this.runSingle(evalCase);\n      results.push(result);\n    }\n\n    return results;\n  }\n\n  private async runSingle(evalCase: EvalCase): Promise<EvalCaseResult> {\n    const startTime = Date.now();\n\n    if (this.config.beforeEach) {\n      await this.config.beforeEach(evalCase);\n    }\n\n    let result: EvalCaseResult;\n\n    try {\n      const trialConfig = evalCase.trials || { count: this.config.trials, passThreshold: this.config.trialPassThreshold };\n      const trialCount = trialConfig.count ?? 1;\n\n      if (trialCount > 1) {\n        result = await this.runWithTrials(evalCase, trialCount, trialConfig.passThreshold ?? 0.5);\n      } else {\n        result = await this.runWithRetries(evalCase);\n      }\n    } catch (error) {\n      result = {\n        evalCase,\n        success: false,\n        output: '',\n        duration: Date.now() - startTime,\n        judgeResults: [],\n        error: error instanceof Error ? error : new Error(String(error)),\n        errorType: this.classifyError(error),\n      };\n    }\n\n    if (this.config.afterEach) {\n      await this.config.afterEach(result);\n    }\n\n    const status = result.success ? '' : '';\n    const trialInfo = result.trialResults ? ` [${result.trialResults.filter(t => t).length}/${result.trialResults.length} trials]` : '';\n    const retryInfo = result.retryCount ? ` (${result.retryCount} retries)` : '';\n    console.log(`[${evalCase.id}] ${status} ${(result.duration / 1000).toFixed(1)}s${trialInfo}${retryInfo}`);\n\n    return result;\n  }\n\n  private async runWithTrials(evalCase: EvalCase, trialCount: number, passThreshold: number): Promise<EvalCaseResult> {\n    const trialResults: boolean[] = [];\n    let lastResult: EvalCaseResult | undefined;\n    let totalDuration = 0;\n\n    for (let trial = 0; trial < trialCount; trial++) {\n      this.verbose(`[${evalCase.id}] Trial ${trial + 1}/${trialCount}...`);\n\n      try {\n        const result = await this.runWithRetries(evalCase);\n        trialResults.push(result.success);\n        totalDuration += result.duration;\n        lastResult = result;\n\n        this.verbose(`[${evalCase.id}] Trial ${trial + 1} ${result.success ? 'passed' : 'failed'}`);\n      } catch (error) {\n        trialResults.push(false);\n        lastResult = {\n          evalCase,\n          success: false,\n          output: '',\n          duration: 0,\n          judgeResults: [],\n          error: error instanceof Error ? error : new Error(String(error)),\n          errorType: this.classifyError(error),\n        };\n        this.verbose(`[${evalCase.id}] Trial ${trial + 1} errored: ${(error as Error).message}`);\n      }\n    }\n\n    const passCount = trialResults.filter(t => t).length;\n    const passRate = passCount / trialCount;\n    const overallSuccess = passRate >= passThreshold;\n\n    this.verbose(`[${evalCase.id}] Trials complete: ${passCount}/${trialCount} passed (${(passRate * 100).toFixed(0)}%)`);\n\n    return {\n      ...lastResult!,\n      success: overallSuccess,\n      trialResults,\n      duration: totalDuration,\n    };\n  }\n\n  private async runWithRetries(evalCase: EvalCase): Promise<EvalCaseResult> {\n    let lastError: Error | undefined;\n    let lastErrorType: ErrorType | undefined;\n    let retryCount = 0;\n    const retryErrors: string[] = [];\n\n    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {\n      const isRetry = attempt > 0;\n\n      try {\n        const result = await this.executeAndJudge(evalCase);\n\n        if (result.success) {\n          // Test passed - check if it was flaky (passed on retry)\n          return {\n            ...result,\n            retryCount,\n            flaky: isRetry,\n            retryErrors: isRetry ? retryErrors : undefined,\n          };\n        }\n\n        if (attempt === this.config.maxRetries) {\n          return { ...result, retryCount, retryErrors: retryErrors.length > 0 ? retryErrors : undefined };\n        }\n\n        // Record failure reason\n        const failReason = result.errorType || 'judge failure';\n        retryErrors.push(`Attempt ${attempt + 1}: ${failReason}`);\n\n        retryCount++;\n        const delay = this.getRetryDelay(attempt, result.errorType);\n        this.verbose(`[${evalCase.id}] Attempt ${attempt + 1} failed (${failReason}), retrying in ${delay}ms... (${retryCount}/${this.config.maxRetries})`);\n        await this.sleep(delay);\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        lastErrorType = this.classifyError(error);\n\n        // Record error reason\n        retryErrors.push(`Attempt ${attempt + 1}: ${lastErrorType} - ${lastError.message.substring(0, 100)}`);\n        retryCount++;\n\n        if (attempt < this.config.maxRetries) {\n          const delay = this.getRetryDelay(attempt, lastErrorType);\n          this.verbose(`[${evalCase.id}] Attempt ${attempt + 1} errored (${lastErrorType}): ${lastError.message}, retrying in ${delay}ms...`);\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    return {\n      evalCase,\n      success: false,\n      output: '',\n      duration: 0,\n      judgeResults: [],\n      error: lastError,\n      errorType: lastErrorType,\n      retryCount,\n      flaky: false,\n      retryErrors: retryErrors.length > 0 ? retryErrors : undefined,\n    };\n  }\n\n  private getRetryDelay(attempt: number, errorType?: ErrorType): number {\n    const baseDelay = this.config.retryDelayMs;\n    const multiplier = this.config.retryBackoffMultiplier;\n\n    let delay = baseDelay * Math.pow(multiplier, attempt);\n\n    // Use longer delays for API overload to allow recovery\n    if (errorType === 'api') {\n      delay *= 3;\n    } else if (errorType === 'timeout') {\n      delay *= 1.5;\n    }\n\n    return delay;\n  }\n\n  private classifyError(error: unknown, output?: string): ErrorType {\n    if (!error) return 'unknown';\n\n    const errorMessage = error instanceof Error ? error.message.toLowerCase() : String(error).toLowerCase();\n    // Check both error message and output for API errors\n    const combinedText = output ? `${errorMessage} ${output.toLowerCase()}` : errorMessage;\n\n    if (errorMessage.includes('timeout') || errorMessage.includes('timed out')) {\n      return 'timeout';\n    }\n\n    // Check for API errors including Anthropic overload (529) and Cloudflare errors\n    if (combinedText.includes('api') || combinedText.includes('rate limit') ||\n        combinedText.includes('429') || combinedText.includes('529') ||\n        combinedText.includes('500') || combinedText.includes('502') || combinedText.includes('503') ||\n        combinedText.includes('overloaded') || combinedText.includes('api error')) {\n      return 'api';\n    }\n\n    if (errorMessage.includes('judge')) {\n      return 'judge';\n    }\n\n    return 'unknown';\n  }\n\n  private async executeAndJudge(evalCase: EvalCase): Promise<EvalCaseResult> {\n    let executionResult: ExecutionResult;\n    let turnResults: ExecutionResult[] | undefined;\n    let judgeResults: JudgeResult[];\n\n    if (isMultiTurnEval(evalCase)) {\n      turnResults = await this.harness.executeMultiTurn(evalCase);\n      executionResult = turnResults[turnResults.length - 1];\n      // Use multi-turn judging which supports per-turn judges\n      judgeResults = await this.runJudgesForMultiTurn(evalCase, turnResults);\n    } else {\n      executionResult = await this.harness.execute(evalCase);\n      judgeResults = await this.runJudgesParallel(evalCase, executionResult);\n    }\n\n    const allPassed = judgeResults.every(r => r.passed);\n\n    if (this.config.verbose && judgeResults.length > 0) {\n      for (const result of judgeResults) {\n        const status = result.passed ? '' : '';\n        this.verbose(`[${evalCase.id}] Judge ${result.judgeId}: ${status} (score: ${result.score})`);\n        if (!result.passed && result.reasoning) {\n          this.verbose(`[${evalCase.id}]    ${result.reasoning}`);\n        }\n      }\n    }\n\n    // Cleanup workspace after judging completes\n    if (executionResult.workspaceId) {\n      await this.harness.cleanupWorkspace(executionResult.workspaceId);\n    }\n\n    return {\n      evalCase,\n      success: executionResult.success && allPassed,\n      output: executionResult.output,\n      duration: executionResult.duration,\n      judgeResults,\n      toolCalls: executionResult.toolCalls,\n      error: executionResult.error,\n      errorType: executionResult.error ? this.classifyError(executionResult.error, executionResult.output) : undefined,\n    };\n  }\n\n  private async runJudgesParallel(evalCase: EvalCase, executionResult: ExecutionResult, maxRetries: number = 2): Promise<JudgeResult[]> {\n    const judgeIds = this.getJudgeIds(evalCase);\n    const registry = getJudgeRegistry();\n\n    // Run all judges in parallel\n    const judgePromises = judgeIds.map(async (judgeId) => {\n      const judge = registry.get(judgeId);\n\n      if (!judge) {\n        this.verbose(`[${evalCase.id}] Warning: Judge not found: ${judgeId}`);\n        return null;\n      }\n\n      return this.evaluateJudgeWithRetry(\n        judge,\n        {\n          evalCase,\n          executionResult,\n          workingDirectory: executionResult.workingDirectory || '',\n        },\n        maxRetries,\n        judgeId\n      );\n    });\n\n    const results = await Promise.all(judgePromises);\n    return results.filter((r): r is JudgeResult => r !== null);\n  }\n\n  private async runJudgesForMultiTurn(evalCase: EvalCase & { category: 'multi-turn' }, turnResults: ExecutionResult[], maxRetries: number = 2): Promise<JudgeResult[]> {\n    const registry = getJudgeRegistry();\n    const allJudgePromises: Promise<JudgeResult | null>[] = [];\n\n    // Turn-level judges (all in parallel)\n    for (let i = 0; i < evalCase.turns.length; i++) {\n      const turn = evalCase.turns[i];\n      const turnResult = turnResults[i];\n      const turnJudgeIds = turn.judges || [];\n\n      for (const judgeId of turnJudgeIds) {\n        const turnIndex = i;\n        allJudgePromises.push(\n          (async () => {\n            const judge = registry.get(judgeId);\n            if (!judge) {\n              this.verbose(`[${evalCase.id}] Warning: Judge not found: ${judgeId}`);\n              return null;\n            }\n\n            return this.evaluateJudgeWithRetry(\n              judge,\n              {\n                evalCase,\n                executionResult: turnResult,\n                workingDirectory: turnResult.workingDirectory || '',\n                turnIndex,\n              },\n              maxRetries,\n              `${judgeId}[turn-${turnIndex + 1}]`\n            );\n          })()\n        );\n      }\n    }\n\n    // Global judges (all in parallel)\n    const globalJudgeIds = evalCase.judges || [];\n    const lastResult = turnResults[turnResults.length - 1];\n\n    for (const judgeId of globalJudgeIds) {\n      allJudgePromises.push(\n        (async () => {\n          const judge = registry.get(judgeId);\n          if (!judge) {\n            this.verbose(`[${evalCase.id}] Warning: Judge not found: ${judgeId}`);\n            return null;\n          }\n\n          return this.evaluateJudgeWithRetry(\n            judge,\n            {\n              evalCase,\n              executionResult: lastResult,\n              workingDirectory: lastResult.workingDirectory || '',\n            },\n            maxRetries,\n            judgeId\n          );\n        })()\n      );\n    }\n\n    const results = await Promise.all(allJudgePromises);\n    return results.filter((r): r is JudgeResult => r !== null);\n  }\n\n  private async evaluateJudgeWithRetry(\n    judge: { id: string; evaluate: (context: JudgeContext) => Promise<JudgeResult> },\n    context: JudgeContext,\n    maxRetries: number,\n    judgeIdOverride?: string\n  ): Promise<JudgeResult> {\n    const judgeId = judgeIdOverride || judge.id;\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const result = await judge.evaluate(context);\n        // Log success on retry\n        if (attempt > 0) {\n          this.verbose(`[${context.evalCase.id}] Judge ${judgeId} succeeded on attempt ${attempt + 1}`);\n        }\n        // Apply override judgeId if provided\n        if (judgeIdOverride) {\n          return { ...result, judgeId: judgeIdOverride };\n        }\n        return result;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        if (attempt < maxRetries) {\n          const delay = 500 * (attempt + 1);\n          this.verbose(`[${context.evalCase.id}] Judge ${judgeId} failed (attempt ${attempt + 1}), retrying in ${delay}ms...`);\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    return {\n      judgeId,\n      passed: false,\n      score: 0,\n      confidence: 1,\n      reasoning: `Judge error after ${maxRetries + 1} attempts: ${lastError?.message || 'Unknown'}`,\n    };\n  }\n\n  private getJudgeIds(evalCase: EvalCase): string[] {\n    if ('judges' in evalCase && evalCase.judges) {\n      return evalCase.judges;\n    }\n    return [];\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n","import type { EvalCase, JudgeResult } from '../config/schemas.js';\nimport type { AgentResult, Transcript, ProgressRecord } from '../config/types.js';\n\nexport interface ExecutionResult {\n  success: boolean;\n  output: string;\n  error?: Error;\n  toolCalls: ToolCallRecord[];\n  duration: number;\n  numTurns?: number;\n  sessionId?: string;\n  workingDirectory?: string;\n  workspaceId?: string;\n  transcript?: Transcript;\n  progressUpdates?: ProgressRecord[];\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalCostUsd?: number;\n  };\n}\n\nexport interface ToolCallRecord {\n  toolName: string;\n  toolUseId?: string;\n  input: unknown;\n  output?: unknown;\n  timestamp?: number;\n  duration?: number;\n  isError?: boolean;\n}\n\nexport interface JudgeContext {\n  evalCase: EvalCase;\n  executionResult: ExecutionResult;\n  workingDirectory: string;\n  turnIndex?: number;\n}\n\nexport type JudgeType = 'code' | 'llm' | 'hybrid';\n\nexport interface Judge {\n  id: string;\n  name: string;\n  type: JudgeType;\n  evaluate(context: JudgeContext): Promise<JudgeResult>;\n}\n\nexport abstract class BaseJudge implements Judge {\n  abstract id: string;\n  abstract name: string;\n  abstract type: JudgeType;\n\n  abstract evaluate(context: JudgeContext): Promise<JudgeResult>;\n\n  protected createResult(params: {\n    passed: boolean;\n    score: number;\n    reasoning: string;\n    confidence?: number;\n    details?: Record<string, unknown>;\n  }): JudgeResult {\n    return {\n      judgeId: this.id,\n      passed: params.passed,\n      score: params.score,\n      confidence: params.confidence ?? 1,\n      reasoning: params.reasoning,\n      details: params.details,\n    };\n  }\n\n  protected notApplicable(reason: string = 'Not applicable'): JudgeResult {\n    return this.createResult({\n      passed: true,\n      score: 100,\n      reasoning: reason,\n    });\n  }\n}\n\nexport function agentResultToExecutionResult(result: AgentResult): ExecutionResult {\n  return {\n    success: result.success,\n    output: result.output,\n    error: result.error,\n    toolCalls: (result.toolCalls ?? []).map(tc => ({\n      toolName: tc.toolName,\n      input: tc.input,\n      output: tc.output,\n      isError: tc.isError,\n    })),\n    duration: result.duration ?? 0,\n    numTurns: result.numTurns,\n    sessionId: result.sessionId,\n    usage: result.usage,\n  };\n}\n\nexport { JudgeResult };\n","import * as fs from 'fs/promises';\nimport * as fsSync from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport type { EvalCase } from '../config/schemas.js';\nimport type { AgentFunction, AgentContext, AgentResult, ResolvedConfig, EvalWorkspace, ToolCall } from '../config/types.js';\nimport type { ExecutionResult } from '../judges/judge-interface.js';\nimport { agentResultToExecutionResult } from '../judges/judge-interface.js';\n\nexport interface TestHarnessOptions {\n  config: ResolvedConfig;\n}\n\n/** @deprecated Use TestHarnessOptions instead */\nexport type HarnessOptions = TestHarnessOptions;\n\nexport class TestHarness {\n  private config: ResolvedConfig;\n  private workspaces: Map<string, EvalWorkspace> = new Map();\n\n  constructor(options: TestHarnessOptions) {\n    this.config = options.config;\n  }\n\n  private verbose(message: string): void {\n    if (this.config.verbose) {\n      console.log(message);\n    }\n  }\n\n  async execute(evalCase: EvalCase): Promise<ExecutionResult> {\n    this.verbose(`[${evalCase.id}] Starting: ${evalCase.name}`);\n\n    const workspace = this.config.createWorkspace\n      ? await this.config.createWorkspace()\n      : await this.createDefaultWorkspace();\n\n    this.workspaces.set(workspace.id, workspace);\n    this.verbose(`[${evalCase.id}] Workspace: ${workspace.id}`);\n\n    try {\n      const context: AgentContext = {\n        workingDirectory: workspace.path,\n        evalId: evalCase.id,\n        evalName: evalCase.name,\n        timeout: evalCase.timeout ?? this.config.timeout,\n      };\n\n      const prompt = this.getPrompt(evalCase);\n      const startTime = Date.now();\n\n      this.verbose(`[${evalCase.id}] Executing agent...`);\n      const result = await this.executeWithTimeout(\n        this.config.agent,\n        prompt,\n        context,\n        context.timeout!\n      );\n\n      // Extract tool calls from JSONL for claude-code agent type\n      if (this.config.agentType === 'claude-code') {\n        const jsonlToolCalls = await this.extractToolCallsFromJsonl(workspace.path);\n        if (jsonlToolCalls.length > 0) {\n          this.verbose(`[${evalCase.id}] Found ${jsonlToolCalls.length} tool calls from JSONL`);\n          result.toolCalls = result.toolCalls || [];\n          for (const call of jsonlToolCalls) {\n            if (!result.toolCalls.some((t) => t.toolName === call.toolName)) {\n              result.toolCalls.push(call);\n            }\n          }\n        }\n      }\n\n      const executionResult = agentResultToExecutionResult(result);\n      executionResult.duration = result.duration ?? (Date.now() - startTime);\n      executionResult.workingDirectory = workspace.path;\n\n      this.verbose(`[${evalCase.id}] Completed (${result.success ? 'success' : 'failed'}) in ${executionResult.duration}ms`);\n\n      // Store workspace ID in result so eval runner can clean up after judging\n      executionResult.workspaceId = workspace.id;\n\n      return executionResult;\n    } catch (error) {\n      // Still try to extract tool calls from JSONL even on error/timeout\n      let jsonlToolCalls: ToolCall[] = [];\n      if (this.config.agentType === 'claude-code') {\n        jsonlToolCalls = await this.extractToolCallsFromJsonl(workspace.path);\n      }\n\n      // On error, cleanup immediately\n      if (this.config.cleanupWorkspace || !this.config.preserveWorkspaces) {\n        await this.cleanupWorkspaceById(workspace.id);\n      }\n\n      // Re-throw with tool calls available for error analysis\n      const executionError = error as Error & { toolCalls?: ToolCall[] };\n      executionError.toolCalls = jsonlToolCalls;\n      throw executionError;\n    }\n    // Note: Workspace cleanup is deferred until after judging completes\n    // The eval runner should call cleanupWorkspaceById after judges run\n  }\n\n  async executeMultiTurn(evalCase: EvalCase & { category: 'multi-turn' }): Promise<ExecutionResult[]> {\n    this.verbose(`[${evalCase.id}] Starting multi-turn: ${evalCase.name} (${evalCase.turns.length} turns)`);\n\n    const workspace = this.config.createWorkspace\n      ? await this.config.createWorkspace()\n      : await this.createDefaultWorkspace();\n\n    this.workspaces.set(workspace.id, workspace);\n    this.verbose(`[${evalCase.id}] Workspace: ${workspace.id}`);\n\n    const results: ExecutionResult[] = [];\n    let sessionId: string | undefined;\n\n    try {\n      for (let i = 0; i < evalCase.turns.length; i++) {\n        const turn = evalCase.turns[i];\n\n        const context: AgentContext = {\n          workingDirectory: workspace.path,\n          evalId: evalCase.id,\n          evalName: `${evalCase.name} - Turn ${i + 1}`,\n          timeout: evalCase.timeout ?? this.config.timeout,\n          sessionId,\n        };\n\n        const startTime = Date.now();\n\n        this.verbose(`[${evalCase.id}] Executing turn ${i + 1}/${evalCase.turns.length}...`);\n        const result = await this.executeWithTimeout(\n          this.config.agent,\n          turn.prompt,\n          context,\n          context.timeout!\n        );\n\n        // Extract tool calls from JSONL for claude-code agent type\n        if (this.config.agentType === 'claude-code') {\n          const jsonlToolCalls = await this.extractToolCallsFromJsonl(workspace.path);\n          if (jsonlToolCalls.length > 0) {\n            this.verbose(`[${evalCase.id}] Found ${jsonlToolCalls.length} tool calls from JSONL`);\n            result.toolCalls = result.toolCalls || [];\n            for (const call of jsonlToolCalls) {\n              if (!result.toolCalls.some((t) => t.toolName === call.toolName)) {\n                result.toolCalls.push(call);\n              }\n            }\n          }\n        }\n\n        const executionResult = agentResultToExecutionResult(result);\n        executionResult.duration = result.duration ?? (Date.now() - startTime);\n        executionResult.workingDirectory = workspace.path;\n\n        this.verbose(`[${evalCase.id}] Turn ${i + 1} completed (${result.success ? 'success' : 'failed'}) in ${executionResult.duration}ms`);\n\n        results.push(executionResult);\n\n        sessionId = result.sessionId;\n      }\n\n      this.verbose(`[${evalCase.id}] Multi-turn completed`);\n\n      // Store workspace ID in final result so eval runner can clean up after judging\n      if (results.length > 0) {\n        results[results.length - 1].workspaceId = workspace.id;\n      }\n\n      return results;\n    } catch (error) {\n      // Still try to extract tool calls from JSONL even on error/timeout\n      let jsonlToolCalls: ToolCall[] = [];\n      if (this.config.agentType === 'claude-code') {\n        jsonlToolCalls = await this.extractToolCallsFromJsonl(workspace.path);\n      }\n\n      // On error, cleanup immediately\n      if (this.config.cleanupWorkspace || !this.config.preserveWorkspaces) {\n        await this.cleanupWorkspaceById(workspace.id);\n      }\n\n      // Re-throw with tool calls available for error analysis\n      const executionError = error as Error & { toolCalls?: ToolCall[] };\n      executionError.toolCalls = jsonlToolCalls;\n      throw executionError;\n    }\n    // Note: Workspace cleanup is deferred until after judging completes\n    // The eval runner should call cleanupWorkspaceById after judges run\n  }\n\n  private getPrompt(evalCase: EvalCase): string {\n    if ('prompt' in evalCase) {\n      return evalCase.prompt;\n    }\n    if ('turns' in evalCase && evalCase.turns.length > 0) {\n      return evalCase.turns[0].prompt;\n    }\n    throw new Error(`Eval case ${evalCase.id} has no prompt`);\n  }\n\n  private async executeWithTimeout(\n    agent: AgentFunction,\n    prompt: string,\n    context: AgentContext,\n    timeout: number\n  ): Promise<AgentResult> {\n    return new Promise(async (resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Agent execution timed out after ${timeout}ms`));\n      }, timeout);\n\n      try {\n        const result = await agent(prompt, context);\n        clearTimeout(timer);\n        resolve(result);\n      } catch (error) {\n        clearTimeout(timer);\n        reject(error);\n      }\n    });\n  }\n\n  async cleanup(): Promise<void> {\n    if (this.config.cleanupWorkspace || !this.config.preserveWorkspaces) {\n      for (const id of this.workspaces.keys()) {\n        await this.cleanupWorkspaceById(id);\n      }\n    }\n  }\n\n  async cleanupWorkspace(workspaceId: string): Promise<void> {\n    if (this.config.cleanupWorkspace || !this.config.preserveWorkspaces) {\n      await this.cleanupWorkspaceById(workspaceId);\n    }\n  }\n\n  private async createDefaultWorkspace(): Promise<EvalWorkspace> {\n    const id = `ws-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n    const baseDir = this.getWorkspaceBaseDir();\n    const workspacePath = path.join(baseDir, id);\n\n    await fs.mkdir(workspacePath, { recursive: true });\n    await fs.mkdir(path.join(workspacePath, 'src'), { recursive: true });\n    await fs.writeFile(\n      path.join(workspacePath, 'package.json'),\n      JSON.stringify({ name: 'eval-workspace', version: '1.0.0', type: 'module' }, null, 2)\n    );\n\n    return { id, path: workspacePath };\n  }\n\n  private getWorkspaceBaseDir(): string {\n    const cwd = process.cwd();\n    const evalsResultsDir = path.join(cwd, '__evals__', 'results', 'workspaces');\n\n    try {\n      fsSync.mkdirSync(evalsResultsDir, { recursive: true });\n      const testFile = path.join(evalsResultsDir, '.write-test');\n      fsSync.writeFileSync(testFile, '');\n      fsSync.unlinkSync(testFile);\n      return evalsResultsDir;\n    } catch {\n      const tmpDir = fsSync.realpathSync(os.tmpdir());\n      return path.join(tmpDir, 'vibe-check-evals');\n    }\n  }\n\n  private async cleanupWorkspaceById(id: string): Promise<void> {\n    const workspace = this.workspaces.get(id);\n    if (workspace) {\n      this.verbose(`Cleaning up workspace: ${id}`);\n      if (this.config.cleanupWorkspace) {\n        await this.config.cleanupWorkspace(workspace);\n      } else {\n        try {\n          await fs.rm(workspace.path, { recursive: true, force: true, maxRetries: 3, retryDelay: 100 });\n        } catch {\n          // Ignore cleanup errors\n        }\n      }\n      this.workspaces.delete(id);\n    }\n  }\n\n  private async extractToolCallsFromJsonl(workspacePath: string): Promise<ToolCall[]> {\n    const toolCalls: ToolCall[] = [];\n    const toolUseMap = new Map<string, { name: string; input: unknown }>();\n\n    try {\n      const claudeDir = path.join(workspacePath, '.claude', 'projects');\n      try {\n        await fs.access(claudeDir);\n      } catch {\n        return toolCalls;\n      }\n\n      const projectDirs = await fs.readdir(claudeDir);\n\n      for (const projectDir of projectDirs) {\n        const projectPath = path.join(claudeDir, projectDir);\n        const stat = await fs.stat(projectPath);\n        if (!stat.isDirectory()) continue;\n\n        const files = await fs.readdir(projectPath);\n        const jsonlFiles = files.filter((f) => f.endsWith('.jsonl'));\n\n        for (const jsonlFile of jsonlFiles) {\n          const filePath = path.join(projectPath, jsonlFile);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const lines = content.split('\\n').filter((line) => line.trim());\n\n          // First pass: collect all tool_use blocks\n          for (const line of lines) {\n            try {\n              const entry = JSON.parse(line);\n              const message = entry.message;\n              if (!message?.content || !Array.isArray(message.content)) continue;\n\n              for (const block of message.content) {\n                if (block.type === 'tool_use' && typeof block.name === 'string' && block.id) {\n                  toolUseMap.set(block.id, { name: block.name, input: block.input || {} });\n                }\n              }\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n\n          // Second pass: match with tool_result\n          for (const line of lines) {\n            try {\n              const entry = JSON.parse(line);\n              const message = entry.message;\n              if (!message?.content || !Array.isArray(message.content)) continue;\n\n              for (const block of message.content) {\n                if (block.type === 'tool_result' && block.tool_use_id) {\n                  const toolUse = toolUseMap.get(block.tool_use_id);\n                  if (toolUse) {\n                    const output = typeof block.content === 'string' ? block.content : JSON.stringify(block.content);\n                    if (!toolCalls.some((t) => t.toolName === toolUse.name && JSON.stringify(t.input) === JSON.stringify(toolUse.input))) {\n                      toolCalls.push({\n                        toolName: toolUse.name,\n                        input: toolUse.input,\n                        output,\n                        isError: block.is_error,\n                      });\n                    }\n                    toolUseMap.delete(block.tool_use_id);\n                  }\n                }\n              }\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n\n          // Add any tool uses without results\n          for (const [, toolUse] of toolUseMap) {\n            if (!toolCalls.some((t) => t.toolName === toolUse.name && JSON.stringify(t.input) === JSON.stringify(toolUse.input))) {\n              toolCalls.push({\n                toolName: toolUse.name,\n                input: toolUse.input,\n              });\n            }\n          }\n        }\n      }\n    } catch {\n      // Ignore errors\n    }\n\n    return toolCalls;\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface FileCheckResult {\n  file: string;\n  exists: boolean;\n}\n\nexport class FileExistenceJudge extends BaseJudge {\n  id = 'file-existence';\n  name = 'File Existence Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    const targetFiles = evalCase.targetFiles || [];\n    if (targetFiles.length === 0) {\n      return this.notApplicable('No target files specified');\n    }\n\n    const baseDir = workingDirectory || process.cwd();\n    const results: FileCheckResult[] = [];\n\n    for (const file of targetFiles) {\n      const fullPath = path.join(baseDir, file);\n      try {\n        await fs.access(fullPath);\n        results.push({ file, exists: true });\n      } catch {\n        results.push({ file, exists: false });\n      }\n    }\n\n    const existingCount = results.filter((r) => r.exists).length;\n    const score = (existingCount / targetFiles.length) * 100;\n    const passed = score >= 80;\n\n    const missingFiles = results.filter((r) => !r.exists).map((r) => r.file);\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        missingFiles.length > 0\n          ? `${existingCount}/${targetFiles.length} expected files exist. Missing: ${missingFiles.join(', ')}`\n          : `All ${targetFiles.length} expected files exist`,\n      details: { results, missingFiles },\n    });\n  }\n}\n","import { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isToolEval } from '../../config/schemas.js';\nimport type { ExpectedToolCall } from '../../config/schemas.js';\n\ninterface ToolCallStats {\n  toolName: string;\n  expected: ExpectedToolCall;\n  actualCount: number;\n  passed: boolean;\n  reason: string;\n}\n\nexport class ToolInvocationJudge extends BaseJudge {\n  id = 'tool-invocation';\n  name = 'Tool Invocation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase } = context;\n\n    if (!isToolEval(evalCase)) {\n      return this.notApplicable('Only applicable for tool evals');\n    }\n\n    const expectedCalls = evalCase.expectedToolCalls || [];\n    if (expectedCalls.length === 0) {\n      return this.notApplicable('No expected tool calls specified');\n    }\n\n    const actualCalls = executionResult.toolCalls || [];\n    const toolCallCounts = new Map<string, number>();\n\n    for (const call of actualCalls) {\n      const count = toolCallCounts.get(call.toolName) || 0;\n      toolCallCounts.set(call.toolName, count + 1);\n    }\n\n    const stats: ToolCallStats[] = [];\n\n    for (const expected of expectedCalls) {\n      const actualCount = toolCallCounts.get(expected.toolName) || 0;\n      const minCalls = expected.minCalls ?? 1;\n      const maxCalls = expected.maxCalls ?? Infinity;\n\n      let passed = true;\n      let reason = '';\n\n      if (actualCount < minCalls) {\n        passed = false;\n        reason = `Expected at least ${minCalls} call(s), got ${actualCount}`;\n      } else if (actualCount > maxCalls) {\n        passed = false;\n        reason = `Expected at most ${maxCalls} call(s), got ${actualCount}`;\n      } else {\n        reason = `Called ${actualCount} time(s)`;\n      }\n\n      stats.push({\n        toolName: expected.toolName,\n        expected,\n        actualCount,\n        passed,\n        reason,\n      });\n    }\n\n    const passedCount = stats.filter((s) => s.passed).length;\n    const score = (passedCount / stats.length) * 100;\n    const passed = passedCount === stats.length;\n\n    const failedTools = stats.filter((s) => !s.passed);\n    const reasoning =\n      failedTools.length > 0\n        ? `${passedCount}/${stats.length} expected tool invocations satisfied. Failed: ${failedTools.map((s) => `${s.toolName} (${s.reason})`).join(', ')}`\n        : `All ${stats.length} expected tool invocations satisfied`;\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: {\n        stats,\n        actualToolCalls: actualCalls.map((c) => c.toolName),\n        toolCallCounts: Object.fromEntries(toolCallCounts),\n      },\n    });\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface PatternCheckResult {\n  file: string;\n  patterns: Array<{\n    pattern: string;\n    found: boolean;\n  }>;\n  allFound: boolean;\n}\n\nexport class PatternMatchJudge extends BaseJudge {\n  id = 'pattern-match';\n  name = 'Pattern Match Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    const expectedPatterns = evalCase.expectedPatterns || [];\n    if (expectedPatterns.length === 0) {\n      return this.notApplicable('No expected patterns specified');\n    }\n\n    const baseDir = workingDirectory || process.cwd();\n    const results: PatternCheckResult[] = [];\n\n    for (const { file, patterns } of expectedPatterns) {\n      const fullPath = path.join(baseDir, file);\n      let content = '';\n\n      try {\n        content = await fs.readFile(fullPath, 'utf-8');\n      } catch {\n        results.push({\n          file,\n          patterns: patterns.map((p) => ({ pattern: p, found: false })),\n          allFound: false,\n        });\n        continue;\n      }\n\n      const patternResults = patterns.map((pattern) => {\n        const regex = new RegExp(pattern, 'gm');\n        return {\n          pattern,\n          found: regex.test(content),\n        };\n      });\n\n      results.push({\n        file,\n        patterns: patternResults,\n        allFound: patternResults.every((p) => p.found),\n      });\n    }\n\n    const totalPatterns = results.reduce((sum, r) => sum + r.patterns.length, 0);\n    const foundPatterns = results.reduce(\n      (sum, r) => sum + r.patterns.filter((p) => p.found).length,\n      0\n    );\n    const score = totalPatterns > 0 ? (foundPatterns / totalPatterns) * 100 : 100;\n    const passed = score >= 80;\n\n    const failedFiles = results.filter((r) => !r.allFound);\n    const reasoning =\n      failedFiles.length > 0\n        ? `${foundPatterns}/${totalPatterns} patterns found. Missing patterns in: ${failedFiles.map((r) => r.file).join(', ')}`\n        : `All ${totalPatterns} expected patterns found`;\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: { results },\n    });\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isRoutingEval } from '../../config/schemas.js';\n\nconst DEFAULT_WORK_TYPE_KEYWORDS: Record<string, string[]> = {};\n\nexport interface AgentRoutingJudgeOptions {\n  workTypeKeywords?: Record<string, string[]>;\n}\n\nexport class AgentRoutingJudge extends BaseJudge {\n  id = 'agent-routing';\n  name = 'Agent Routing Judge';\n  type: JudgeType = 'code';\n\n  private workTypeKeywords: Record<string, string[]>;\n\n  constructor(options: AgentRoutingJudgeOptions = {}) {\n    super();\n    this.workTypeKeywords = options.workTypeKeywords || DEFAULT_WORK_TYPE_KEYWORDS;\n  }\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase, workingDirectory } = context;\n\n    if (!isRoutingEval(evalCase)) {\n      return this.notApplicable('Only applicable for routing evals');\n    }\n\n    const taskCalls = executionResult.toolCalls.filter(\n      (call) => call.toolName === 'Task' || call.toolName.includes('task')\n    );\n\n    let agentsInvoked = taskCalls\n      .map((call) => {\n        const input = call.input as Record<string, unknown> | undefined;\n        return (input?.agent as string) || (input?.subagent_type as string) || 'unknown';\n      })\n      .filter((agent) => agent !== 'unknown');\n\n    const jsonlAgents = await this.extractAgentsFromJsonl(workingDirectory);\n    agentsInvoked = [...new Set([...agentsInvoked, ...jsonlAgents])];\n\n    const expectedAgent = evalCase.expectedAgent;\n    const invokedExpected = agentsInvoked.includes(expectedAgent);\n\n    const forbiddenAgents = evalCase.shouldNotRoute || [];\n    const invokedForbidden = forbiddenAgents.filter((a) => agentsInvoked.includes(a));\n\n    const output = executionResult.output || '';\n    const outputLower = output.toLowerCase();\n    const hasDelegationIntent = this.checkDelegationIntent(outputLower, expectedAgent, forbiddenAgents);\n\n    let score: number;\n    let passed: boolean;\n    let reasoning: string;\n\n    if (invokedExpected && invokedForbidden.length === 0) {\n      score = 100;\n      passed = true;\n      reasoning = `Correctly routed to ${expectedAgent}`;\n    } else if (invokedExpected && invokedForbidden.length > 0) {\n      score = 50;\n      passed = false;\n      reasoning = `Routed to ${expectedAgent} but also incorrectly routed to: ${invokedForbidden.join(', ')}`;\n    } else if (hasDelegationIntent.toExpected && !hasDelegationIntent.toForbidden) {\n      score = 80;\n      passed = true;\n      reasoning = `AI indicated delegation intent to ${expectedAgent} (no actual Task tool invocation detected)`;\n    } else if (hasDelegationIntent.toExpected && hasDelegationIntent.toForbidden) {\n      score = 40;\n      passed = false;\n      reasoning = `AI mentioned ${expectedAgent} but also mentioned forbidden agents`;\n    } else if (hasDelegationIntent.performedRightWork) {\n      score = 70;\n      passed = true;\n      reasoning = `AI performed ${expectedAgent}-appropriate work directly (no delegation, but correct work type)`;\n    } else if (agentsInvoked.length === 0) {\n      score = 0;\n      passed = false;\n      reasoning = `Expected ${expectedAgent} but no agent was invoked and no delegation intent detected. The main agent may have handled the task directly.`;\n    } else {\n      score = 0;\n      passed = false;\n      reasoning = `Expected ${expectedAgent} but got: ${agentsInvoked.join(', ')}`;\n    }\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: {\n        agentsInvoked,\n        expectedAgent,\n        invokedForbidden,\n        taskCallCount: taskCalls.length,\n        jsonlAgentsFound: jsonlAgents,\n        delegationIntentDetected: hasDelegationIntent.toExpected,\n        performedRightWork: hasDelegationIntent.performedRightWork,\n      },\n    });\n  }\n\n  private async extractAgentsFromJsonl(workspacePath: string): Promise<string[]> {\n    const agents: string[] = [];\n\n    try {\n      const claudeDir = path.join(workspacePath, '.claude', 'projects');\n\n      try {\n        await fs.access(claudeDir);\n      } catch {\n        return agents;\n      }\n\n      const projectDirs = await fs.readdir(claudeDir);\n\n      for (const projectDir of projectDirs) {\n        const projectPath = path.join(claudeDir, projectDir);\n        const stat = await fs.stat(projectPath);\n\n        if (!stat.isDirectory()) continue;\n\n        const files = await fs.readdir(projectPath);\n        const jsonlFiles = files.filter(f => f.endsWith('.jsonl'));\n\n        for (const jsonlFile of jsonlFiles) {\n          const filePath = path.join(projectPath, jsonlFile);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const lines = content.split('\\n').filter(line => line.trim());\n\n          for (const line of lines) {\n            try {\n              const entry = JSON.parse(line);\n              const message = entry.message;\n\n              if (!message?.content || !Array.isArray(message.content)) continue;\n\n              for (const block of message.content) {\n                if (block.type === 'tool_use' && block.name === 'Task') {\n                  const input = block.input as Record<string, unknown> | undefined;\n                  const agentType = (input?.subagent_type as string) || (input?.agent as string);\n                  if (agentType && !agents.includes(agentType)) {\n                    agents.push(agentType);\n                  }\n                }\n              }\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n        }\n      }\n    } catch {\n      // Ignore errors reading JSONL\n    }\n\n    return agents;\n  }\n\n  private checkDelegationIntent(\n    outputLower: string,\n    expectedAgent: string,\n    forbiddenAgents: string[]\n  ): { toExpected: boolean; toForbidden: boolean; performedRightWork: boolean } {\n    const delegationKeywords = [\n      'delegate',\n      'task tool',\n      'subagent',\n      'agent',\n      'specialized',\n      'use the',\n      'invoke',\n      'call the',\n    ];\n\n    const expectedAgentLower = expectedAgent.toLowerCase();\n    const mentionsExpected = outputLower.includes(expectedAgentLower);\n    const hasDelegationContext = delegationKeywords.some((kw) => outputLower.includes(kw));\n\n    const toExpected = mentionsExpected && hasDelegationContext;\n\n    const toForbidden = forbiddenAgents.some((agent) => {\n      const agentLower = agent.toLowerCase();\n      return outputLower.includes(agentLower) && hasDelegationContext;\n    });\n\n    const performedRightWork = this.checkWorkType(outputLower, expectedAgent);\n\n    return { toExpected, toForbidden, performedRightWork };\n  }\n\n  private checkWorkType(outputLower: string, expectedAgent: string): boolean {\n    const keywords = this.workTypeKeywords[expectedAgent] || [];\n    if (keywords.length === 0) return false;\n\n    const matchCount = keywords.filter((kw) => outputLower.includes(kw)).length;\n    return matchCount >= 2;\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isToolEval } from '../../config/schemas.js';\n\ninterface SkillCheckResult {\n  skillName: string;\n  found: boolean;\n  callCount: number;\n  meetsMin: boolean;\n}\n\nexport class SkillInvocationJudge extends BaseJudge {\n  id = 'skill-invocation';\n  name = 'Skill Invocation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, executionResult, workingDirectory } = context;\n\n    if (!isToolEval(evalCase)) {\n      return this.notApplicable('Only applicable for tool evals');\n    }\n\n    const expectedSkills = evalCase.expectedSkills || [];\n    if (expectedSkills.length === 0) {\n      return this.notApplicable('No expected skills specified');\n    }\n\n    const jsonlSkillCalls = await this.extractSkillCallsFromJsonl(workingDirectory);\n    const mainAgentSkillCalls = this.extractSkillCallsFromToolCalls(executionResult.toolCalls || []);\n    const skillCalls = [...jsonlSkillCalls, ...mainAgentSkillCalls];\n\n    const results: SkillCheckResult[] = [];\n\n    for (const expected of expectedSkills) {\n      const matchCount = skillCalls.filter(\n        (call) => call.skillName === expected.skillName\n      ).length;\n\n      const meetsMin = matchCount >= (expected.minCalls ?? 1);\n\n      results.push({\n        skillName: expected.skillName,\n        found: matchCount > 0,\n        callCount: matchCount,\n        meetsMin,\n      });\n    }\n\n    const passedCount = results.filter((r) => r.found && r.meetsMin).length;\n    const score = (passedCount / expectedSkills.length) * 100;\n    const passed = score >= 80;\n\n    const failedChecks = results.filter((r) => !r.found || !r.meetsMin);\n    const allSkillNames = Array.from(new Set(skillCalls.map((c) => c.skillName)));\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        failedChecks.length > 0\n          ? `${passedCount}/${expectedSkills.length} expected skills invoked. Failed: ${failedChecks.map((f) => `${f.skillName} (found ${f.callCount}x)`).join(', ')}`\n          : `All ${expectedSkills.length} expected skills were invoked`,\n      details: {\n        results,\n        actualSkillNames: allSkillNames,\n        totalSkillCalls: skillCalls.length,\n      },\n    });\n  }\n\n  private extractSkillCallsFromToolCalls(toolCalls: Array<{ toolName: string; input: unknown }>): Array<{ skillName: string; input: unknown }> {\n    const skillCalls: Array<{ skillName: string; input: unknown }> = [];\n\n    for (const call of toolCalls) {\n      if (call.toolName === 'Skill') {\n        const input = call.input as Record<string, unknown> | undefined;\n        const skillName = input?.skill as string || input?.command as string;\n        if (skillName) {\n          skillCalls.push({\n            skillName: skillName.replace(/^\\//, ''),\n            input: input || {},\n          });\n        }\n      }\n    }\n\n    return skillCalls;\n  }\n\n  private async extractSkillCallsFromJsonl(workspacePath: string): Promise<Array<{ skillName: string; input: unknown }>> {\n    const skillCalls: Array<{ skillName: string; input: unknown }> = [];\n\n    try {\n      const claudeDir = path.join(workspacePath, '.claude', 'projects');\n\n      try {\n        await fs.access(claudeDir);\n      } catch {\n        return skillCalls;\n      }\n\n      const projectDirs = await fs.readdir(claudeDir);\n\n      for (const projectDir of projectDirs) {\n        const projectPath = path.join(claudeDir, projectDir);\n        const stat = await fs.stat(projectPath);\n\n        if (!stat.isDirectory()) continue;\n\n        const files = await fs.readdir(projectPath);\n        const jsonlFiles = files.filter(f => f.endsWith('.jsonl'));\n\n        for (const jsonlFile of jsonlFiles) {\n          const filePath = path.join(projectPath, jsonlFile);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const lines = content.split('\\n').filter(line => line.trim());\n\n          for (const line of lines) {\n            try {\n              const entry = JSON.parse(line);\n              const message = entry.message;\n\n              if (!message?.content || !Array.isArray(message.content)) continue;\n\n              for (const block of message.content) {\n                if (block.type === 'tool_use' && block.name === 'Skill') {\n                  const input = block.input as Record<string, unknown> | undefined;\n                  const skillName = input?.skill as string || input?.command as string;\n                  if (skillName) {\n                    skillCalls.push({\n                      skillName: skillName.replace(/^\\//, ''),\n                      input: input || {},\n                    });\n                  }\n                }\n              }\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n        }\n      }\n    } catch {\n      // Ignore errors\n    }\n\n    return skillCalls;\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface SyntaxCheckResult {\n  file: string;\n  valid: boolean;\n  error?: string;\n}\n\nexport class SyntaxValidationJudge extends BaseJudge {\n  id = 'syntax-validation';\n  name = 'Syntax Validation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    if (!evalCase.syntaxValidation) {\n      return this.notApplicable('Syntax validation disabled for this eval');\n    }\n\n    const targetFiles = evalCase.targetFiles || [];\n    const codeFiles = targetFiles.filter(\n      (f) => f.endsWith('.ts') || f.endsWith('.tsx') || f.endsWith('.js') || f.endsWith('.jsx')\n    );\n\n    if (codeFiles.length === 0) {\n      return this.notApplicable('No code files to validate');\n    }\n\n    const results: SyntaxCheckResult[] = [];\n\n    for (const file of codeFiles) {\n      const fullPath = path.join(workingDirectory || executionResult.workingDirectory || '', file);\n      try {\n        const content = await fs.readFile(fullPath, 'utf-8');\n        const isValid = await this.validateSyntax(content, file);\n        results.push({ file, valid: isValid.valid, error: isValid.error });\n      } catch (error) {\n        results.push({\n          file,\n          valid: false,\n          error: error instanceof Error ? error.message : 'File not found',\n        });\n      }\n    }\n\n    const validCount = results.filter((r) => r.valid).length;\n    const score = (validCount / codeFiles.length) * 100;\n    const passed = score >= 90;\n\n    const invalidFiles = results.filter((r) => !r.valid);\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        invalidFiles.length > 0\n          ? `${validCount}/${codeFiles.length} files have valid syntax. Invalid: ${invalidFiles.map((f) => `${f.file} (${f.error})`).join(', ')}`\n          : `All ${codeFiles.length} files have valid syntax`,\n      details: { results },\n    });\n  }\n\n  private async validateSyntax(\n    content: string,\n    filename: string\n  ): Promise<{ valid: boolean; error?: string }> {\n    try {\n      const { parse } = await import('@babel/parser');\n\n      const isTypeScript = filename.endsWith('.ts') || filename.endsWith('.tsx');\n      const isJSX = filename.endsWith('.tsx') || filename.endsWith('.jsx');\n\n      const plugins: string[] = [];\n      if (isTypeScript) plugins.push('typescript');\n      if (isJSX) plugins.push('jsx');\n\n      parse(content, {\n        sourceType: 'module',\n        plugins: plugins as any[],\n      });\n\n      return { valid: true };\n    } catch (error) {\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : 'Parse error',\n      };\n    }\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport Anthropic from '@anthropic-ai/sdk';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport type { ReferenceSolution } from '../../config/schemas.js';\n\nexport interface Rubric {\n  id: string;\n  content: string;\n}\n\nexport interface LLMJudgeOptions {\n  rubricsDir?: string;\n  model?: string;\n}\n\nconst DEFAULT_MODEL = 'claude-sonnet-4-20250514';\nconst DEFAULT_RUBRICS_DIR = './__evals__/rubrics';\n\nexport async function loadRubric(rubricPath: string, rubricsDir?: string): Promise<Rubric> {\n  const baseDir = rubricsDir || DEFAULT_RUBRICS_DIR;\n  const fullPath = path.isAbsolute(rubricPath)\n    ? rubricPath\n    : path.join(process.cwd(), baseDir, rubricPath);\n\n  const content = await fs.readFile(fullPath, 'utf-8');\n  const id = path.basename(rubricPath, path.extname(rubricPath));\n\n  return { id, content };\n}\n\nexport class LLMJudge extends BaseJudge {\n  id: string;\n  name: string;\n  type: JudgeType = 'llm';\n\n  private rubricPath: string;\n  private anthropic: Anthropic;\n  private rubricsDir: string;\n  private model: string;\n\n  constructor(id: string, rubricPath: string, options: LLMJudgeOptions = {}) {\n    super();\n    this.id = id;\n    this.name = `LLM Judge: ${id}`;\n    this.rubricPath = rubricPath;\n    this.rubricsDir = options.rubricsDir || DEFAULT_RUBRICS_DIR;\n    this.model = options.model || DEFAULT_MODEL;\n    this.anthropic = new Anthropic();\n  }\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, executionResult, workingDirectory } = context;\n\n    let rubric: Rubric;\n    try {\n      rubric = await loadRubric(this.rubricPath, this.rubricsDir);\n    } catch (error) {\n      return this.createResult({\n        passed: false,\n        score: 0,\n        reasoning: `Failed to load rubric: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        confidence: 0,\n      });\n    }\n\n    const generatedFiles = await this.readTargetFiles(evalCase, workingDirectory);\n\n    const referenceSolution = evalCase.referenceSolution as ReferenceSolution | undefined;\n    let referenceFiles: Map<string, string> | undefined;\n    if (referenceSolution) {\n      referenceFiles = await this.readReferenceFiles(referenceSolution, workingDirectory);\n    }\n\n    const prompt = referenceFiles && referenceFiles.size > 0\n      ? this.buildPairwisePrompt(evalCase, executionResult, rubric, generatedFiles, referenceFiles)\n      : this.buildPrompt(evalCase, executionResult, rubric, generatedFiles);\n\n    try {\n      const response = await this.anthropic.messages.create({\n        model: this.model,\n        max_tokens: 1024,\n        messages: [{ role: 'user', content: prompt }],\n      });\n\n      const content = response.content[0];\n      if (content.type !== 'text') {\n        throw new Error('Unexpected response type from LLM');\n      }\n\n      return this.parseResponse(content.text);\n    } catch (error) {\n      return this.createResult({\n        passed: false,\n        score: 0,\n        reasoning: `LLM evaluation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        confidence: 0,\n      });\n    }\n  }\n\n  private async readReferenceFiles(\n    referenceSolution: ReferenceSolution,\n    workingDirectory: string\n  ): Promise<Map<string, string>> {\n    const files = new Map<string, string>();\n\n    if (referenceSolution.code) {\n      files.set('reference_code', referenceSolution.code);\n    }\n\n    if (referenceSolution.files && referenceSolution.files.length > 0) {\n      for (const filePath of referenceSolution.files) {\n        const fullPath = path.isAbsolute(filePath)\n          ? filePath\n          : path.join(workingDirectory, filePath);\n        try {\n          const content = await fs.readFile(fullPath, 'utf-8');\n          files.set(filePath, content);\n        } catch {\n          files.set(filePath, '[REFERENCE FILE NOT FOUND]');\n        }\n      }\n    }\n\n    return files;\n  }\n\n  private buildPairwisePrompt(\n    evalCase: any,\n    result: any,\n    rubric: Rubric,\n    generatedFiles: Map<string, string>,\n    referenceFiles: Map<string, string>\n  ): string {\n    const toolCallSummary = this.formatToolCalls(result.toolCalls);\n\n    let generatedFilesSection = '';\n    if (generatedFiles && generatedFiles.size > 0) {\n      const fileContents = Array.from(generatedFiles.entries())\n        .map(([filePath, content]) => `### ${filePath}\\n\\`\\`\\`\\n${content}\\n\\`\\`\\``)\n        .join('\\n\\n');\n      generatedFilesSection = `\\n## Generated Output (Candidate)\\n${fileContents}\\n`;\n    }\n\n    let referenceFilesSection = '';\n    if (referenceFiles && referenceFiles.size > 0) {\n      const fileContents = Array.from(referenceFiles.entries())\n        .map(([filePath, content]) => `### ${filePath}\\n\\`\\`\\`\\n${content}\\n\\`\\`\\``)\n        .join('\\n\\n');\n      referenceFilesSection = `\\n## Reference Solution (Gold Standard)\\n${fileContents}\\n`;\n    }\n\n    return `You are an AI evaluation judge performing PAIRWISE COMPARISON. Compare the candidate output against the reference solution.\n\n## Evaluation Case\nID: ${evalCase.id}\nName: ${evalCase.name}\nDescription: ${evalCase.description}\nCategory: ${evalCase.category}\nOriginal Prompt: ${evalCase.prompt || 'N/A'}\nExpected Behavior: ${evalCase.expectedBehavior || 'N/A'}\n\n## Rubric\n${rubric.content}\n${referenceFilesSection}\n${generatedFilesSection}\n## Execution Result\nSuccess: ${result.success}\nAI Response: ${result.output || 'N/A'}\nDuration: ${result.duration}ms\nTool Calls: ${toolCallSummary}\nError: ${result.error?.message || 'None'}\n\n## Pairwise Comparison Instructions\n1. Compare the candidate output against the reference solution\n2. Evaluate how closely the candidate matches the reference in terms of:\n   - Functional correctness\n   - Code quality and style\n   - Completeness of implementation\n3. Award scores based on how well the candidate achieves the same goals as the reference\n4. A candidate that fully matches or exceeds the reference should score 90-100\n5. Output your evaluation in the following JSON format:\n\n\\`\\`\\`json\n{\n  \"score\": <number 0-100>,\n  \"passed\": <boolean - true if score >= 70>,\n  \"confidence\": <number 0-1 indicating how confident you are in this evaluation>,\n  \"reasoning\": \"<your detailed reasoning comparing candidate to reference, 2-4 sentences>\"\n}\n\\`\\`\\`\n\nOutput only the JSON block, no other text.`;\n  }\n\n  private async readTargetFiles(\n    evalCase: any,\n    workingDirectory: string\n  ): Promise<Map<string, string>> {\n    const files = new Map<string, string>();\n\n    const targetFiles = evalCase.targetFiles as string[] | undefined;\n    if (!targetFiles || targetFiles.length === 0) {\n      return files;\n    }\n\n    for (const filePath of targetFiles) {\n      const fullPath = path.join(workingDirectory, filePath);\n      try {\n        const content = await fs.readFile(fullPath, 'utf-8');\n        files.set(filePath, content);\n      } catch {\n        files.set(filePath, '[FILE NOT FOUND]');\n      }\n    }\n\n    return files;\n  }\n\n  private buildPrompt(\n    evalCase: any,\n    result: any,\n    rubric: Rubric,\n    generatedFiles?: Map<string, string>\n  ): string {\n    const toolCallSummary = this.formatToolCalls(result.toolCalls);\n\n    let generatedFilesSection = '';\n    if (generatedFiles && generatedFiles.size > 0) {\n      const fileContents = Array.from(generatedFiles.entries())\n        .map(([filePath, content]) => `### ${filePath}\\n\\`\\`\\`\\n${content}\\n\\`\\`\\``)\n        .join('\\n\\n');\n      generatedFilesSection = `\\n## Generated Files\\n${fileContents}\\n`;\n    }\n\n    return `You are an AI evaluation judge. Evaluate the following AI execution result against the rubric.\n\n## Evaluation Case\nID: ${evalCase.id}\nName: ${evalCase.name}\nDescription: ${evalCase.description}\nCategory: ${evalCase.category}\nOriginal Prompt: ${evalCase.prompt || 'N/A'}\nExpected Behavior: ${evalCase.expectedBehavior || 'N/A'}\n\n## Rubric\n${rubric.content}\n\n## Execution Result\nSuccess: ${result.success}\nAI Response: ${result.output || 'N/A'}\nDuration: ${result.duration}ms\nTool Calls: ${toolCallSummary}\nError: ${result.error?.message || 'None'}\n${generatedFilesSection}\n## Instructions\n1. Carefully evaluate the result against each criterion in the rubric\n2. Consider both what the AI did correctly and what it failed to do\n3. For code-gen evals, focus on the Generated Files section to evaluate the actual code quality\n4. Provide a score from 0-100 based on the rubric criteria\n5. Be specific in your reasoning - cite specific behaviors observed\n6. Output your evaluation in the following JSON format:\n\n\\`\\`\\`json\n{\n  \"score\": <number 0-100>,\n  \"passed\": <boolean - true if score >= 70>,\n  \"confidence\": <number 0-1 indicating how confident you are in this evaluation>,\n  \"reasoning\": \"<your detailed reasoning, 2-4 sentences>\"\n}\n\\`\\`\\`\n\nOutput only the JSON block, no other text.`;\n  }\n\n  private parseResponse(text: string): JudgeResult {\n    const parsed = parseLLMJudgeResponse(text);\n    return this.createResult(parsed);\n  }\n\n  private formatToolCalls(toolCalls: any[] | undefined): string {\n    return formatToolCallsSummary(toolCalls);\n  }\n}\n\nexport function createLLMCodeQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-code-quality', 'code-quality.md', options);\n}\n\nexport function createLLMRoutingQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-routing-quality', 'routing-quality.md', options);\n}\n\nexport function createLLMResponseQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-response-quality', 'response-quality.md', options);\n}\n\nexport function createLLMConversationQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-conversation-quality', 'conversation-quality.md', options);\n}\n\nexport interface ParsedLLMResponse {\n  passed: boolean;\n  score: number;\n  confidence: number;\n  reasoning: string;\n}\n\nexport function parseLLMJudgeResponse(text: string): ParsedLLMResponse {\n  const jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n  const jsonContent = jsonMatch ? jsonMatch[1] : text;\n\n  try {\n    const parsed = JSON.parse(jsonContent.trim());\n\n    return {\n      passed: parsed.passed ?? parsed.score >= 70,\n      score: Math.max(0, Math.min(100, parsed.score || 0)),\n      confidence: Math.max(0, Math.min(1, parsed.confidence || 0.5)),\n      reasoning: parsed.reasoning || 'No reasoning provided',\n    };\n  } catch {\n    return {\n      passed: false,\n      score: 0,\n      reasoning: `Failed to parse LLM response: ${text.substring(0, 200)}...`,\n      confidence: 0,\n    };\n  }\n}\n\nexport function formatToolCallsSummary(toolCalls: any[] | undefined): string {\n  if (!toolCalls || toolCalls.length === 0) {\n    return 'None';\n  }\n\n  if (toolCalls.length <= 10) {\n    return toolCalls.map((t: any) => t.toolName).join(', ');\n  }\n\n  const toolCounts = new Map<string, number>();\n  for (const call of toolCalls) {\n    const name = call.toolName || 'unknown';\n    toolCounts.set(name, (toolCounts.get(name) || 0) + 1);\n  }\n\n  return Array.from(toolCounts.entries())\n    .map(([name, count]) => count > 1 ? `${name} (x${count})` : name)\n    .join(', ');\n}\n","import type { Judge, JudgeType } from './judge-interface.js';\nimport { FileExistenceJudge } from './builtin/file-existence.js';\nimport { ToolInvocationJudge } from './builtin/tool-invocation.js';\nimport { PatternMatchJudge } from './builtin/pattern-match.js';\nimport { AgentRoutingJudge } from './builtin/agent-routing.js';\nimport { SkillInvocationJudge } from './builtin/skill-invocation.js';\nimport { SyntaxValidationJudge } from './builtin/syntax-validation.js';\nimport {\n  createLLMCodeQualityJudge,\n  createLLMRoutingQualityJudge,\n  createLLMResponseQualityJudge,\n  createLLMConversationQualityJudge,\n} from './builtin/llm-judge.js';\n\nexport class JudgeRegistry {\n  private judges: Map<string, Judge> = new Map();\n\n  constructor() {\n    this.registerBuiltInJudges();\n  }\n\n  private registerBuiltInJudges(): void {\n    this.register(new FileExistenceJudge());\n    this.register(new ToolInvocationJudge());\n    this.register(new PatternMatchJudge());\n    this.register(new AgentRoutingJudge());\n    this.register(new SkillInvocationJudge());\n    this.register(new SyntaxValidationJudge());\n    this.register(createLLMCodeQualityJudge());\n    this.register(createLLMRoutingQualityJudge());\n    this.register(createLLMResponseQualityJudge());\n    this.register(createLLMConversationQualityJudge());\n  }\n\n  register(judge: Judge): void {\n    this.judges.set(judge.id, judge);\n  }\n\n  /** @internal Used for testing only */\n  unregister(id: string): boolean {\n    return this.judges.delete(id);\n  }\n\n  get(id: string): Judge | undefined {\n    return this.judges.get(id);\n  }\n\n  has(id: string): boolean {\n    return this.judges.has(id);\n  }\n\n  list(): string[] {\n    return Array.from(this.judges.keys());\n  }\n\n  /** @internal Used for testing only */\n  listByType(type: JudgeType): string[] {\n    return Array.from(this.judges.entries())\n      .filter(([_, judge]) => judge.type === type)\n      .map(([id]) => id);\n  }\n\n  /** @internal Used for testing only */\n  getAll(): Judge[] {\n    return Array.from(this.judges.values());\n  }\n}\n\nlet defaultRegistry: JudgeRegistry | null = null;\n\nexport function getJudgeRegistry(): JudgeRegistry {\n  if (!defaultRegistry) {\n    defaultRegistry = new JudgeRegistry();\n  }\n  return defaultRegistry;\n}\n\n/** @internal Used for testing only */\nexport function resetJudgeRegistry(): void {\n  defaultRegistry = null;\n}\n","import { Command } from 'commander';\nimport chalk from 'chalk';\nimport { loadConfig } from '../config/config-loader.js';\nimport { EvalRunner } from '../runner/eval-runner.js';\nimport type { EvalCategory } from '../config/schemas.js';\n\nconst program = new Command();\n\nprogram\n  .name('vibe-check')\n  .description('AI agent evaluation framework')\n  .version('0.1.0');\n\nprogram\n  .command('run')\n  .description('Run eval suite')\n  .option('-c, --config <path>', 'Path to config file')\n  .option('--category <categories...>', 'Filter by category (tool, code-gen, routing, multi-turn, basic)')\n  .option('--tag <tags...>', 'Filter by tag')\n  .option('--id <ids...>', 'Filter by eval ID')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options) => {\n    try {\n      const config = await loadConfig(options.config);\n\n      if (options.verbose) {\n        config.verbose = true;\n      }\n\n      console.log(chalk.blue(' Running vibe-check evals...\\n'));\n\n      const runner = new EvalRunner(config);\n      const result = await runner.run({\n        categories: options.category as EvalCategory[] | undefined,\n        tags: options.tag,\n        ids: options.id,\n      });\n\n      console.log();\n      printSummary(result);\n\n      process.exit(result.failed + result.errors > 0 ? 1 : 0);\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nprogram\n  .command('list')\n  .description('List all eval cases')\n  .option('-c, --config <path>', 'Path to config file')\n  .option('--category <categories...>', 'Filter by category')\n  .option('--tag <tags...>', 'Filter by tag')\n  .option('--json', 'Output as JSON')\n  .action(async (options) => {\n    try {\n      const config = await loadConfig(options.config);\n      const { loadEvalCases } = await import('../utils/eval-loader.js');\n\n      const evalCases = await loadEvalCases({\n        testDir: config.testDir,\n        testMatch: config.testMatch,\n        categories: options.category as EvalCategory[] | undefined,\n        tags: options.tag,\n        enabledOnly: true,\n      });\n\n      if (options.json) {\n        console.log(JSON.stringify(evalCases, null, 2));\n      } else {\n        console.log(chalk.blue(`Found ${evalCases.length} eval cases:\\n`));\n\n        for (const evalCase of evalCases) {\n          const tags = evalCase.tags?.length ? chalk.gray(`[${evalCase.tags.join(', ')}]`) : '';\n          console.log(`  ${chalk.cyan(evalCase.id)} - ${evalCase.name} ${tags}`);\n          console.log(`    Category: ${evalCase.category}`);\n          if (evalCase.description) {\n            console.log(`    ${chalk.gray(evalCase.description)}`);\n          }\n          console.log();\n        }\n      }\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nprogram\n  .command('init')\n  .description('Initialize vibe-check in current project')\n  .option('--typescript', 'Create TypeScript config (default)')\n  .action(async () => {\n    const fs = await import('fs/promises');\n    const path = await import('path');\n\n    const configContent = `import { defineConfig } from '@pooflabs/vibe-check';\n\n// TODO: Import your AI agent SDK\n// import { query } from '@anthropic-ai/claude-agent-sdk';\n\nexport default defineConfig({\n  testDir: './__evals__',\n\n  // Implement your agent function\n  agent: async (prompt, context) => {\n    // TODO: Replace with your agent implementation\n    // For Claude Agent SDK:\n    // for await (const msg of query({ prompt, options: { cwd: context.workingDirectory } })) {\n    //   if (msg.type === 'result') {\n    //     return { output: msg.result || '', success: msg.subtype === 'success' };\n    //   }\n    // }\n\n    throw new Error('Agent not implemented - update vibe-check.config.ts');\n  },\n});\n`;\n\n    const evalExampleContent = `{\n  \"id\": \"example-eval\",\n  \"name\": \"Example Evaluation\",\n  \"description\": \"An example eval case\",\n  \"category\": \"basic\",\n  \"prompt\": \"Say hello world\",\n  \"judges\": []\n}\n`;\n\n    try {\n      const cwd = process.cwd();\n\n      await fs.writeFile(path.join(cwd, 'vibe-check.config.ts'), configContent);\n      console.log(chalk.green(''), 'Created vibe-check.config.ts');\n\n      await fs.mkdir(path.join(cwd, '__evals__'), { recursive: true });\n      await fs.writeFile(path.join(cwd, '__evals__', 'example.eval.json'), evalExampleContent);\n      console.log(chalk.green(''), 'Created __evals__/example.eval.json');\n\n      console.log();\n      console.log(chalk.blue('Next steps:'));\n      console.log('  1. Update vibe-check.config.ts with your agent function');\n      console.log('  2. Create eval cases in __evals__/*.eval.json');\n      console.log('  3. Run: bunx vibe-check run');\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Learning commands\nconst learn = program.command('learn').description('Learning loop commands');\n\nlearn\n  .command('run')\n  .description('Run full learning iteration')\n  .option('--source <source>', 'Data source to use (eval, jsonl, both)', 'eval')\n  .option('--auto-approve', 'Auto-approve high-confidence rules')\n  .option('--save-pending', 'Save rules for later review')\n  .action(async (options) => {\n    try {\n      const { LearningRunner } = await import('../learning/learning-runner.js');\n      const runner = new LearningRunner();\n\n      const sources = options.source === 'both' ? ['eval', 'jsonl'] : [options.source];\n\n      await runner.runIteration({\n        sources,\n        autoApprove: options.autoApprove,\n        savePending: options.savePending,\n      });\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nlearn\n  .command('analyze')\n  .description('Analyze failures without generating rules')\n  .option('--source <source>', 'Data source to use (eval, jsonl, both)', 'eval')\n  .action(async (options) => {\n    try {\n      const { LearningRunner } = await import('../learning/learning-runner.js');\n      const runner = new LearningRunner();\n\n      const sources = options.source === 'both' ? ['eval', 'jsonl'] : [options.source];\n\n      await runner.analyze({ sources });\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nlearn\n  .command('review')\n  .description('Review pending rules')\n  .action(async () => {\n    try {\n      const { LearningRunner } = await import('../learning/learning-runner.js');\n      const runner = new LearningRunner();\n      await runner.reviewPending();\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nlearn\n  .command('stats')\n  .description('Show learning system statistics')\n  .action(async () => {\n    try {\n      const { LearningRunner } = await import('../learning/learning-runner.js');\n      const runner = new LearningRunner();\n      await runner.showStats();\n    } catch (error) {\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nfunction printSummary(result: import('../runner/eval-runner.js').EvalSuiteResult): void {\n  const { total, passed, failed, errors, passRate, duration } = result;\n\n  console.log(chalk.bold('Results:'));\n  console.log(`  Total:  ${total}`);\n  console.log(`  ${chalk.green('Passed:')} ${passed}`);\n\n  if (failed > 0) {\n    console.log(`  ${chalk.red('Failed:')} ${failed}`);\n  }\n\n  if (errors > 0) {\n    console.log(`  ${chalk.yellow('Errors:')} ${errors}`);\n  }\n\n  console.log();\n  console.log(`  Pass rate: ${chalk.bold((passRate * 100).toFixed(1) + '%')}`);\n  console.log(`  Duration:  ${(duration / 1000).toFixed(2)}s`);\n\n  if (result.results.length > 0 && (failed > 0 || errors > 0)) {\n    console.log();\n    console.log(chalk.bold('Failed cases:'));\n\n    for (const r of result.results) {\n      if (!r.success) {\n        console.log(`  ${chalk.red('')} ${r.evalCase.name}`);\n        if (r.error) {\n          console.log(`    ${chalk.gray(r.error.message)}`);\n        }\n        for (const judge of r.judgeResults) {\n          if (!judge.passed) {\n            console.log(`    ${chalk.gray(`[${judge.judgeId}] ${judge.reasoning}`)}`);\n          }\n        }\n      }\n    }\n  }\n}\n\n// Handle graceful shutdown signals\nlet shuttingDown = false;\nconst handleShutdown = (signal: string) => {\n  if (shuttingDown) return;\n  shuttingDown = true;\n  console.log(`\\n${chalk.yellow(`Received ${signal}, shutting down gracefully...`)}`);\n  process.exit(1);\n};\n\nprocess.on('SIGTERM', () => handleShutdown('SIGTERM'));\nprocess.on('SIGINT', () => handleShutdown('SIGINT'));\n\nprogram.parse();\n"]}