{"version":3,"sources":["../../src/judges/judge-interface.ts","../../src/config/schemas.ts","../../src/judges/builtin/file-existence.ts","../../src/judges/builtin/tool-invocation.ts","../../src/judges/builtin/pattern-match.ts","../../src/judges/judge-registry.ts"],"names":["passed","path2","fs2"],"mappings":"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","file":"index.js","sourcesContent":["import type { EvalCase, JudgeResult } from '../config/schemas.js';\nimport type { AgentResult } from '../config/types.js';\n\nexport interface ExecutionResult {\n  success: boolean;\n  output: string;\n  error?: Error;\n  toolCalls: ToolCallRecord[];\n  duration: number;\n  numTurns?: number;\n  sessionId?: string;\n  workingDirectory?: string;\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalCostUsd?: number;\n  };\n}\n\nexport interface ToolCallRecord {\n  toolName: string;\n  toolUseId?: string;\n  input: unknown;\n  output?: unknown;\n  timestamp?: number;\n  duration?: number;\n  isError?: boolean;\n}\n\nexport interface JudgeContext {\n  evalCase: EvalCase;\n  executionResult: ExecutionResult;\n  workingDirectory: string;\n  turnIndex?: number;\n}\n\nexport type JudgeType = 'code' | 'llm' | 'hybrid';\n\nexport interface Judge {\n  id: string;\n  name: string;\n  type: JudgeType;\n  evaluate(context: JudgeContext): Promise<JudgeResult>;\n}\n\nexport abstract class BaseJudge implements Judge {\n  abstract id: string;\n  abstract name: string;\n  abstract type: JudgeType;\n\n  abstract evaluate(context: JudgeContext): Promise<JudgeResult>;\n\n  protected createResult(params: {\n    passed: boolean;\n    score: number;\n    reasoning: string;\n    confidence?: number;\n    details?: Record<string, unknown>;\n  }): JudgeResult {\n    return {\n      judgeId: this.id,\n      passed: params.passed,\n      score: params.score,\n      confidence: params.confidence ?? 1,\n      reasoning: params.reasoning,\n      details: params.details,\n    };\n  }\n\n  protected notApplicable(reason: string = 'Not applicable'): JudgeResult {\n    return this.createResult({\n      passed: true,\n      score: 100,\n      reasoning: reason,\n    });\n  }\n}\n\nexport function agentResultToExecutionResult(result: AgentResult): ExecutionResult {\n  return {\n    success: result.success,\n    output: result.output,\n    error: result.error,\n    toolCalls: (result.toolCalls ?? []).map(tc => ({\n      toolName: tc.toolName,\n      input: tc.input,\n      output: tc.output,\n      isError: tc.isError,\n    })),\n    duration: result.duration ?? 0,\n    numTurns: result.numTurns,\n    sessionId: result.sessionId,\n    usage: result.usage,\n  };\n}\n\nexport { JudgeResult };\n","import { z } from 'zod';\n\nexport const EvalCategorySchema = z.enum(['tool', 'code-gen', 'multi-turn', 'routing', 'basic']);\nexport type EvalCategory = z.infer<typeof EvalCategorySchema>;\n\nexport const EvalAgentTypeSchema = z.enum(['coding', 'conversational', 'research', 'computer-use', 'general']);\nexport type EvalAgentType = z.infer<typeof EvalAgentTypeSchema>;\n\nexport const ReferenceSolutionSchema = z.object({\n  files: z.array(z.string()).optional(),\n  description: z.string().optional(),\n  code: z.string().optional(),\n});\nexport type ReferenceSolution = z.infer<typeof ReferenceSolutionSchema>;\n\nexport const TrialConfigSchema = z.object({\n  count: z.number().min(1).max(10).default(1),\n  passThreshold: z.number().min(0).max(1).default(0.5),\n});\nexport type TrialConfig = z.infer<typeof TrialConfigSchema>;\n\nconst BaseEvalCaseSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  description: z.string(),\n  category: EvalCategorySchema,\n  tags: z.array(z.string()).optional(),\n  enabled: z.boolean().default(true),\n  timeout: z.number().optional(),\n  agentType: EvalAgentTypeSchema.optional(),\n  trials: TrialConfigSchema.optional(),\n  referenceSolution: ReferenceSolutionSchema.optional(),\n});\n\nexport const ExpectedToolCallSchema = z.object({\n  toolName: z.string(),\n  expectedInput: z.record(z.unknown()).optional(),\n  minCalls: z.number().optional(),\n  maxCalls: z.number().optional(),\n});\nexport type ExpectedToolCall = z.infer<typeof ExpectedToolCallSchema>;\n\nexport const ExpectedSkillSchema = z.object({\n  skillName: z.string(),\n  minCalls: z.number().optional().default(1),\n});\nexport type ExpectedSkill = z.infer<typeof ExpectedSkillSchema>;\n\nexport const ToolEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('tool'),\n  prompt: z.string(),\n  expectedToolCalls: z.array(ExpectedToolCallSchema),\n  expectedSkills: z.array(ExpectedSkillSchema).optional(),\n  judges: z.array(z.string()),\n});\nexport type ToolEvalCase = z.infer<typeof ToolEvalSchema>;\n\nexport const ExpectedPatternSchema = z.object({\n  file: z.string(),\n  patterns: z.array(z.string()),\n});\nexport type ExpectedPattern = z.infer<typeof ExpectedPatternSchema>;\n\nexport const CodeGenEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('code-gen'),\n  prompt: z.string(),\n  targetFiles: z.array(z.string()),\n  expectedPatterns: z.array(ExpectedPatternSchema).optional(),\n  syntaxValidation: z.boolean().default(true),\n  buildVerification: z.boolean().default(false),\n  judges: z.array(z.string()),\n});\nexport type CodeGenEvalCase = z.infer<typeof CodeGenEvalSchema>;\n\nexport const RoutingEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('routing'),\n  prompt: z.string(),\n  expectedAgent: z.string(),\n  shouldNotRoute: z.array(z.string()).optional(),\n  judges: z.array(z.string()),\n});\nexport type RoutingEvalCase = z.infer<typeof RoutingEvalSchema>;\n\nexport const TurnSchema = z.object({\n  prompt: z.string(),\n  expectedBehavior: z.string().optional(),\n  judges: z.array(z.string()).optional(),\n});\nexport type Turn = z.infer<typeof TurnSchema>;\n\nexport const MultiTurnEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('multi-turn'),\n  turns: z.array(TurnSchema),\n  sessionPersistence: z.boolean().default(true),\n  contextValidation: z.array(z.string()).optional(),\n  judges: z.array(z.string()).optional(),\n});\nexport type MultiTurnEvalCase = z.infer<typeof MultiTurnEvalSchema>;\n\nexport const BasicEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('basic'),\n  prompt: z.string(),\n  expectedBehavior: z.string().optional(),\n  judges: z.array(z.string()),\n});\nexport type BasicEvalCase = z.infer<typeof BasicEvalSchema>;\n\nexport const EvalCaseSchema = z.discriminatedUnion('category', [\n  ToolEvalSchema,\n  CodeGenEvalSchema,\n  RoutingEvalSchema,\n  MultiTurnEvalSchema,\n  BasicEvalSchema,\n]);\nexport type EvalCase = z.infer<typeof EvalCaseSchema>;\n\nexport function parseEvalCase(data: unknown): EvalCase {\n  return EvalCaseSchema.parse(data);\n}\n\nexport function isToolEval(evalCase: EvalCase): evalCase is ToolEvalCase {\n  return evalCase.category === 'tool';\n}\n\nexport function isCodeGenEval(evalCase: EvalCase): evalCase is CodeGenEvalCase {\n  return evalCase.category === 'code-gen';\n}\n\nexport function isRoutingEval(evalCase: EvalCase): evalCase is RoutingEvalCase {\n  return evalCase.category === 'routing';\n}\n\nexport function isMultiTurnEval(evalCase: EvalCase): evalCase is MultiTurnEvalCase {\n  return evalCase.category === 'multi-turn';\n}\n\nexport function isBasicEval(evalCase: EvalCase): evalCase is BasicEvalCase {\n  return evalCase.category === 'basic';\n}\n\nexport interface JudgeResult {\n  judgeId: string;\n  passed: boolean;\n  score: number;\n  confidence: number;\n  reasoning: string;\n  details?: Record<string, unknown>;\n}\n\nexport interface EvalCaseResult {\n  evalCase: EvalCase;\n  success: boolean;\n  output: string;\n  duration: number;\n  judgeResults: JudgeResult[];\n  toolCalls?: Array<{ toolName: string; input: unknown; output?: unknown; isError?: boolean }>;\n  error?: Error;\n  retryCount?: number;\n  trialResults?: boolean[];\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface FileCheckResult {\n  file: string;\n  exists: boolean;\n}\n\nexport class FileExistenceJudge extends BaseJudge {\n  id = 'file-existence';\n  name = 'File Existence Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    const targetFiles = evalCase.targetFiles || [];\n    if (targetFiles.length === 0) {\n      return this.notApplicable('No target files specified');\n    }\n\n    const baseDir = workingDirectory || process.cwd();\n    const results: FileCheckResult[] = [];\n\n    for (const file of targetFiles) {\n      const fullPath = path.join(baseDir, file);\n      try {\n        await fs.access(fullPath);\n        results.push({ file, exists: true });\n      } catch {\n        results.push({ file, exists: false });\n      }\n    }\n\n    const existingCount = results.filter((r) => r.exists).length;\n    const score = (existingCount / targetFiles.length) * 100;\n    const passed = score >= 80;\n\n    const missingFiles = results.filter((r) => !r.exists).map((r) => r.file);\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        missingFiles.length > 0\n          ? `${existingCount}/${targetFiles.length} expected files exist. Missing: ${missingFiles.join(', ')}`\n          : `All ${targetFiles.length} expected files exist`,\n      details: { results, missingFiles },\n    });\n  }\n}\n","import { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isToolEval } from '../../config/schemas.js';\nimport type { ExpectedToolCall } from '../../config/schemas.js';\n\ninterface ToolCallStats {\n  toolName: string;\n  expected: ExpectedToolCall;\n  actualCount: number;\n  passed: boolean;\n  reason: string;\n}\n\nexport class ToolInvocationJudge extends BaseJudge {\n  id = 'tool-invocation';\n  name = 'Tool Invocation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase } = context;\n\n    if (!isToolEval(evalCase)) {\n      return this.notApplicable('Only applicable for tool evals');\n    }\n\n    const expectedCalls = evalCase.expectedToolCalls || [];\n    if (expectedCalls.length === 0) {\n      return this.notApplicable('No expected tool calls specified');\n    }\n\n    const actualCalls = executionResult.toolCalls || [];\n    const toolCallCounts = new Map<string, number>();\n\n    for (const call of actualCalls) {\n      const count = toolCallCounts.get(call.toolName) || 0;\n      toolCallCounts.set(call.toolName, count + 1);\n    }\n\n    const stats: ToolCallStats[] = [];\n\n    for (const expected of expectedCalls) {\n      const actualCount = toolCallCounts.get(expected.toolName) || 0;\n      const minCalls = expected.minCalls ?? 1;\n      const maxCalls = expected.maxCalls ?? Infinity;\n\n      let passed = true;\n      let reason = '';\n\n      if (actualCount < minCalls) {\n        passed = false;\n        reason = `Expected at least ${minCalls} call(s), got ${actualCount}`;\n      } else if (actualCount > maxCalls) {\n        passed = false;\n        reason = `Expected at most ${maxCalls} call(s), got ${actualCount}`;\n      } else {\n        reason = `Called ${actualCount} time(s)`;\n      }\n\n      stats.push({\n        toolName: expected.toolName,\n        expected,\n        actualCount,\n        passed,\n        reason,\n      });\n    }\n\n    const passedCount = stats.filter((s) => s.passed).length;\n    const score = (passedCount / stats.length) * 100;\n    const passed = passedCount === stats.length;\n\n    const failedTools = stats.filter((s) => !s.passed);\n    const reasoning =\n      failedTools.length > 0\n        ? `${passedCount}/${stats.length} expected tool invocations satisfied. Failed: ${failedTools.map((s) => `${s.toolName} (${s.reason})`).join(', ')}`\n        : `All ${stats.length} expected tool invocations satisfied`;\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: {\n        stats,\n        actualToolCalls: actualCalls.map((c) => c.toolName),\n        toolCallCounts: Object.fromEntries(toolCallCounts),\n      },\n    });\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface PatternCheckResult {\n  file: string;\n  patterns: Array<{\n    pattern: string;\n    found: boolean;\n  }>;\n  allFound: boolean;\n}\n\nexport class PatternMatchJudge extends BaseJudge {\n  id = 'pattern-match';\n  name = 'Pattern Match Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    const expectedPatterns = evalCase.expectedPatterns || [];\n    if (expectedPatterns.length === 0) {\n      return this.notApplicable('No expected patterns specified');\n    }\n\n    const baseDir = workingDirectory || process.cwd();\n    const results: PatternCheckResult[] = [];\n\n    for (const { file, patterns } of expectedPatterns) {\n      const fullPath = path.join(baseDir, file);\n      let content = '';\n\n      try {\n        content = await fs.readFile(fullPath, 'utf-8');\n      } catch {\n        results.push({\n          file,\n          patterns: patterns.map((p) => ({ pattern: p, found: false })),\n          allFound: false,\n        });\n        continue;\n      }\n\n      const patternResults = patterns.map((pattern) => {\n        const regex = new RegExp(pattern, 'gm');\n        return {\n          pattern,\n          found: regex.test(content),\n        };\n      });\n\n      results.push({\n        file,\n        patterns: patternResults,\n        allFound: patternResults.every((p) => p.found),\n      });\n    }\n\n    const totalPatterns = results.reduce((sum, r) => sum + r.patterns.length, 0);\n    const foundPatterns = results.reduce(\n      (sum, r) => sum + r.patterns.filter((p) => p.found).length,\n      0\n    );\n    const score = totalPatterns > 0 ? (foundPatterns / totalPatterns) * 100 : 100;\n    const passed = score >= 80;\n\n    const failedFiles = results.filter((r) => !r.allFound);\n    const reasoning =\n      failedFiles.length > 0\n        ? `${foundPatterns}/${totalPatterns} patterns found. Missing patterns in: ${failedFiles.map((r) => r.file).join(', ')}`\n        : `All ${totalPatterns} expected patterns found`;\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: { results },\n    });\n  }\n}\n","import type { Judge, JudgeType } from './judge-interface.js';\nimport { FileExistenceJudge } from './builtin/file-existence.js';\nimport { ToolInvocationJudge } from './builtin/tool-invocation.js';\nimport { PatternMatchJudge } from './builtin/pattern-match.js';\n\nexport class JudgeRegistry {\n  private judges: Map<string, Judge> = new Map();\n\n  constructor() {\n    this.registerBuiltInJudges();\n  }\n\n  private registerBuiltInJudges(): void {\n    this.register(new FileExistenceJudge());\n    this.register(new ToolInvocationJudge());\n    this.register(new PatternMatchJudge());\n  }\n\n  register(judge: Judge): void {\n    this.judges.set(judge.id, judge);\n  }\n\n  unregister(id: string): boolean {\n    return this.judges.delete(id);\n  }\n\n  get(id: string): Judge | undefined {\n    return this.judges.get(id);\n  }\n\n  has(id: string): boolean {\n    return this.judges.has(id);\n  }\n\n  list(): string[] {\n    return Array.from(this.judges.keys());\n  }\n\n  listByType(type: JudgeType): string[] {\n    return Array.from(this.judges.entries())\n      .filter(([_, judge]) => judge.type === type)\n      .map(([id]) => id);\n  }\n\n  getAll(): Judge[] {\n    return Array.from(this.judges.values());\n  }\n}\n\nlet defaultRegistry: JudgeRegistry | null = null;\n\nexport function getJudgeRegistry(): JudgeRegistry {\n  if (!defaultRegistry) {\n    defaultRegistry = new JudgeRegistry();\n  }\n  return defaultRegistry;\n}\n\nexport function resetJudgeRegistry(): void {\n  defaultRegistry = null;\n}\n"]}