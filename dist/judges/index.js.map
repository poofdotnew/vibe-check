{"version":3,"sources":["../../src/judges/judge-interface.ts","../../src/config/schemas.ts","../../src/judges/builtin/file-existence.ts","../../src/judges/builtin/tool-invocation.ts","../../src/judges/builtin/pattern-match.ts","../../src/judges/builtin/agent-routing.ts","../../src/judges/builtin/skill-invocation.ts","../../src/judges/builtin/syntax-validation.ts","../../src/judges/builtin/llm-judge.ts","../../src/judges/judge-registry.ts"],"names":["path","fs","passed","path2","fs2","path3","stat","path4","fs4","path5","fs5","fs6"],"mappings":"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","file":"index.js","sourcesContent":["import type { EvalCase, JudgeResult } from '../config/schemas.js';\nimport type { AgentResult, Transcript, ProgressRecord } from '../config/types.js';\n\nexport interface ExecutionResult {\n  success: boolean;\n  output: string;\n  error?: Error;\n  toolCalls: ToolCallRecord[];\n  duration: number;\n  numTurns?: number;\n  sessionId?: string;\n  workingDirectory?: string;\n  workspaceId?: string;\n  transcript?: Transcript;\n  progressUpdates?: ProgressRecord[];\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalCostUsd?: number;\n  };\n}\n\nexport interface ToolCallRecord {\n  toolName: string;\n  toolUseId?: string;\n  input: unknown;\n  output?: unknown;\n  timestamp?: number;\n  duration?: number;\n  isError?: boolean;\n}\n\nexport interface JudgeContext {\n  evalCase: EvalCase;\n  executionResult: ExecutionResult;\n  workingDirectory: string;\n  turnIndex?: number;\n}\n\nexport type JudgeType = 'code' | 'llm' | 'hybrid';\n\nexport interface Judge {\n  id: string;\n  name: string;\n  type: JudgeType;\n  evaluate(context: JudgeContext): Promise<JudgeResult>;\n}\n\nexport abstract class BaseJudge implements Judge {\n  abstract id: string;\n  abstract name: string;\n  abstract type: JudgeType;\n\n  abstract evaluate(context: JudgeContext): Promise<JudgeResult>;\n\n  protected createResult(params: {\n    passed: boolean;\n    score: number;\n    reasoning: string;\n    confidence?: number;\n    details?: Record<string, unknown>;\n  }): JudgeResult {\n    return {\n      judgeId: this.id,\n      passed: params.passed,\n      score: params.score,\n      confidence: params.confidence ?? 1,\n      reasoning: params.reasoning,\n      details: params.details,\n    };\n  }\n\n  protected notApplicable(reason: string = 'Not applicable'): JudgeResult {\n    return this.createResult({\n      passed: true,\n      score: 100,\n      reasoning: reason,\n    });\n  }\n}\n\nexport function agentResultToExecutionResult(result: AgentResult): ExecutionResult {\n  return {\n    success: result.success,\n    output: result.output,\n    error: result.error,\n    toolCalls: (result.toolCalls ?? []).map(tc => ({\n      toolName: tc.toolName,\n      input: tc.input,\n      output: tc.output,\n      isError: tc.isError,\n    })),\n    duration: result.duration ?? 0,\n    numTurns: result.numTurns,\n    sessionId: result.sessionId,\n    usage: result.usage,\n  };\n}\n\nexport { JudgeResult };\n","import { z } from 'zod';\n\nexport const EvalCategorySchema = z.enum(['tool', 'code-gen', 'multi-turn', 'routing', 'basic']);\nexport type EvalCategory = z.infer<typeof EvalCategorySchema>;\n\nexport const EvalAgentTypeSchema = z.enum(['coding', 'conversational', 'research', 'computer-use', 'general']);\nexport type EvalAgentType = z.infer<typeof EvalAgentTypeSchema>;\n\nexport const ReferenceSolutionSchema = z.object({\n  files: z.array(z.string()).optional(),\n  description: z.string().optional(),\n  code: z.string().optional(),\n});\nexport type ReferenceSolution = z.infer<typeof ReferenceSolutionSchema>;\n\nexport const TrialConfigSchema = z.object({\n  count: z.number().min(1).max(10).default(1),\n  passThreshold: z.number().min(0).max(1).default(0.5),\n});\nexport type TrialConfig = z.infer<typeof TrialConfigSchema>;\n\nconst BaseEvalCaseSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  description: z.string(),\n  category: EvalCategorySchema,\n  tags: z.array(z.string()).optional(),\n  enabled: z.boolean().default(true),\n  timeout: z.number().optional(),\n  agentType: EvalAgentTypeSchema.optional(),\n  trials: TrialConfigSchema.optional(),\n  referenceSolution: ReferenceSolutionSchema.optional(),\n});\n\nexport const ExpectedToolCallSchema = z.object({\n  toolName: z.string(),\n  expectedInput: z.record(z.unknown()).optional(),\n  minCalls: z.number().optional(),\n  maxCalls: z.number().optional(),\n});\nexport type ExpectedToolCall = z.infer<typeof ExpectedToolCallSchema>;\n\nexport const ExpectedSkillSchema = z.object({\n  skillName: z.string(),\n  minCalls: z.number().optional().default(1),\n});\nexport type ExpectedSkill = z.infer<typeof ExpectedSkillSchema>;\n\nexport const ToolEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('tool'),\n  prompt: z.string(),\n  expectedToolCalls: z.array(ExpectedToolCallSchema),\n  expectedSkills: z.array(ExpectedSkillSchema).optional(),\n  judges: z.array(z.string()),\n});\nexport type ToolEvalCase = z.infer<typeof ToolEvalSchema>;\n\nexport const ExpectedPatternSchema = z.object({\n  file: z.string(),\n  patterns: z.array(z.string()),\n});\nexport type ExpectedPattern = z.infer<typeof ExpectedPatternSchema>;\n\nexport const CodeGenEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('code-gen'),\n  prompt: z.string(),\n  targetFiles: z.array(z.string()),\n  expectedPatterns: z.array(ExpectedPatternSchema).optional(),\n  syntaxValidation: z.boolean().default(true),\n  buildVerification: z.boolean().default(false),\n  judges: z.array(z.string()),\n});\nexport type CodeGenEvalCase = z.infer<typeof CodeGenEvalSchema>;\n\nexport const RoutingEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('routing'),\n  prompt: z.string(),\n  expectedAgent: z.string(),\n  shouldNotRoute: z.array(z.string()).optional(),\n  judges: z.array(z.string()),\n});\nexport type RoutingEvalCase = z.infer<typeof RoutingEvalSchema>;\n\nexport const TurnSchema = z.object({\n  prompt: z.string(),\n  expectedBehavior: z.string().optional(),\n  judges: z.array(z.string()).optional(),\n});\nexport type Turn = z.infer<typeof TurnSchema>;\n\nexport const MultiTurnEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('multi-turn'),\n  turns: z.array(TurnSchema),\n  sessionPersistence: z.boolean().default(true),\n  contextValidation: z.array(z.string()).optional(),\n  judges: z.array(z.string()).optional(),\n});\nexport type MultiTurnEvalCase = z.infer<typeof MultiTurnEvalSchema>;\n\nexport const BasicEvalSchema = BaseEvalCaseSchema.extend({\n  category: z.literal('basic'),\n  prompt: z.string(),\n  expectedBehavior: z.string().optional(),\n  judges: z.array(z.string()),\n});\nexport type BasicEvalCase = z.infer<typeof BasicEvalSchema>;\n\nexport const EvalCaseSchema = z.discriminatedUnion('category', [\n  ToolEvalSchema,\n  CodeGenEvalSchema,\n  RoutingEvalSchema,\n  MultiTurnEvalSchema,\n  BasicEvalSchema,\n]);\nexport type EvalCase = z.infer<typeof EvalCaseSchema>;\n\nexport function parseEvalCase(data: unknown): EvalCase {\n  return EvalCaseSchema.parse(data);\n}\n\nexport function isToolEval(evalCase: EvalCase): evalCase is ToolEvalCase {\n  return evalCase.category === 'tool';\n}\n\nexport function isCodeGenEval(evalCase: EvalCase): evalCase is CodeGenEvalCase {\n  return evalCase.category === 'code-gen';\n}\n\nexport function isRoutingEval(evalCase: EvalCase): evalCase is RoutingEvalCase {\n  return evalCase.category === 'routing';\n}\n\nexport function isMultiTurnEval(evalCase: EvalCase): evalCase is MultiTurnEvalCase {\n  return evalCase.category === 'multi-turn';\n}\n\nexport function isBasicEval(evalCase: EvalCase): evalCase is BasicEvalCase {\n  return evalCase.category === 'basic';\n}\n\nexport interface JudgeResult {\n  judgeId: string;\n  passed: boolean;\n  score: number;\n  confidence: number;\n  reasoning: string;\n  details?: Record<string, unknown>;\n}\n\nexport type ErrorType = 'api' | 'timeout' | 'judge' | 'unknown';\n\nexport interface EvalCaseResult {\n  evalCase: EvalCase;\n  success: boolean;\n  output: string;\n  duration: number;\n  judgeResults: JudgeResult[];\n  toolCalls?: Array<{ toolName: string; input: unknown; output?: unknown; isError?: boolean; timestamp?: number; duration?: number }>;\n  error?: Error;\n  errorType?: ErrorType;\n  retryCount?: number;\n  trialResults?: boolean[];\n  /** Whether this test passed on a retry (indicates flaky test) */\n  flaky?: boolean;\n  /** Error messages from each failed retry attempt */\n  retryErrors?: string[];\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface FileCheckResult {\n  file: string;\n  exists: boolean;\n}\n\nexport class FileExistenceJudge extends BaseJudge {\n  id = 'file-existence';\n  name = 'File Existence Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    const targetFiles = evalCase.targetFiles || [];\n    if (targetFiles.length === 0) {\n      return this.notApplicable('No target files specified');\n    }\n\n    const baseDir = workingDirectory || process.cwd();\n    const results: FileCheckResult[] = [];\n\n    for (const file of targetFiles) {\n      const fullPath = path.join(baseDir, file);\n      try {\n        await fs.access(fullPath);\n        results.push({ file, exists: true });\n      } catch {\n        results.push({ file, exists: false });\n      }\n    }\n\n    const existingCount = results.filter((r) => r.exists).length;\n    const score = (existingCount / targetFiles.length) * 100;\n    const passed = score >= 80;\n\n    const missingFiles = results.filter((r) => !r.exists).map((r) => r.file);\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        missingFiles.length > 0\n          ? `${existingCount}/${targetFiles.length} expected files exist. Missing: ${missingFiles.join(', ')}`\n          : `All ${targetFiles.length} expected files exist`,\n      details: { results, missingFiles },\n    });\n  }\n}\n","import { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isToolEval } from '../../config/schemas.js';\nimport type { ExpectedToolCall } from '../../config/schemas.js';\n\ninterface ToolCallStats {\n  toolName: string;\n  expected: ExpectedToolCall;\n  actualCount: number;\n  passed: boolean;\n  reason: string;\n}\n\nexport class ToolInvocationJudge extends BaseJudge {\n  id = 'tool-invocation';\n  name = 'Tool Invocation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase } = context;\n\n    if (!isToolEval(evalCase)) {\n      return this.notApplicable('Only applicable for tool evals');\n    }\n\n    const expectedCalls = evalCase.expectedToolCalls || [];\n    if (expectedCalls.length === 0) {\n      return this.notApplicable('No expected tool calls specified');\n    }\n\n    const actualCalls = executionResult.toolCalls || [];\n    const toolCallCounts = new Map<string, number>();\n\n    for (const call of actualCalls) {\n      const count = toolCallCounts.get(call.toolName) || 0;\n      toolCallCounts.set(call.toolName, count + 1);\n    }\n\n    const stats: ToolCallStats[] = [];\n\n    for (const expected of expectedCalls) {\n      const actualCount = toolCallCounts.get(expected.toolName) || 0;\n      const minCalls = expected.minCalls ?? 1;\n      const maxCalls = expected.maxCalls ?? Infinity;\n\n      let passed = true;\n      let reason = '';\n\n      if (actualCount < minCalls) {\n        passed = false;\n        reason = `Expected at least ${minCalls} call(s), got ${actualCount}`;\n      } else if (actualCount > maxCalls) {\n        passed = false;\n        reason = `Expected at most ${maxCalls} call(s), got ${actualCount}`;\n      } else {\n        reason = `Called ${actualCount} time(s)`;\n      }\n\n      stats.push({\n        toolName: expected.toolName,\n        expected,\n        actualCount,\n        passed,\n        reason,\n      });\n    }\n\n    const passedCount = stats.filter((s) => s.passed).length;\n    const score = (passedCount / stats.length) * 100;\n    const passed = passedCount === stats.length;\n\n    const failedTools = stats.filter((s) => !s.passed);\n    const reasoning =\n      failedTools.length > 0\n        ? `${passedCount}/${stats.length} expected tool invocations satisfied. Failed: ${failedTools.map((s) => `${s.toolName} (${s.reason})`).join(', ')}`\n        : `All ${stats.length} expected tool invocations satisfied`;\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: {\n        stats,\n        actualToolCalls: actualCalls.map((c) => c.toolName),\n        toolCallCounts: Object.fromEntries(toolCallCounts),\n      },\n    });\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface PatternCheckResult {\n  file: string;\n  patterns: Array<{\n    pattern: string;\n    found: boolean;\n  }>;\n  allFound: boolean;\n}\n\nexport class PatternMatchJudge extends BaseJudge {\n  id = 'pattern-match';\n  name = 'Pattern Match Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    const expectedPatterns = evalCase.expectedPatterns || [];\n    if (expectedPatterns.length === 0) {\n      return this.notApplicable('No expected patterns specified');\n    }\n\n    const baseDir = workingDirectory || process.cwd();\n    const results: PatternCheckResult[] = [];\n\n    for (const { file, patterns } of expectedPatterns) {\n      const fullPath = path.join(baseDir, file);\n      let content = '';\n\n      try {\n        content = await fs.readFile(fullPath, 'utf-8');\n      } catch {\n        results.push({\n          file,\n          patterns: patterns.map((p) => ({ pattern: p, found: false })),\n          allFound: false,\n        });\n        continue;\n      }\n\n      const patternResults = patterns.map((pattern) => {\n        const regex = new RegExp(pattern, 'gm');\n        return {\n          pattern,\n          found: regex.test(content),\n        };\n      });\n\n      results.push({\n        file,\n        patterns: patternResults,\n        allFound: patternResults.every((p) => p.found),\n      });\n    }\n\n    const totalPatterns = results.reduce((sum, r) => sum + r.patterns.length, 0);\n    const foundPatterns = results.reduce(\n      (sum, r) => sum + r.patterns.filter((p) => p.found).length,\n      0\n    );\n    const score = totalPatterns > 0 ? (foundPatterns / totalPatterns) * 100 : 100;\n    const passed = score >= 80;\n\n    const failedFiles = results.filter((r) => !r.allFound);\n    const reasoning =\n      failedFiles.length > 0\n        ? `${foundPatterns}/${totalPatterns} patterns found. Missing patterns in: ${failedFiles.map((r) => r.file).join(', ')}`\n        : `All ${totalPatterns} expected patterns found`;\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: { results },\n    });\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isRoutingEval } from '../../config/schemas.js';\n\nconst DEFAULT_WORK_TYPE_KEYWORDS: Record<string, string[]> = {};\n\nexport interface AgentRoutingJudgeOptions {\n  workTypeKeywords?: Record<string, string[]>;\n}\n\nexport class AgentRoutingJudge extends BaseJudge {\n  id = 'agent-routing';\n  name = 'Agent Routing Judge';\n  type: JudgeType = 'code';\n\n  private workTypeKeywords: Record<string, string[]>;\n\n  constructor(options: AgentRoutingJudgeOptions = {}) {\n    super();\n    this.workTypeKeywords = options.workTypeKeywords || DEFAULT_WORK_TYPE_KEYWORDS;\n  }\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase, workingDirectory } = context;\n\n    if (!isRoutingEval(evalCase)) {\n      return this.notApplicable('Only applicable for routing evals');\n    }\n\n    const taskCalls = executionResult.toolCalls.filter(\n      (call) => call.toolName === 'Task' || call.toolName.includes('task')\n    );\n\n    let agentsInvoked = taskCalls\n      .map((call) => {\n        const input = call.input as Record<string, unknown> | undefined;\n        return (input?.agent as string) || (input?.subagent_type as string) || 'unknown';\n      })\n      .filter((agent) => agent !== 'unknown');\n\n    const jsonlAgents = await this.extractAgentsFromJsonl(workingDirectory);\n    agentsInvoked = [...new Set([...agentsInvoked, ...jsonlAgents])];\n\n    const expectedAgent = evalCase.expectedAgent;\n    const invokedExpected = agentsInvoked.includes(expectedAgent);\n\n    const forbiddenAgents = evalCase.shouldNotRoute || [];\n    const invokedForbidden = forbiddenAgents.filter((a) => agentsInvoked.includes(a));\n\n    const output = executionResult.output || '';\n    const outputLower = output.toLowerCase();\n    const hasDelegationIntent = this.checkDelegationIntent(outputLower, expectedAgent, forbiddenAgents);\n\n    let score: number;\n    let passed: boolean;\n    let reasoning: string;\n\n    if (invokedExpected && invokedForbidden.length === 0) {\n      score = 100;\n      passed = true;\n      reasoning = `Correctly routed to ${expectedAgent}`;\n    } else if (invokedExpected && invokedForbidden.length > 0) {\n      score = 50;\n      passed = false;\n      reasoning = `Routed to ${expectedAgent} but also incorrectly routed to: ${invokedForbidden.join(', ')}`;\n    } else if (hasDelegationIntent.toExpected && !hasDelegationIntent.toForbidden) {\n      score = 80;\n      passed = true;\n      reasoning = `AI indicated delegation intent to ${expectedAgent} (no actual Task tool invocation detected)`;\n    } else if (hasDelegationIntent.toExpected && hasDelegationIntent.toForbidden) {\n      score = 40;\n      passed = false;\n      reasoning = `AI mentioned ${expectedAgent} but also mentioned forbidden agents`;\n    } else if (hasDelegationIntent.performedRightWork) {\n      score = 70;\n      passed = true;\n      reasoning = `AI performed ${expectedAgent}-appropriate work directly (no delegation, but correct work type)`;\n    } else if (agentsInvoked.length === 0) {\n      score = 0;\n      passed = false;\n      reasoning = `Expected ${expectedAgent} but no agent was invoked and no delegation intent detected. The main agent may have handled the task directly.`;\n    } else {\n      score = 0;\n      passed = false;\n      reasoning = `Expected ${expectedAgent} but got: ${agentsInvoked.join(', ')}`;\n    }\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning,\n      details: {\n        agentsInvoked,\n        expectedAgent,\n        invokedForbidden,\n        taskCallCount: taskCalls.length,\n        jsonlAgentsFound: jsonlAgents,\n        delegationIntentDetected: hasDelegationIntent.toExpected,\n        performedRightWork: hasDelegationIntent.performedRightWork,\n      },\n    });\n  }\n\n  private async extractAgentsFromJsonl(workspacePath: string): Promise<string[]> {\n    const agents: string[] = [];\n\n    try {\n      const claudeDir = path.join(workspacePath, '.claude', 'projects');\n\n      try {\n        await fs.access(claudeDir);\n      } catch {\n        return agents;\n      }\n\n      const projectDirs = await fs.readdir(claudeDir);\n\n      for (const projectDir of projectDirs) {\n        const projectPath = path.join(claudeDir, projectDir);\n        const stat = await fs.stat(projectPath);\n\n        if (!stat.isDirectory()) continue;\n\n        const files = await fs.readdir(projectPath);\n        const jsonlFiles = files.filter(f => f.endsWith('.jsonl'));\n\n        for (const jsonlFile of jsonlFiles) {\n          const filePath = path.join(projectPath, jsonlFile);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const lines = content.split('\\n').filter(line => line.trim());\n\n          for (const line of lines) {\n            try {\n              const entry = JSON.parse(line);\n              const message = entry.message;\n\n              if (!message?.content || !Array.isArray(message.content)) continue;\n\n              for (const block of message.content) {\n                if (block.type === 'tool_use' && block.name === 'Task') {\n                  const input = block.input as Record<string, unknown> | undefined;\n                  const agentType = (input?.subagent_type as string) || (input?.agent as string);\n                  if (agentType && !agents.includes(agentType)) {\n                    agents.push(agentType);\n                  }\n                }\n              }\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n        }\n      }\n    } catch {\n      // Ignore errors reading JSONL\n    }\n\n    return agents;\n  }\n\n  private checkDelegationIntent(\n    outputLower: string,\n    expectedAgent: string,\n    forbiddenAgents: string[]\n  ): { toExpected: boolean; toForbidden: boolean; performedRightWork: boolean } {\n    const delegationKeywords = [\n      'delegate',\n      'task tool',\n      'subagent',\n      'agent',\n      'specialized',\n      'use the',\n      'invoke',\n      'call the',\n    ];\n\n    const expectedAgentLower = expectedAgent.toLowerCase();\n    const mentionsExpected = outputLower.includes(expectedAgentLower);\n    const hasDelegationContext = delegationKeywords.some((kw) => outputLower.includes(kw));\n\n    const toExpected = mentionsExpected && hasDelegationContext;\n\n    const toForbidden = forbiddenAgents.some((agent) => {\n      const agentLower = agent.toLowerCase();\n      return outputLower.includes(agentLower) && hasDelegationContext;\n    });\n\n    const performedRightWork = this.checkWorkType(outputLower, expectedAgent);\n\n    return { toExpected, toForbidden, performedRightWork };\n  }\n\n  private checkWorkType(outputLower: string, expectedAgent: string): boolean {\n    const keywords = this.workTypeKeywords[expectedAgent] || [];\n    if (keywords.length === 0) return false;\n\n    const matchCount = keywords.filter((kw) => outputLower.includes(kw)).length;\n    return matchCount >= 2;\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isToolEval } from '../../config/schemas.js';\n\ninterface SkillCheckResult {\n  skillName: string;\n  found: boolean;\n  callCount: number;\n  meetsMin: boolean;\n}\n\nexport class SkillInvocationJudge extends BaseJudge {\n  id = 'skill-invocation';\n  name = 'Skill Invocation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, executionResult, workingDirectory } = context;\n\n    if (!isToolEval(evalCase)) {\n      return this.notApplicable('Only applicable for tool evals');\n    }\n\n    const expectedSkills = evalCase.expectedSkills || [];\n    if (expectedSkills.length === 0) {\n      return this.notApplicable('No expected skills specified');\n    }\n\n    const jsonlSkillCalls = await this.extractSkillCallsFromJsonl(workingDirectory);\n    const mainAgentSkillCalls = this.extractSkillCallsFromToolCalls(executionResult.toolCalls || []);\n    const skillCalls = [...jsonlSkillCalls, ...mainAgentSkillCalls];\n\n    const results: SkillCheckResult[] = [];\n\n    for (const expected of expectedSkills) {\n      const matchCount = skillCalls.filter(\n        (call) => call.skillName === expected.skillName\n      ).length;\n\n      const meetsMin = matchCount >= (expected.minCalls ?? 1);\n\n      results.push({\n        skillName: expected.skillName,\n        found: matchCount > 0,\n        callCount: matchCount,\n        meetsMin,\n      });\n    }\n\n    const passedCount = results.filter((r) => r.found && r.meetsMin).length;\n    const score = (passedCount / expectedSkills.length) * 100;\n    const passed = score >= 80;\n\n    const failedChecks = results.filter((r) => !r.found || !r.meetsMin);\n    const allSkillNames = Array.from(new Set(skillCalls.map((c) => c.skillName)));\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        failedChecks.length > 0\n          ? `${passedCount}/${expectedSkills.length} expected skills invoked. Failed: ${failedChecks.map((f) => `${f.skillName} (found ${f.callCount}x)`).join(', ')}`\n          : `All ${expectedSkills.length} expected skills were invoked`,\n      details: {\n        results,\n        actualSkillNames: allSkillNames,\n        totalSkillCalls: skillCalls.length,\n      },\n    });\n  }\n\n  private extractSkillCallsFromToolCalls(toolCalls: Array<{ toolName: string; input: unknown }>): Array<{ skillName: string; input: unknown }> {\n    const skillCalls: Array<{ skillName: string; input: unknown }> = [];\n\n    for (const call of toolCalls) {\n      if (call.toolName === 'Skill') {\n        const input = call.input as Record<string, unknown> | undefined;\n        const skillName = input?.skill as string || input?.command as string;\n        if (skillName) {\n          skillCalls.push({\n            skillName: skillName.replace(/^\\//, ''),\n            input: input || {},\n          });\n        }\n      }\n    }\n\n    return skillCalls;\n  }\n\n  private async extractSkillCallsFromJsonl(workspacePath: string): Promise<Array<{ skillName: string; input: unknown }>> {\n    const skillCalls: Array<{ skillName: string; input: unknown }> = [];\n\n    try {\n      const claudeDir = path.join(workspacePath, '.claude', 'projects');\n\n      try {\n        await fs.access(claudeDir);\n      } catch {\n        return skillCalls;\n      }\n\n      const projectDirs = await fs.readdir(claudeDir);\n\n      for (const projectDir of projectDirs) {\n        const projectPath = path.join(claudeDir, projectDir);\n        const stat = await fs.stat(projectPath);\n\n        if (!stat.isDirectory()) continue;\n\n        const files = await fs.readdir(projectPath);\n        const jsonlFiles = files.filter(f => f.endsWith('.jsonl'));\n\n        for (const jsonlFile of jsonlFiles) {\n          const filePath = path.join(projectPath, jsonlFile);\n          const content = await fs.readFile(filePath, 'utf-8');\n          const lines = content.split('\\n').filter(line => line.trim());\n\n          for (const line of lines) {\n            try {\n              const entry = JSON.parse(line);\n              const message = entry.message;\n\n              if (!message?.content || !Array.isArray(message.content)) continue;\n\n              for (const block of message.content) {\n                if (block.type === 'tool_use' && block.name === 'Skill') {\n                  const input = block.input as Record<string, unknown> | undefined;\n                  const skillName = input?.skill as string || input?.command as string;\n                  if (skillName) {\n                    skillCalls.push({\n                      skillName: skillName.replace(/^\\//, ''),\n                      input: input || {},\n                    });\n                  }\n                }\n              }\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n        }\n      }\n    } catch {\n      // Ignore errors\n    }\n\n    return skillCalls;\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport { isCodeGenEval } from '../../config/schemas.js';\n\ninterface SyntaxCheckResult {\n  file: string;\n  valid: boolean;\n  error?: string;\n}\n\nexport class SyntaxValidationJudge extends BaseJudge {\n  id = 'syntax-validation';\n  name = 'Syntax Validation Judge';\n  type: JudgeType = 'code';\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { executionResult, evalCase, workingDirectory } = context;\n\n    if (!isCodeGenEval(evalCase)) {\n      return this.notApplicable('Only applicable for code-gen evals');\n    }\n\n    if (!evalCase.syntaxValidation) {\n      return this.notApplicable('Syntax validation disabled for this eval');\n    }\n\n    const targetFiles = evalCase.targetFiles || [];\n    const codeFiles = targetFiles.filter(\n      (f) => f.endsWith('.ts') || f.endsWith('.tsx') || f.endsWith('.js') || f.endsWith('.jsx')\n    );\n\n    if (codeFiles.length === 0) {\n      return this.notApplicable('No code files to validate');\n    }\n\n    const results: SyntaxCheckResult[] = [];\n\n    for (const file of codeFiles) {\n      const fullPath = path.join(workingDirectory || executionResult.workingDirectory || '', file);\n      try {\n        const content = await fs.readFile(fullPath, 'utf-8');\n        const isValid = await this.validateSyntax(content, file);\n        results.push({ file, valid: isValid.valid, error: isValid.error });\n      } catch (error) {\n        results.push({\n          file,\n          valid: false,\n          error: error instanceof Error ? error.message : 'File not found',\n        });\n      }\n    }\n\n    const validCount = results.filter((r) => r.valid).length;\n    const score = (validCount / codeFiles.length) * 100;\n    const passed = score >= 90;\n\n    const invalidFiles = results.filter((r) => !r.valid);\n\n    return this.createResult({\n      passed,\n      score,\n      reasoning:\n        invalidFiles.length > 0\n          ? `${validCount}/${codeFiles.length} files have valid syntax. Invalid: ${invalidFiles.map((f) => `${f.file} (${f.error})`).join(', ')}`\n          : `All ${codeFiles.length} files have valid syntax`,\n      details: { results },\n    });\n  }\n\n  private async validateSyntax(\n    content: string,\n    filename: string\n  ): Promise<{ valid: boolean; error?: string }> {\n    try {\n      const { parse } = await import('@babel/parser');\n\n      const isTypeScript = filename.endsWith('.ts') || filename.endsWith('.tsx');\n      const isJSX = filename.endsWith('.tsx') || filename.endsWith('.jsx');\n\n      const plugins: string[] = [];\n      if (isTypeScript) plugins.push('typescript');\n      if (isJSX) plugins.push('jsx');\n\n      parse(content, {\n        sourceType: 'module',\n        plugins: plugins as any[],\n      });\n\n      return { valid: true };\n    } catch (error) {\n      return {\n        valid: false,\n        error: error instanceof Error ? error.message : 'Parse error',\n      };\n    }\n  }\n}\n","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport Anthropic from '@anthropic-ai/sdk';\nimport { BaseJudge } from '../judge-interface.js';\nimport type { JudgeContext, JudgeResult, JudgeType } from '../judge-interface.js';\nimport type { ReferenceSolution } from '../../config/schemas.js';\n\nexport interface Rubric {\n  id: string;\n  content: string;\n}\n\nexport interface LLMJudgeOptions {\n  rubricsDir?: string;\n  model?: string;\n}\n\nconst DEFAULT_MODEL = 'claude-sonnet-4-20250514';\nconst DEFAULT_RUBRICS_DIR = './__evals__/rubrics';\n\nexport async function loadRubric(rubricPath: string, rubricsDir?: string): Promise<Rubric> {\n  const baseDir = rubricsDir || DEFAULT_RUBRICS_DIR;\n  const fullPath = path.isAbsolute(rubricPath)\n    ? rubricPath\n    : path.join(process.cwd(), baseDir, rubricPath);\n\n  const content = await fs.readFile(fullPath, 'utf-8');\n  const id = path.basename(rubricPath, path.extname(rubricPath));\n\n  return { id, content };\n}\n\nexport class LLMJudge extends BaseJudge {\n  id: string;\n  name: string;\n  type: JudgeType = 'llm';\n\n  private rubricPath: string;\n  private anthropic: Anthropic;\n  private rubricsDir: string;\n  private model: string;\n\n  constructor(id: string, rubricPath: string, options: LLMJudgeOptions = {}) {\n    super();\n    this.id = id;\n    this.name = `LLM Judge: ${id}`;\n    this.rubricPath = rubricPath;\n    this.rubricsDir = options.rubricsDir || DEFAULT_RUBRICS_DIR;\n    this.model = options.model || DEFAULT_MODEL;\n    this.anthropic = new Anthropic();\n  }\n\n  async evaluate(context: JudgeContext): Promise<JudgeResult> {\n    const { evalCase, executionResult, workingDirectory } = context;\n\n    let rubric: Rubric;\n    try {\n      rubric = await loadRubric(this.rubricPath, this.rubricsDir);\n    } catch (error) {\n      return this.createResult({\n        passed: false,\n        score: 0,\n        reasoning: `Failed to load rubric: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        confidence: 0,\n      });\n    }\n\n    const generatedFiles = await this.readTargetFiles(evalCase, workingDirectory);\n\n    const referenceSolution = evalCase.referenceSolution as ReferenceSolution | undefined;\n    let referenceFiles: Map<string, string> | undefined;\n    if (referenceSolution) {\n      referenceFiles = await this.readReferenceFiles(referenceSolution, workingDirectory);\n    }\n\n    const prompt = referenceFiles && referenceFiles.size > 0\n      ? this.buildPairwisePrompt(evalCase, executionResult, rubric, generatedFiles, referenceFiles)\n      : this.buildPrompt(evalCase, executionResult, rubric, generatedFiles);\n\n    try {\n      const response = await this.anthropic.messages.create({\n        model: this.model,\n        max_tokens: 1024,\n        messages: [{ role: 'user', content: prompt }],\n      });\n\n      const content = response.content[0];\n      if (content.type !== 'text') {\n        throw new Error('Unexpected response type from LLM');\n      }\n\n      return this.parseResponse(content.text);\n    } catch (error) {\n      return this.createResult({\n        passed: false,\n        score: 0,\n        reasoning: `LLM evaluation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        confidence: 0,\n      });\n    }\n  }\n\n  private async readReferenceFiles(\n    referenceSolution: ReferenceSolution,\n    workingDirectory: string\n  ): Promise<Map<string, string>> {\n    const files = new Map<string, string>();\n\n    if (referenceSolution.code) {\n      files.set('reference_code', referenceSolution.code);\n    }\n\n    if (referenceSolution.files && referenceSolution.files.length > 0) {\n      for (const filePath of referenceSolution.files) {\n        const fullPath = path.isAbsolute(filePath)\n          ? filePath\n          : path.join(workingDirectory, filePath);\n        try {\n          const content = await fs.readFile(fullPath, 'utf-8');\n          files.set(filePath, content);\n        } catch {\n          files.set(filePath, '[REFERENCE FILE NOT FOUND]');\n        }\n      }\n    }\n\n    return files;\n  }\n\n  private buildPairwisePrompt(\n    evalCase: any,\n    result: any,\n    rubric: Rubric,\n    generatedFiles: Map<string, string>,\n    referenceFiles: Map<string, string>\n  ): string {\n    const toolCallSummary = this.formatToolCalls(result.toolCalls);\n\n    let generatedFilesSection = '';\n    if (generatedFiles && generatedFiles.size > 0) {\n      const fileContents = Array.from(generatedFiles.entries())\n        .map(([filePath, content]) => `### ${filePath}\\n\\`\\`\\`\\n${content}\\n\\`\\`\\``)\n        .join('\\n\\n');\n      generatedFilesSection = `\\n## Generated Output (Candidate)\\n${fileContents}\\n`;\n    }\n\n    let referenceFilesSection = '';\n    if (referenceFiles && referenceFiles.size > 0) {\n      const fileContents = Array.from(referenceFiles.entries())\n        .map(([filePath, content]) => `### ${filePath}\\n\\`\\`\\`\\n${content}\\n\\`\\`\\``)\n        .join('\\n\\n');\n      referenceFilesSection = `\\n## Reference Solution (Gold Standard)\\n${fileContents}\\n`;\n    }\n\n    return `You are an AI evaluation judge performing PAIRWISE COMPARISON. Compare the candidate output against the reference solution.\n\n## Evaluation Case\nID: ${evalCase.id}\nName: ${evalCase.name}\nDescription: ${evalCase.description}\nCategory: ${evalCase.category}\nOriginal Prompt: ${evalCase.prompt || 'N/A'}\nExpected Behavior: ${evalCase.expectedBehavior || 'N/A'}\n\n## Rubric\n${rubric.content}\n${referenceFilesSection}\n${generatedFilesSection}\n## Execution Result\nSuccess: ${result.success}\nAI Response: ${result.output || 'N/A'}\nDuration: ${result.duration}ms\nTool Calls: ${toolCallSummary}\nError: ${result.error?.message || 'None'}\n\n## Pairwise Comparison Instructions\n1. Compare the candidate output against the reference solution\n2. Evaluate how closely the candidate matches the reference in terms of:\n   - Functional correctness\n   - Code quality and style\n   - Completeness of implementation\n3. Award scores based on how well the candidate achieves the same goals as the reference\n4. A candidate that fully matches or exceeds the reference should score 90-100\n5. Output your evaluation in the following JSON format:\n\n\\`\\`\\`json\n{\n  \"score\": <number 0-100>,\n  \"passed\": <boolean - true if score >= 70>,\n  \"confidence\": <number 0-1 indicating how confident you are in this evaluation>,\n  \"reasoning\": \"<your detailed reasoning comparing candidate to reference, 2-4 sentences>\"\n}\n\\`\\`\\`\n\nOutput only the JSON block, no other text.`;\n  }\n\n  private async readTargetFiles(\n    evalCase: any,\n    workingDirectory: string\n  ): Promise<Map<string, string>> {\n    const files = new Map<string, string>();\n\n    const targetFiles = evalCase.targetFiles as string[] | undefined;\n    if (!targetFiles || targetFiles.length === 0) {\n      return files;\n    }\n\n    for (const filePath of targetFiles) {\n      const fullPath = path.join(workingDirectory, filePath);\n      try {\n        const content = await fs.readFile(fullPath, 'utf-8');\n        files.set(filePath, content);\n      } catch {\n        files.set(filePath, '[FILE NOT FOUND]');\n      }\n    }\n\n    return files;\n  }\n\n  private buildPrompt(\n    evalCase: any,\n    result: any,\n    rubric: Rubric,\n    generatedFiles?: Map<string, string>\n  ): string {\n    const toolCallSummary = this.formatToolCalls(result.toolCalls);\n\n    let generatedFilesSection = '';\n    if (generatedFiles && generatedFiles.size > 0) {\n      const fileContents = Array.from(generatedFiles.entries())\n        .map(([filePath, content]) => `### ${filePath}\\n\\`\\`\\`\\n${content}\\n\\`\\`\\``)\n        .join('\\n\\n');\n      generatedFilesSection = `\\n## Generated Files\\n${fileContents}\\n`;\n    }\n\n    return `You are an AI evaluation judge. Evaluate the following AI execution result against the rubric.\n\n## Evaluation Case\nID: ${evalCase.id}\nName: ${evalCase.name}\nDescription: ${evalCase.description}\nCategory: ${evalCase.category}\nOriginal Prompt: ${evalCase.prompt || 'N/A'}\nExpected Behavior: ${evalCase.expectedBehavior || 'N/A'}\n\n## Rubric\n${rubric.content}\n\n## Execution Result\nSuccess: ${result.success}\nAI Response: ${result.output || 'N/A'}\nDuration: ${result.duration}ms\nTool Calls: ${toolCallSummary}\nError: ${result.error?.message || 'None'}\n${generatedFilesSection}\n## Instructions\n1. Carefully evaluate the result against each criterion in the rubric\n2. Consider both what the AI did correctly and what it failed to do\n3. For code-gen evals, focus on the Generated Files section to evaluate the actual code quality\n4. Provide a score from 0-100 based on the rubric criteria\n5. Be specific in your reasoning - cite specific behaviors observed\n6. Output your evaluation in the following JSON format:\n\n\\`\\`\\`json\n{\n  \"score\": <number 0-100>,\n  \"passed\": <boolean - true if score >= 70>,\n  \"confidence\": <number 0-1 indicating how confident you are in this evaluation>,\n  \"reasoning\": \"<your detailed reasoning, 2-4 sentences>\"\n}\n\\`\\`\\`\n\nOutput only the JSON block, no other text.`;\n  }\n\n  private parseResponse(text: string): JudgeResult {\n    const parsed = parseLLMJudgeResponse(text);\n    return this.createResult(parsed);\n  }\n\n  private formatToolCalls(toolCalls: any[] | undefined): string {\n    return formatToolCallsSummary(toolCalls);\n  }\n}\n\nexport function createLLMCodeQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-code-quality', 'code-quality.md', options);\n}\n\nexport function createLLMRoutingQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-routing-quality', 'routing-quality.md', options);\n}\n\nexport function createLLMResponseQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-response-quality', 'response-quality.md', options);\n}\n\nexport function createLLMConversationQualityJudge(options: LLMJudgeOptions = {}): LLMJudge {\n  return new LLMJudge('llm-conversation-quality', 'conversation-quality.md', options);\n}\n\nexport interface ParsedLLMResponse {\n  passed: boolean;\n  score: number;\n  confidence: number;\n  reasoning: string;\n}\n\nexport function parseLLMJudgeResponse(text: string): ParsedLLMResponse {\n  const jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n  const jsonContent = jsonMatch ? jsonMatch[1] : text;\n\n  try {\n    const parsed = JSON.parse(jsonContent.trim());\n\n    return {\n      passed: parsed.passed ?? parsed.score >= 70,\n      score: Math.max(0, Math.min(100, parsed.score || 0)),\n      confidence: Math.max(0, Math.min(1, parsed.confidence || 0.5)),\n      reasoning: parsed.reasoning || 'No reasoning provided',\n    };\n  } catch {\n    return {\n      passed: false,\n      score: 0,\n      reasoning: `Failed to parse LLM response: ${text.substring(0, 200)}...`,\n      confidence: 0,\n    };\n  }\n}\n\nexport function formatToolCallsSummary(toolCalls: any[] | undefined): string {\n  if (!toolCalls || toolCalls.length === 0) {\n    return 'None';\n  }\n\n  if (toolCalls.length <= 10) {\n    return toolCalls.map((t: any) => t.toolName).join(', ');\n  }\n\n  const toolCounts = new Map<string, number>();\n  for (const call of toolCalls) {\n    const name = call.toolName || 'unknown';\n    toolCounts.set(name, (toolCounts.get(name) || 0) + 1);\n  }\n\n  return Array.from(toolCounts.entries())\n    .map(([name, count]) => count > 1 ? `${name} (x${count})` : name)\n    .join(', ');\n}\n","import type { Judge, JudgeType } from './judge-interface.js';\nimport { FileExistenceJudge } from './builtin/file-existence.js';\nimport { ToolInvocationJudge } from './builtin/tool-invocation.js';\nimport { PatternMatchJudge } from './builtin/pattern-match.js';\nimport { AgentRoutingJudge } from './builtin/agent-routing.js';\nimport { SkillInvocationJudge } from './builtin/skill-invocation.js';\nimport { SyntaxValidationJudge } from './builtin/syntax-validation.js';\nimport {\n  createLLMCodeQualityJudge,\n  createLLMRoutingQualityJudge,\n  createLLMResponseQualityJudge,\n  createLLMConversationQualityJudge,\n} from './builtin/llm-judge.js';\n\nexport class JudgeRegistry {\n  private judges: Map<string, Judge> = new Map();\n\n  constructor() {\n    this.registerBuiltInJudges();\n  }\n\n  private registerBuiltInJudges(): void {\n    this.register(new FileExistenceJudge());\n    this.register(new ToolInvocationJudge());\n    this.register(new PatternMatchJudge());\n    this.register(new AgentRoutingJudge());\n    this.register(new SkillInvocationJudge());\n    this.register(new SyntaxValidationJudge());\n    this.register(createLLMCodeQualityJudge());\n    this.register(createLLMRoutingQualityJudge());\n    this.register(createLLMResponseQualityJudge());\n    this.register(createLLMConversationQualityJudge());\n  }\n\n  register(judge: Judge): void {\n    this.judges.set(judge.id, judge);\n  }\n\n  /** @internal Used for testing only */\n  unregister(id: string): boolean {\n    return this.judges.delete(id);\n  }\n\n  get(id: string): Judge | undefined {\n    return this.judges.get(id);\n  }\n\n  has(id: string): boolean {\n    return this.judges.has(id);\n  }\n\n  list(): string[] {\n    return Array.from(this.judges.keys());\n  }\n\n  /** @internal Used for testing only */\n  listByType(type: JudgeType): string[] {\n    return Array.from(this.judges.entries())\n      .filter(([_, judge]) => judge.type === type)\n      .map(([id]) => id);\n  }\n\n  /** @internal Used for testing only */\n  getAll(): Judge[] {\n    return Array.from(this.judges.values());\n  }\n}\n\nlet defaultRegistry: JudgeRegistry | null = null;\n\nexport function getJudgeRegistry(): JudgeRegistry {\n  if (!defaultRegistry) {\n    defaultRegistry = new JudgeRegistry();\n  }\n  return defaultRegistry;\n}\n\n/** @internal Used for testing only */\nexport function resetJudgeRegistry(): void {\n  defaultRegistry = null;\n}\n"]}